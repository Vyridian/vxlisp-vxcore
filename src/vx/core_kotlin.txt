  interface Type_replfunc {
    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any
  }

  interface Type_replfunc_async {
    fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any>
  }

  val emptylistany : List<vx_core.Type_any> = ArrayList<vx_core.Type_any>()

  val emptymapany : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

  fun <T> immutablelist(
    listany : List<T>) : List<T> {
    return listany.toList()
  }

  fun <T> immutablemap(
    mapany : Map<String, T>) : Map<String, T> {
    return LinkedHashMap<String, T>(mapany)
  }

  open class Class_base {
    internal var vx_iref : Int = 0
    internal var vx_p_constdef : vx_core.Type_constdef? = null
    internal var vxmsgblock : vx_core.Type_msgblock? = null
    fun vx_constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef
      val constdef : vx_core.Type_constdef? = this.vx_p_constdef
      if (constdef == null) {
        output = vx_core.e_constdef
      } else {
        output = constdef
      }
      return output
    }
    fun vx_dispose() : List<Type_any> {
      this.vx_iref = 0
      this.vxmsgblock = null
      return vx_core.emptylistany
    }
    fun vx_msgblock() : vx_core.Type_msgblock {
      var output : vx_core.Type_msgblock
      val msgblock : vx_core.Type_msgblock? = this.vxmsgblock
      if (msgblock == null) {
        output = vx_core.e_msgblock
      } else {
        output = msgblock
      }
      return output
    }
    fun vx_release() : Boolean {
      var output : Boolean = false
      if (this.vx_iref < 0) {
      } else if (this.vx_iref == 0) {
        this.vx_iref = -1
        output = true
      } else {
        this.vx_iref -= 1
      }
      return output
    }
    fun vx_reserve() : Unit {
      this.vx_iref += 1
    }
  }

/*
  class KeyValue<T> {
    var key : String = ""
    var value : T = null
  }
*/

  fun constdef_new(
    pkgname : String,
    name : String,
    typ : vx_core.Type_any) : vx_core.Type_constdef {
    var output : vx_core.Class_constdef = vx_core.Class_constdef()
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname)
    output.vx_p_name = vx_core.vx_new_string(name)
    output.vx_p_type = typ
    return output
  }

  fun funcdef_new(
    pkgname : String,
    name : String,
    idx : Int,
    async : Boolean,
    typ : vx_core.Type_any) : vx_core.Type_funcdef {
    var output : vx_core.Class_funcdef = vx_core.Class_funcdef()
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname)
    output.vx_p_name = vx_core.vx_new_string(name)
    output.vx_p_idx = vx_core.vx_new_int(idx)
    output.vx_p_async = vx_core.vx_new_boolean(async)
    output.vx_p_type = typ
    return output
  }

  fun arrayany_from_anylist(
    list : vx_core.Type_anylist) : Array<vx_core.Type_any> {
    val listany : List<vx_core.Type_any> = list.vx_list()
    val output : Array<vx_core.Type_any> = listany.toTypedArray()
    return output
  }

  //@SafeVarargs
  fun <T> arraylist_from_array(
    vararg items : T) : List<T> {
    var output : List<T> = items.asList()
    output = vx_core.immutablelist(output)
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> arraylist_from_arraylist(
    generic_any_1 : T,
    listval : List<U>) : List<T> {
    val list : MutableList<T> = ArrayList<T>()
    for (value : vx_core.Type_any in listval) {
      val t_val : T = vx_core.f_any_from_any(generic_any_1, value)
      list.add(t_val)
    }
    val output = vx_core.immutablelist(list)
    return output
  }

  fun <T, U> arraylist_from_arraylist_fn(
    listval : List<U>,
    fn_any_from_any : (U) -> T) : List<T> {
    val list : MutableList<T> = ArrayList<T>()
    for (value_u : U in listval) {
      val t_val : T = fn_any_from_any(value_u)
      list.add(t_val)
    }
    val output = vx_core.immutablelist(list)
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> arraylist_from_linkedhashmap(
    generic_any_1 : T,
    mapval : Map<String, U>) : List<T> {
    val list : MutableList<T> = ArrayList<T>()
    val keys : Set<String> = mapval.keys
    for (key : String in keys) {
      val u_val : U? = mapval.get(key)
      if (u_val != null) {
        val t_val : T = vx_core.f_any_from_any(generic_any_1, u_val)
        list.add(t_val)
      }
    }
    val output = vx_core.immutablelist(list)
    return output
  }

  fun <T, U> arraylist_from_linkedhashmap_fn(
    mapval : Map<String, U>,
    fn_any_from_key_value : (String, U) -> T) : List<T> {
    val list : MutableList<T> = ArrayList<T>()
    val keys : Set<String> = mapval.keys
    for (key : String in keys) {
      val u_val : U? = mapval.get(key)
      if (u_val != null) {
        val t_val : T = fn_any_from_key_value(key, u_val)
        list.add(t_val)
      }
    }
    val output = vx_core.immutablelist(list)
    return output
  }

  fun <T> async_new_completed(
    value : T) : CompletableFuture<T> {
    val output : CompletableFuture<T> = CompletableFuture.completedFuture(value)
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> async_from_async(
    generic_any_1 : T,
    future : CompletableFuture<U>) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply({value : U ->
      val output_1 : T = vx_core.f_any_from_any(generic_any_1, value)
      output_1
    })
    return output
  }

  fun <T, U> async_from_async_fn(
    future : CompletableFuture<U>,
    fn : (U) -> T) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply(fn)
    return output
  }

  fun <T> map_from_list_fn(
    listval : List<T>,
    fn_any_from_any : (T) -> vx_core.Type_string) : Map<String, T> {
    var map : MutableMap<String, T> = LinkedHashMap<String, T>()
    for (value : T in listval) {
      val valkey : vx_core.Type_string = fn_any_from_any(value)
      val key : String = valkey.vx_string()
      map.put(key, value)
    }
    val output = vx_core.immutablemap<T>(map)
    return output
  }

  // vx_any_from_func(generic_any_1, func, args...)
  fun <T : vx_core.Type_any> vx_any_from_func(
    generic_any_1 : T,
    func : vx_core.Type_replfunc,
    vararg args : vx_core.Type_any) : T {
    val anylist : vx_core.Type_anylist = vx_core.vx_new_anylist(*args)
    val value : vx_core.Type_any = func.vx_repl(anylist)
    val output : T = vx_core.f_any_from_any(generic_any_1, value)
    return output
  }

  // vx_any_from_list_start_reduce(any-1, list-2, any-1, any<-reduce)
  fun <T : vx_core.Type_any, N : vx_core.Type_list> vx_any_from_list_start_reduce(
    generic_any_1 : T,
    list : N,
    valstart : T,
    fn_reduce : vx_core.Func_any_from_reduce) : T {
    var output : T = valstart
    val listval : List<vx_core.Type_any> = list.vx_list()
    for (item : vx_core.Type_any in listval) {
      output = fn_reduce.vx_any_from_reduce(
        generic_any_1, output, item
      )
    }
    return output
  }

  // vx_any_from_list_start_reduce_next(any-1, list-2, any-1, any<-reduce-next)
  fun <T : vx_core.Type_any, N : vx_core.Type_list> vx_any_from_list_start_reduce_next(
    generic_any_1 : T,
    list : N,
    valstart : T,
    fn_reduce_next : vx_core.Func_any_from_reduce_next) : T {
    var output : T = valstart
    val listval : List<vx_core.Type_any> = list.vx_list()
    var current : vx_core.Type_any = vx_core.e_any
    var first : Boolean = true
    for (next : vx_core.Type_any in listval) {
      if (first) {
        first = false
      } else {
        output = fn_reduce_next.vx_any_from_reduce_next(generic_any_1, output, current, next)
      }
      current = next
    }
    return output
  }

  // vx_any_from_map(generic_any_1, map, string)
  fun <T : vx_core.Type_any> vx_any_from_map(
    generic_any_1 : T,
    valuemap : vx_core.Type_map,
    key : vx_core.Type_string) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    var skey : String = key.vx_string()
    if (skey.startsWith(":")) {
      skey = skey.substring(1);
    }
    val value : vx_core.Type_any = valuemap.vx_map().getOrDefault(
      skey, output
    )
    output = vx_core.f_any_from_any(
      generic_any_1,
      value
    )
    return output
  }

  // vx_any_from_map_start_reduce(any-1, map-2, any-1, any<-any-key-value)
  fun <T : vx_core.Type_any, N : vx_core.Type_map> vx_any_from_map_start_reduce(
    generic_any_1 : T,
    map : N,
    start : T,
    fn_reduce : vx_core.Func_any_from_any_key_value) : T {
    var output : T = start
    val mapval : Map<String, vx_core.Type_any> = map.vx_map()
    val keys : Set<String> = mapval.keys
    for (skey : String in keys) {
      val key : vx_core.Type_string = vx_core.vx_new_string(skey)
      val value : vx_core.Type_any? = mapval.get(skey)
      if (value != null) {
        output = fn_reduce.vx_any_from_any_key_value(
          generic_any_1, output, key, value
        )
      }
    }
    return output
  }

  // vx_any_first_from_list_fn(generic_any_1, list, fn_any)
  fun <T : vx_core.Type_any> vx_any_first_from_list_fn(
    generic_any_1 : T,
    list : vx_core.Type_list,
    fn_any : (vx_core.Type_any) -> T) : T {
    val empty : T = vx_core.f_empty(generic_any_1)
    var output : T = empty
    val listany : List<vx_core.Type_any> = list.vx_list()
    for (any : vx_core.Type_any in listany) {
      val tany : T = vx_core.f_any_from_any(generic_any_1, any)
      val value : T = fn_any(tany)
      if (value != empty) {
        output = value
        break
      }
    }
    return output
  }

  fun <T> vx_async_new_from_value(
    value : T) : CompletableFuture<T>  {
    val output : CompletableFuture<T> = CompletableFuture.completedFuture(
      value
    )
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_async_from_async(
    generic_any_1 : T,
    future : CompletableFuture<U>) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply({value ->
      val output_1 : T = vx_core.f_any_from_any(generic_any_1, value)
      output_1
    })
    return output
  }

  fun <T, U> vx_async_from_async_fn(
    future : CompletableFuture<U>,
    fn : (U) -> T) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply(fn)
    return output
  }

  fun <T> vx_async_arraylist_from_arraylist_async(
    list_future_t : List<CompletableFuture<T>>) : CompletableFuture<List<T>> {
    val array_future_t : Array<CompletableFuture<*>> = list_future_t.toTypedArray()
    val future_void : CompletableFuture<Void> = CompletableFuture.allOf(
      *array_future_t
    )
    val output : CompletableFuture<List<T>> = future_void.thenApply {
      _ ->
      val list : List<T> = list_future_t.map {
        future_t : CompletableFuture<T> ->
        val output_2 : T = future_t.get()
        output_2
      }
      val output_1 : List<T> = vx_core.immutablelist<T>(list)
      output_1
    }
    return output
  }

  // vx_boolean_from_string_ends(string, string)
  fun vx_boolean_from_string_ends(
    text : String,
    ends : String) : Boolean {
    return text.endsWith(ends)
  }

  // vx_boolean_from_string_find(string, string)
  fun vx_boolean_from_string_find(
    text : String,
    find : String
  ) : Boolean {
    return text.contains(find)
  }

  // vx_boolean_from_string_starts(string, string)
  fun vx_boolean_from_string_starts(
    text : String,
    starts : String) : Boolean {
    return text.startsWith(starts)
  }

  // vx_boolean_write_from_map_name_value(map, string, any)
  fun vx_boolean_write_from_map_name_value(
    valuemap : vx_core.Type_map,
    name : vx_core.Type_string,
    value : vx_core.Type_any) : vx_core.Type_boolean {
    val output : vx_core.Type_boolean = valuemap.vx_set(name, value)
    return output
  }

  // vx_compare(any, any)
  fun vx_compare(
    val1 : vx_core.Type_any,
    val2 : vx_core.Type_any) : vx_core.Type_int {
    var intresult : Int = 0
    if ((val1 is vx_core.Type_number) && (val2 is vx_core.Type_number)) {
      val num1 = val1 as vx_core.Type_number
      val num2 = val2 as vx_core.Type_number
      val float1 : Float = vx_core.vx_new(vx_core.t_float, num1).vx_float()
      val float2 : Float = vx_core.vx_new(vx_core.t_float, num2).vx_float()
      if (float1 < float2) {
        intresult = -1
      } else if (float1 > float2) {
        intresult = 1
      }
    } else {
      val stringval1 : String = vx_core.f_string_from_any(val1).vx_string()
      val stringval2 : String = vx_core.f_string_from_any(val2).vx_string()
      val compare : Int = stringval1.compareTo(stringval2)
      if (compare > 0) {
        intresult = 1
      } else if (compare < 0) {
        intresult = -1
      }
    }
    val output : vx_core.Type_int = vx_core.vx_new_int(intresult)
    return output
  }

  // vx_constdef<-any(any)
  fun vx_constdef_from_any(
    value : vx_core.Type_any) : vx_core.Type_constdef {
    val output : vx_core.Type_constdef = value.vx_constdef()
    return output
  }

  // vx_contains(list-1, any)
  fun <T : vx_core.Type_list> vx_contains_1(
    values : T,
    find : vx_core.Type_any) : vx_core.Type_boolean {
    var booleanresult : Boolean = false
    val listvalues : List<vx_core.Type_any> = values.vx_list()
    for (item : vx_core.Type_any in listvalues) {
      val iseq : vx_core.Type_boolean = vx_core.f_eq(
        item, find
      )
      if (iseq.vx_boolean()) {
        booleanresult = true
        break
      }
    }
    val output : vx_core.Type_boolean = vx_core.vx_new_boolean(
      booleanresult
    )
    return output
  }

  // vx_copy(generic_any_1, args...)
  fun <T : vx_core.Type_any> vx_copy(
    copyval : T,
    vararg vals : Any) : T {
    val value : vx_core.Type_any = copyval.vx_copy(*vals)
    val output : T = vx_core.f_any_from_any(copyval, value)
    return output
  }

  // vx_empty(generic_any_1)
  fun <T : vx_core.Type_any> vx_empty(
    type : T) : T {
    @Suppress("UNCHECKED_CAST")
    val output : T = type.vx_empty() as T
    return output
  }

  // vx_eqeq(any, any)
  fun vx_eqeq(
    val1 : vx_core.Type_any,
    val2 : vx_core.Type_any) : Boolean {
    var output : Boolean = false
    if (val1 == val2) {
      output = true
    } else if (val1.vx_msgblock() != vx_core.e_msgblock) {
    } else if (val2.vx_msgblock() != vx_core.e_msgblock) {
    } else {
      val type1 : vx_core.Type_any = val1.vx_type()
      val type2 : vx_core.Type_any = val2.vx_type()
      if (type1 != type2) {
      } else if (type1 == vx_core.t_int) {
        val valint1 : vx_core.Type_int = val1 as vx_core.Type_int
        val valint2 : vx_core.Type_int = val1 as vx_core.Type_int
        if (valint1.vx_int() == valint2.vx_int()) {
          output = true
        }
      } else if (type1 == vx_core.t_float) {
        val valfloat1 : vx_core.Type_float = val1 as vx_core.Type_float
        val valfloat2 : vx_core.Type_float = val2 as vx_core.Type_float
        if (valfloat1.vx_float() == valfloat2.vx_float()) {
          output = true
        }
      } else if (type1 == vx_core.t_decimal) {
        val valdecimal1 : vx_core.Type_decimal = val1 as vx_core.Type_decimal
        val valdecimal2 : vx_core.Type_decimal = val2 as vx_core.Type_decimal
        if (valdecimal1.vx_string() == valdecimal2.vx_string()) {
          output = true
        }
      } else if (type1 == vx_core.t_string) {
        val valstring1 : vx_core.Type_string = val1 as vx_core.Type_string
        val valstring2 : vx_core.Type_string = val2 as vx_core.Type_string
        if (valstring1.vx_string() == valstring2.vx_string()) {
          output = true
        }
      }
    }
    return output
  }

  // vx_float_from_number(number)
  fun vx_float_from_number(
    num : vx_core.Type_number) : Float {
    var output : Float = 0f
    val type : vx_core.Type_any = num.vx_type()
    if (type == vx_core.t_float) {
      val floatval : vx_core.Type_float = vx_core.f_any_from_any(vx_core.t_float, num)
      output = floatval.vx_float()
    } else if (type == vx_core.t_int) {
      val intval : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, num)
      output = intval.vx_int().toFloat()
    } else if (type == vx_core.t_decimal) {
      val decval : vx_core.Type_decimal = vx_core.f_any_from_any(vx_core.t_decimal, num)
      output = decval.vx_float()
    }
    return output
  }

  // vx_float_from_string(string)
  fun vx_float_from_string(
    text : String) : Float {
    var output : Float = 0f
    try {
      output = text.toFloat()
    } catch (ex : Exception) {
    }    
    return output
  }

  // vx_global_package_set(string, map<any>, map<any>, map<func>)
  fun vx_global_package_set(
    pkgname : String,
    maptype : Map<String, vx_core.Type_any>,
    mapconst : Map<String, vx_core.Type_any>,
    mapfunc : Map<String, vx_core.Type_func>) : Unit {
    val typemap : vx_core.Class_typemap = vx_core.Class_typemap()
    typemap.vx_p_map = vx_core.immutablemap(maptype)
    val constmap : vx_core.Class_constmap = vx_core.Class_constmap()
    constmap.vx_p_map = vx_core.immutablemap(mapconst)
    val funcmap : vx_core.Class_funcmap = vx_core.Class_funcmap()
    funcmap.vx_p_map = vx_core.immutablemap(mapfunc)
    val global : vx_core.Class_project = vx_core.c_global as vx_core.Class_project
    var typepackagemap : vx_core.Type_packagemap? = global.vx_p_packagemap
    var packagemap : vx_core.Class_packagemap = vx_core.Class_packagemap()
    if (typepackagemap == null) {
      global.vx_p_packagemap = packagemap
    } else {
      packagemap = typepackagemap as vx_core.Class_packagemap
    }
    val mappackage : MutableMap<String, vx_core.Type_package> = LinkedHashMap<String, vx_core.Type_package>(
      packagemap.vx_p_map
    )
    val pkg : vx_core.Class_package = vx_core.Class_package()
    pkg.vx_p_constmap = constmap
    pkg.vx_p_typemap = typemap
    pkg.vx_p_funcmap = funcmap
    mappackage.put(pkgname, pkg)
    packagemap.vx_p_map = vx_core.immutablemap<vx_core.Type_package>(mappackage)
  }

  fun <T : vx_core.Type_any> vx_if_2(
    generic_any_1 : T,
    thenelselist : vx_core.Type_thenelselist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    val fn_any : vx_core.Func_any_from_func = vx_core.vx_any_first_from_list_fn(
      vx_core.t_any_from_func,
      thenelselist,
      {any : vx_core.Type_any ->
        var fnany : vx_core.Func_any_from_func = vx_core.e_any_from_func
        if (any is vx_core.Type_thenelse) {
          val thenelse : vx_core.Type_thenelse = any as vx_core.Type_thenelse
          val code : vx_core.Type_string = thenelse.code()
          val scode : String = code.vx_string()
          if (scode.equals(":then")) {
            val fn_cond : vx_core.Func_boolean_from_func = thenelse.fn_cond()
            val cond : vx_core.Type_boolean = fn_cond.vx_boolean_from_func()
            if (cond.vx_boolean() == true) {
              fnany = thenelse.fn_any()
            }
          } else if (scode.equals(":else")) {
            fnany = thenelse.fn_any()
          }
        }
        fnany
      }
    )
    if (fn_any != vx_core.e_any_from_func) {
      output = fn_any.vx_any_from_func(generic_any_1)
    }
    return output
  }

  // vx_int_from_string(string)
  fun vx_int_from_string(
    text : String) : Int {
    var output : Int = 0
    try {
      output = text.toInt()
    } catch (ex : Exception) {
    }    
    return output
  }

  // vx_int_from_string_find(string, string)
  fun vx_int_from_string_find(
    text : String,
    find : String) : Int {
    return text.indexOf(find)
  }

  // vx_int_from_string_findlast(string, string)
  fun vx_int_from_string_findlast(
    text : String,
    findlast : String
  ) : Int {
    return text.lastIndexOf(findlast)
  }

  // vx_is_float(string)
  fun vx_is_float(
    text : String) : Boolean {
    var output : Boolean = false
    try {
      text.toFloat()
      output = true
    } catch (ex : Exception) {
    }    
    return output
  }

  // vx_is_float(any)
  fun vx_is_float(
    value : vx_core.Type_any) : Boolean {
    var output : Boolean = false
    if (value is vx_core.Type_number) {
      output = true
    } else if (value is vx_core.Type_string) {
      val valuestring : vx_core.Type_string = value as vx_core.Type_string
      output = vx_core.vx_is_float(valuestring.vx_string())
    }
    return output
  }

  // vx_is_int(string)
  fun vx_is_int(
    text : String) : Boolean {
    var output : Boolean = false
    if (text == "notanumber") {
      output = true
    } else if (text == "infinity") {
      output = true
    } else if (text == "neginfinity") {
      output = true
    } else {
      try {
        Integer.parseInt(text)
        output = true
      } catch (ex : Exception) {
      }
    }
    return output
  }

  // vx_is_int(any)
  fun vx_is_int(
    value : vx_core.Type_any) : Boolean {
    var result : Boolean = false
    if (value == vx_core.c_infinity) {
      result = true
    } else if (value == vx_core.c_neginfinity) {
      result = true
    } else if (value == vx_core.c_notanumber) {
      result = true
    } else if (value is vx_core.Type_int) {
      result = true
    } else if (value is vx_core.Type_float) {
      val valfloat : vx_core.Type_float = value as vx_core.Type_float
      val floatval : Float = valfloat.vx_float()
      if (floatval == floatval.toInt().toFloat()) {
        result = true
      }
    } else if (value is vx_core.Type_decimal) {
      val valdec : vx_core.Type_decimal = value as vx_core.Type_decimal
      val strval : String = valdec.vx_string()
      try {
        val floatval : Float = strval.toFloat()
        if (floatval == floatval.toInt().toFloat()) {
          result = true
        }
      } catch (ex : Exception) {
      }
    } else if (value is vx_core.Type_string) {
      val valstr : vx_core.Type_string = value as vx_core.Type_string
      val strval : String = valstr.vx_string()
      result = vx_is_int(strval)
    }
    return result
  }

  // vx_log(object...)
  fun vx_log(
    vararg values : Any) : Unit {
    for (value : Any in values) {
      var text : String = ""
      if (value is vx_core.Type_string) {
        val valstring : vx_core.Type_string = value as vx_core.Type_string
        text = valstring.vx_string()
      } else if (value is vx_core.Type_any) {
        val valany : vx_core.Type_any = value as vx_core.Type_any
        text = vx_core.vx_string_from_any(valany)
      } else if (value is Array<*>) {
        val items : Array<Any> = value as Array<Any>
        text = "(array"
        for (item : Any in items) {
          if (item is vx_core.Type_string) {
            val valstring : vx_core.Type_string = item as vx_core.Type_string
            text += "\n " + valstring.vx_string()
          } else if (item is vx_core.Type_any) {
            val valany : vx_core.Type_any = item as vx_core.Type_any
            text += "\n " + vx_core.vx_string_from_any(valany)
          } else {
            text += "\n " + item.toString()
          }
        }
        text += "\n)"
      } else if (value is List<*>) {
        val items : List<Any> = value as List<Any>
        text = "(list"
        for (item : Any in items) {
          if (item is vx_core.Type_string) {
            val valstring : vx_core.Type_string = item as vx_core.Type_string
            text += "\n " + valstring.vx_string()
          } else if (item is vx_core.Type_any) {
            val valany : vx_core.Type_any = item as vx_core.Type_any
            text += "\n " + vx_core.vx_string_from_any(valany)
          } else {
            text += "\n " + item.toString()
          }
        }
        text += "\n)"
      } else {
        text = value.toString()
      }
      println(text)
    }
  }

  // vx_msg_error
  fun vx_msg_error(
    text : String) : Type_msg {
    val output : Class_msg = Class_msg()
    output.vx_p_text = vx_core.vx_new_string(text)
    output.vx_p_severity = vx_core.c_msg_severe
    return output
  }

  // vx_msg_from_error
  fun vx_msg_from_error(
    text : String) : vx_core.Type_msg {
    var output : Class_msg = Class_msg()
    output.vx_p_text = vx_core.vx_new_string(text)
    output.vx_p_severity = vx_core.c_msg_severe
    return output
  }

  // vx_msg_from_error
  fun vx_msg_from_error(
    path : String,
    code : String,
    detail : vx_core.Type_any) : vx_core.Type_msg {
    var output : Class_msg = Class_msg()
    output.vx_p_path = vx_core.vx_new_string(path)
    output.vx_p_code = vx_core.vx_new_string(code)
    output.vx_p_detail = detail
    output.vx_p_severity = vx_core.c_msg_severe
    return output
  }

  // vx_msg_from_exception
  fun vx_msg_from_exception(
    text : String,
    err : Exception) : Type_msg {
    val output : Class_msg = Class_msg()
    output.vx_p_text = vx_core.vx_new_string(text)
    output.vx_p_severity = vx_core.c_msg_severe
    output.err = err
    vx_core.vx_log(output)
    return output
  }

  // vx_msgblock_from_copy_arrayval(msgblock, any...)
  fun vx_msgblock_from_copy_arrayval(
    copy : vx_core.Type_any,
    vararg vals : Any) : vx_core.Type_msgblock {
    var output : vx_core.Type_msgblock = vx_core.e_msgblock
    val copymsgblock : vx_core.Type_msgblock = copy.vx_msgblock()
    if (copymsgblock != vx_core.e_msgblock) {
      output = copymsgblock
    }
    return output
  }

  // vx_new(generic_any_1, args...)
  fun <T : vx_core.Type_any> vx_new(
    generic_any_1 : T,
    vararg vals : Any) : T {
    val value : vx_core.Type_any = generic_any_1.vx_new(*vals)
    val output : T = vx_core.f_any_from_any(generic_any_1, value)
    return output
  }

  // vx_new_anylist(Array<any>)
  fun vx_new_anylist(
    vararg anys : vx_core.Type_any) : vx_core.Type_anylist {
    val listany : List<vx_core.Type_any> = anys.asList()
    return vx_new_anylist(listany)
  }

  fun vx_new_anylist(
    listany : List<vx_core.Type_any>) : vx_core.Type_anylist {
    val output : vx_core.Class_anylist = vx_core.Class_anylist()
    output.vx_p_list = immutablelist(listany)
    return output
  }

  // vx_new_list(T, List<any>)
  fun <T : vx_core.Type_list> vx_new_list(
    generic_list_1 : T,
    listval : List<vx_core.Type_any>) : T {
    val anylist : vx_core.Type_any = generic_list_1.vx_new(listval)
    val output : T = vx_core.f_any_from_any(generic_list_1, anylist)
    return output
  }

  // vx_type(generic_any_1)
  fun <T : vx_core.Type_any> vx_type(
    type : T) : T {
    @Suppress("UNCHECKED_CAST")
    val output : T = type.vx_type() as T
    return output
  }

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_1(
    generic_list_1 : X,
    values : Y,
    fn_any_from_any : vx_core.Func_any_from_any) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    val list_value : List<vx_core.Type_any> = values.vx_list()
    val fn : (vx_core.Type_any) -> vx_core.Type_any = {
      value : vx_core.Type_any ->
      val output_1 : vx_core.Type_any = fn_any_from_any.vx_any_from_any(
        vx_core.t_any, value
      )
      output_1
    }
    val list_result : List<vx_core.Type_any> = vx_core.arraylist_from_arraylist_fn<vx_core.Type_any, vx_core.Type_any>(
      list_value, fn
    )
    output = vx_core.f_any_from_any(
      generic_list_1,
      generic_list_1.vx_new(list_result)
    )
    return output
  }

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_async(
    generic_list_1 : X,
    values : Y,
    fn_any_from_any_async : vx_core.Func_any_from_any_async) : CompletableFuture<X> {
    val fn_future_from_any : (vx_core.Type_any) -> CompletableFuture<vx_core.Type_any> = {
      value : vx_core.Type_any ->
      val future_any : CompletableFuture<vx_core.Type_any> = fn_any_from_any_async.vx_any_from_any_async(
       vx_core.t_any, value
      )
      future_any
    }
    val fn_any_from_list : (List<vx_core.Type_any>) -> X = {
      list_result : List<vx_core.Type_any> ->
      val anylist : vx_core.Type_any = generic_list_1.vx_new(
        *list_result.toTypedArray()
      )
      val work : X = vx_core.f_any_from_any(
        generic_list_1,
        anylist
      )
      work
    }
    val list_value : List<vx_core.Type_any> = values.vx_list()
    val list_async_result : List<CompletableFuture<vx_core.Type_any>> = vx_core.arraylist_from_arraylist_fn(
      list_value, fn_future_from_any
    )
    val async_list_result : CompletableFuture<List<vx_core.Type_any>> = vx_core.vx_async_arraylist_from_arraylist_async(
      list_async_result
    )
    val output : CompletableFuture<X> = vx_core.vx_async_from_async_fn(
      async_list_result, fn_any_from_list
    )
    return output
  }

  // vx_list_from_list_intany(generic_list_1, list-2, any<-int-any)
  fun <T : vx_core.Type_list, U : vx_core.Type_list> vx_list_from_list_intany(
    generic_list_1 : T,
    valuelist : U,
    fn_any_from_int_any : vx_core.Func_any_from_int_any) : T {
    var output : T = vx_core.f_empty(generic_list_1)
    val listany : List<vx_core.Type_any> = valuelist.vx_list()
    if (listany.size > 0) {
      val listout : MutableList<vx_core.Type_any> = ArrayList<vx_core.Type_any>()
      var i : Int = 0
      for (value in listany) {
        i += 1
        val vali : vx_core.Type_int = vx_core.vx_new_int(i)
        val outval : vx_core.Type_any = fn_any_from_int_any.vx_any_from_int_any(
          vx_core.t_any, vali, value
        )
        listout.add(outval)
      }
      output = vx_core.vx_new_list(
        generic_list_1,
        listout
      )
    }
    return output
  }

  fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map_1(
    generic_list_1 : X,
    valuemap : O,
    fn_any_from_key_value : vx_core.Func_any_from_key_value) : X {
    val map_value : Map<String, vx_core.Type_any> = valuemap.vx_map()
    val fn_key_value : (String, vx_core.Type_any) -> vx_core.Type_any = {
      key : String, value : vx_core.Type_any ->
      val valkey : vx_core.Type_string = vx_core.vx_new_string(
        key
      )
      val output_1 : vx_core.Type_any = fn_any_from_key_value.vx_any_from_key_value(
        vx_core.t_any, valkey, value
      )
      output_1
    }
    val listresult : List<vx_core.Type_any> = vx_core.arraylist_from_linkedhashmap_fn(
      map_value, fn_key_value
    )
    val anylist : vx_core.Type_any = generic_list_1.vx_new(
      listresult
    )
    val output : X = vx_core.f_any_from_any(
      generic_list_1,
      anylist
    )
    return output
  }

  fun <N : vx_core.Type_map, Y : vx_core.Type_list> vx_map_from_list(
    generic_map_1 : N,
    vallist : Y,
    fn_any_from_any : vx_core.Func_any_from_any) : N {
    val listval : List<vx_core.Type_any> = vallist.vx_list()
    val fn_string_from_any : (vx_core.Type_any) -> vx_core.Type_string = {
      value : vx_core.Type_any ->
      val output_string : vx_core.Type_string = fn_any_from_any.vx_any_from_any(
        vx_core.t_string, value
      )
      output_string
    }
    val mapresult : Map<String, vx_core.Type_any> = vx_core.vx_map_from_list_fn(
      listval, fn_string_from_any
    )
    val mapval : vx_core.Type_map = generic_map_1.vx_new_from_map(
      mapresult
    )
    val output = vx_core.f_any_from_any(
      generic_map_1,
      mapval
    )
    return output
  }

  // vx_map_from_list_fn(generic_map, list, fn_any_from_key_value)
  fun <T> vx_map_from_list_fn(
    listval : List<T>,
    fn_any_from_any : (T) -> vx_core.Type_string) : Map<String, T> {
    val map : MutableMap<String, T> = LinkedHashMap<String, T>()
    for (value : T in listval) {
      val valkey : vx_core.Type_string = fn_any_from_any(
        value
      )
      val key : String = valkey.vx_string()
      map.put(key, value)
    }
    val output : Map<String, T> = vx_core.immutablemap<T>(map)
    return output
  }

  // vx_map_from_map_fn(generic_map, map, fn_any_from_key_value)
  fun <T : vx_core.Type_map> vx_map_from_map_fn(
    generic_map_1 : T,
    valuemap : vx_core.Type_map,
    fn_any_from_key_value : vx_core.Func_any_from_key_value) : T {
    var output : T = vx_core.f_empty(generic_map_1)
    val mapvalue : Map<String, vx_core.Type_any> = valuemap.vx_map()
    if (mapvalue.size > 0) {
      val typedef : vx_core.Type_typedef = vx_core.f_typedef_from_any(
        generic_map_1
      )
      val allowtypes : vx_core.Type_typelist = vx_core.f_allowtypes_from_typedef(
        typedef
      )
      val lallowtypes : List<vx_core.Type_any> = allowtypes.vx_list()
      val keys : Set<String> = mapvalue.keys
      val mapnew : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      for (key : String in keys) {
        val value : vx_core.Type_any? = mapvalue.get(key)
        if (value != null) {
          val stringkey : vx_core.Type_string = vx_core.vx_new_string(key)
          val chgvalue : vx_core.Type_any = fn_any_from_key_value.vx_any_from_key_value(
            vx_core.t_any, stringkey, value
          )
          val chgtype : vx_core.Type_any = chgvalue.vx_type()
          if (lallowtypes.contains(chgtype)) {
            mapnew.put(key, chgvalue)
          }
        }
      }
      output = vx_core.vx_new_map(
        generic_map_1, mapnew
      )
    }
    return output;
  }

  fun vx_new_boolean(
    isval : Boolean) : Type_boolean {
    var output : Type_boolean = vx_core.c_false
    if (isval) {
      output = vx_core.c_true
    }
    return output
  }

  fun vx_new_decimal(
    text : String) : vx_core.Type_decimal {
    var output : vx_core.Type_decimal
    if (text.equals("0") || text.equals("0.0")) {
      output = vx_core.e_decimal
    } else {
      val work : vx_core.Class_decimal = vx_core.Class_decimal()
      work.vxdecimal = text
      output = work
    }
    return output
  }

  fun vx_new_float(
    fval : Float) : Type_float {
    var output : Class_float = vx_core.Class_float()
    output.vxfloat = fval
    return output
  }

  fun vx_new_int(
    ival : Int) : Type_int {
    var output : Type_int
    if (ival == 0) {
      output = vx_core.e_int
    } else {
      val work : vx_core.Class_int = vx_core.Class_int()
      work.vxint = ival
      output = work
    }
    return output
  }

  // vx_new_map(T, Map<string, any>)
  fun <T : vx_core.Type_map> vx_new_map(
    generic_map_1 : T,
    mapval : Map<String, vx_core.Type_any>) : T {
    val anymap : vx_core.Type_any = generic_map_1.vx_new_from_map(mapval)
    val output : T = vx_core.f_any_from_any(
      generic_map_1, anymap
    )
    return output
  }

  fun vx_new_string(
    text : String) : Type_string {
    var output : Type_string
    if (text.equals("")) {
      output = vx_core.e_string
    } else {
      val work : Class_string = vx_core.Class_string()
      work.vxstring = text
      output = work
    }
    return output
  }

  fun vx_string_from_any(
    value : vx_core.Type_any) : String {
    return vx_string_from_any_indent(value, 0, false)
  }

  fun vx_string_from_any_indent(
    value : vx_core.Type_any,
    indent : Int,
    linefeed : Boolean) : String {
    val indenttext : String = " ".repeat(indent)
    var output : String = ""
    if (indent > 50) {
      output = "Error: Max Depth Exceeded"
    } else if (value == null) {
      output = "null"
    } else if (value == value.vx_type()) {
      if (value is vx_core.Type_func) {
        val valuefunc : vx_core.Type_func = value as vx_core.Type_func
        val funcdef : vx_core.Type_funcdef = valuefunc.vx_funcdef()
        output = funcdef.pkgname().vx_string() + "/" + funcdef.name().vx_string()
      } else {
        val typedef : vx_core.Type_typedef = value.vx_typedef()
        output = typedef.pkgname().vx_string() + "/" + typedef.name().vx_string()
      }
    } else if (value is vx_core.Type_boolean) {
      val valbool : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, value)
      if (valbool.vx_boolean() == true) {
        output = "true"
      } else {
        output = "false"
      }
    } else if (value is vx_core.Type_decimal) {
      val valdec : vx_core.Type_decimal = vx_core.f_any_from_any(vx_core.t_decimal, value)
      output = valdec.vx_string()
    } else if (value is vx_core.Type_float) {
      val valfloat : vx_core.Type_float = vx_core.f_any_from_any(vx_core.t_float, value)
      output = valfloat.vx_float().toString()
      if (output.endsWith(".0")) {
        output = output.substring(0, output.length - 2)
      }
    } else if (value is vx_core.Type_int) {
      if (value == vx_core.c_notanumber) {
        output = "notanumber"
      } else if (value == vx_core.c_infinity) {
        output = "infinity"
      } else if (value == vx_core.c_neginfinity) {
        output = "neginfinity"
      } else {
        val valint : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, value)
        output = Integer.toString(valint.vx_int())
      }
    } else if (value is vx_core.Type_string) {
      val valstring : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, value)
      var sval : String = valstring.vx_string()
      if (sval.indexOf("\"") < 0) {
        sval = "\"" + sval + "\""
      } else {
        sval = "`" + sval + "`"
      }
      if (valstring.vx_msgblock() != vx_core.e_msgblock) {
        var msgtext : String = vx_core.vx_string_from_any_indent(
          valstring.vx_msgblock(), indent, linefeed
        )
        output  = "\n" + indenttext + "(string"
        output += "\n" + indenttext + " " + sval
        output += "\n" + indenttext + " " + msgtext + ")"
      } else {
        output = sval
      }
    } else if (value.vx_constdef() != vx_core.e_constdef) {
      val constdef : vx_core.Type_constdef = value.vx_constdef()
      val constpkg : String = constdef.pkgname().vx_string()
      val constname : String = constdef.name().vx_string()
      if (constpkg.equals("vx/core")) {
        output = constname
      } else {
        output = constpkg + "/" + constname
      }
    } else if (value is vx_core.Type_list) {
      val vallist : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, value)
      val typedef : vx_core.Type_typedef = vallist.vx_typedef()
      val typedefname : vx_core.Type_string = typedef.name()
      var indentint : Int = indent
      indentint += 1
      val listval : List<vx_core.Type_any> = vallist.vx_list()
      for (valsub : vx_core.Type_any in listval) {
        val valtext : String = vx_core.vx_string_from_any_indent(valsub, indentint, linefeed)
        output += "\n " + indenttext + valtext
      }
      if (vallist.vx_msgblock() != vx_core.e_msgblock) {
        val msgtext : String = vx_core.vx_string_from_any_indent(vallist.vx_msgblock(), indentint, linefeed)
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext
      }
      output = "(" + typedefname.vx_string() + output + ")"
    } else if (value is vx_core.Type_map) {
      val valmap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, value)
      val typedef : vx_core.Type_typedef = valmap.vx_typedef()
      val typedefname : vx_core.Type_string = typedef.name()
      var indentint : Int = indent
      indentint += 2
      val mapval : Map<String, vx_core.Type_any> = valmap.vx_map()
      val keys : Set<String> = mapval.keys
      for (skey : String in keys) {
        var key : String = skey
        var valsub : vx_core.Type_any = mapval.getOrDefault(
          key, vx_core.e_any
        )
        if (!key.startsWith(":")) {
          key = ":" + key
        }
        var strval : String = vx_core.vx_string_from_any_indent(
          valsub, indentint, linefeed
        )
        if (strval.contains("\n")) {
          strval = "\n  " + indenttext + strval
        } else {
          strval = " " + strval
        }
        output += "\n" + indenttext + " " + key + strval
      }
      if (valmap.vx_msgblock() != vx_core.e_msgblock) {
        val msgtext : String = vx_core.vx_string_from_any_indent(
          valmap.vx_msgblock(), indentint, linefeed
        )
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext
      }
      output = "(" + typedefname.vx_string() + output + ")"
    } else if (value is vx_core.Type_struct) {
      val valstruct : vx_core.Type_struct = vx_core.f_any_from_any(
        vx_core.t_struct, value
      )
      val typedef : vx_core.Type_typedef = valstruct.vx_typedef()
      val typedefname : vx_core.Type_string = typedef.name()
      var indentint2 : Int = indent
      indentint2 += 2
      val mapval2 : Map<String, vx_core.Type_any> = valstruct.vx_map()
      val keys2 : Set<String> = mapval2.keys
      for (skey : String in keys2) {
        var key : String = skey
        val valsub2 : vx_core.Type_any = mapval2.getOrDefault(
          key, vx_core.e_any
        )
        if (!vx_core.f_is_empty_1(valsub2).vx_boolean()) {
          if (!key.startsWith(":")) {
            key = ":" + key
          }
          var strval2 : String = vx_core.vx_string_from_any_indent(
            valsub2, indentint2, linefeed
          )
          if (strval2.contains("\n")) {
            strval2 = "\n  " + indenttext + strval2
          } else {
            strval2 = " " + strval2
          }
          output += "\n" + indenttext + " " + key + strval2
        }
      }
      if (valstruct.vx_msgblock() != vx_core.e_msgblock) {
        val msgtext2 : String = vx_core.vx_string_from_any_indent(
          valstruct.vx_msgblock(), indentint2, linefeed
        )
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext2
      }
      output = "(" + typedefname.vx_string() + output + ")"
    } else if (value is vx_core.Type_func) {
      val valfunc : vx_core.Type_func = vx_core.f_any_from_any(
        vx_core.t_func, value
      )
      val funcdef : vx_core.Type_funcdef = valfunc.vx_funcdef()
      val funcdefname : vx_core.Type_string = vx_core.f_funcname_from_funcdef(
        funcdef
      )
      output = funcdefname.vx_string()
      if (valfunc.vx_msgblock() != vx_core.e_msgblock) {
        val msgtext : String = vx_core.vx_string_from_any_indent(
          valfunc.vx_msgblock(), indent, linefeed
        )
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext
      }
      output = "(" + output + ")"
    }
    return output
  }

  fun vx_string_from_any_indent(
    value : vx_core.Type_any,
    indent : vx_core.Type_int,
    linefeed : vx_core.Type_boolean) : vx_core.Type_string {
    val soutput : String = vx_core.vx_string_from_any_indent(
      value,
      indent.vx_int(),
      linefeed.vx_boolean())
    val output : vx_core.Type_string = vx_core.vx_new_string(soutput)
    return output
  }

  // vx_string_from_string_find_replace(string, string, string)
  fun vx_string_from_string_find_replace(
    text : String,
    find : String,
    replace : String) : String {
    val output : String = text.replace(find, replace)
    return output
  }

  // vx_string_from_string_find_replace(string, string, string)
  fun vx_string_from_string_find_replace(
    text : vx_core.Type_string,
    find : vx_core.Type_string,
    replace : vx_core.Type_string) : vx_core.Type_string {
    val stext : String = vx_core.vx_string_from_string_find_replace(
      text.vx_string(), find.vx_string(), replace.vx_string()
    )
    val output : vx_core.Type_string = vx_core.vx_new_string(stext)
    return output
  }

  fun vx_string_from_string_start_end(
    text : String,
    start : Int,
    endarg : Int) : String {
    var output : String = ""
    var maxlen : Int = text.length
    var end : Int = endarg
    if (end < 0) {
     end += maxlen
    }
    if (start < 1) {
    } else if (start > end) {
    } else if (start > maxlen) {
    } else {
      if (end >= maxlen) {
        end = maxlen
      }
      output = text.substring(start - 1, end)
    }
    return output
  }

  fun vx_string_repeat(
    text : String,
    repeat : Int) : String {
    val output : String = text.repeat(repeat)
    return output
  }

  fun vx_string_repeat(
    text : vx_core.Type_string,
    repeat : vx_core.Type_int) : vx_core.Type_string {
    val stext : String = vx_core.vx_string_repeat(text.vx_string(), repeat.vx_int())
    val output : vx_core.Type_string = vx_core.vx_new_string(stext)
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_switch(
    generic_any_1 : T,
    value : U,
    thenelselist : vx_core.Type_thenelselist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    var fn_any : vx_core.Func_any_from_func = vx_core.e_any_from_func
    val listthenelse : List<vx_core.Type_thenelse> = thenelselist.vx_listthenelse()
    for (thenelse : vx_core.Type_thenelse in listthenelse) {
      val code : vx_core.Type_string = thenelse.code()
      when (code.vx_string()) {
        ":case" -> {
          val casevalue : vx_core.Type_any = thenelse.value()
          val iseq : vx_core.Type_boolean = vx_core.f_eq(casevalue, value)
          if (iseq.vx_boolean()) {
            fn_any = thenelse.fn_any()
          }
        }
        ":casemany" -> {
          val values : vx_core.Type_list = thenelse.values()
          val iscontain : vx_core.Type_boolean = vx_core.f_contains_1(values, value)
          if (iscontain.vx_boolean()) {
            fn_any = thenelse.fn_any()
          }
        }
        ":else" -> {
          fn_any = thenelse.fn_any()
        }
      }
      if (fn_any != vx_core.e_any_from_func) {
        break
      }
    }
    if (fn_any != vx_core.e_any_from_func) {
      output = fn_any.vx_any_from_func(generic_any_1)
    }
    return output
  }

  fun typedef_new(
    pkgname : String,
    name : String,
    extend : String,
    traits : vx_core.Type_typelist,
    allowtypes : vx_core.Type_typelist,
    disallowtypes : vx_core.Type_typelist,
    allowfuncs : vx_core.Type_funclist,
    disallowfuncs : vx_core.Type_funclist,
    allowvalues : vx_core.Type_anylist,
    disallowvalues : vx_core.Type_anylist,
    properties : vx_core.Type_argmap) : vx_core.Type_typedef {
    val output : vx_core.Class_typedef = vx_core.Class_typedef()
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname)
    output.vx_p_name = vx_core.vx_new_string(name)
    output.vx_p_extend = vx_core.vx_new_string(extend)
    output.vx_p_traits = traits
    output.vx_p_allowtypes = allowtypes
    output.vx_p_disallowtypes = disallowtypes
    output.vx_p_allowfuncs = disallowfuncs
    output.vx_p_disallowfuncs = disallowfuncs
    output.vx_p_allowvalues = disallowvalues
    output.vx_p_disallowvalues = disallowvalues
    output.vx_p_properties = properties
    return output
  }

  fun vx_anylist_from_arraystring(
    vararg arraystring : String) : vx_core.Type_anylist {
    val listany : MutableList<Any> = ArrayList<Any>()
    for (svalue : String in arraystring) {
      val value : vx_core.Type_string = vx_core.vx_new_string(svalue)
      listany.add(value)
    }
    val arrayany : Array<Any> = listany.toTypedArray()
    val output : vx_core.Type_anylist = vx_core.vx_new(
      vx_core.t_anylist,
      *arrayany)
    return output
  }

  // Warning!: Blocking
  fun <T : vx_core.Type_any> vx_sync_from_async(
    generic_any_1 : T,
    future : CompletableFuture<T>) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    try {
      output = future.get()
    } catch (ex : Exception) {
      val msg : vx_core.Type_msg = vx_core.vx_msg_from_exception(
        "sync<-async", ex
      )
      val value : vx_core.Type_any = generic_any_1.vx_new(
        msg
      )
      output = vx_core.f_any_from_any(
        generic_any_1, value
      )
    }
    return output
  }
