(package vx/core
 :libs (lib javafunction)
       (lib javacollectors)
       (lib javafuture)
 :doc "Core vxlisp Library. Unfortunately large because of interdependencies.")

(type any
 :create
  (native
   :cpp
    "// :header
     vx_core::Type_any vx_type_from_any(vx_core::Type_any value) const;")
 :doc "Any Value for Variant Type")

(type any-async<-func : func
 :allowfuncs [any<-func any<-func-async]
 :doc        "A sync or async function that returns one value.")

(type any<-anylist : list
 :allowfuncs [any<-any]
 :doc        "List of any<-any")

(type anylist : list
 :allowtypes [any]
 :doc        "A list of any")

(type anymap : map
 :allowtypes [any]
 :doc        "A map of any")

(type anytype : type
 :doc     "Any Type that allows any Type as a Value")

(type arg : struct
 :properties [name    : string
              argtype : any
              fn-any  : any<-func
              doc     : string]
 :doc        "A function argument")

(type arglist : list
 :allowtypes [arg]
 :doc        "A list of arg")

(type argmap : map
 :allowtypes [arg]
 :doc        "A map of arg")

(type boolean
 :default     false
 :allowvalues [true false]
 :create
  (native
   :cpp
    "// :header
     bool vx_p_boolean = false;
     bool vx_boolean() const;"
   :csharp
    "internal bool vxboolean = false;

     // :implements
     public bool vx_boolean() {
       return vxboolean;
     }"
   :java
    "protected boolean vxboolean = false;

     @Override
     public boolean vx_boolean() {
       return vxboolean;
     }"
   :kotlin
    "internal var vxboolean : Boolean = false

     // :implements
     override fun vx_boolean() : Boolean {
       return vxboolean;
     }")
 :test (test-true true)
       (test-false false)
       (test-true (boolean true))
       (test-false (boolean false))
 :doc "Standard Boolean Type")

(type booleanlist : list
 :allowtypes [boolean])

(type collection
 :allowtypes [list map])

(type compilelanguages
 :default     :unknown
 :allowvalues [:unknown :cpp :csharp :java :js :kotlin :swift])

(type connect
 :doc "General connect trait")

(type connectlist : list
 :allowtypes [connect]
 :doc "List of connect")

(type connectmap : map
 :allowtypes [connect]
 :doc "Map of connect")

(type const : const
 :doc "Original Constant Class.")

(type constdef : struct
 :properties
  [pkgname : string
   name    : string
   type    : any]
 :doc "Const Definition Class for inspecting properties.")

(type constlist : list
 :allowtypes [any]
 :doc "List of Const.")

(type constmap : map
 :allowtypes [any]
 :doc "Map of Const.")

(type context : struct
 :properties [code    : string
              session : session
              setting : setting
              state   : state]
 :doc "Context")

(type date : string
 :doc "A simple UTC date.")

(type decimal
 :traits  [number]
 :default 0
 :create
  (native
   :cpp
    "// :header
     std::string vx_p_decimal = “0.0”;
     float vx_float() const;
     std::string vx_string() const;"
   :csharp
    "internal string vxdecimal = “0.0”;

     // :implements
     public float vx_float() {
       return float.Parse(vxdecimal);
     }

     // :implements
     public string vx_string() {
       return vxdecimal;
     }"
   :java
    "protected String vxdecimal = “0.0”;

     @Override
     public float vx_float() {
       return Float.parseFloat(vxdecimal);
     }

     @Override
     public String vx_string() {
       return vxdecimal;
     }"
   :kotlin
    "internal var vxdecimal : String = “0.0”

     // :implements
     override fun vx_float() : Float {
       return vxdecimal.toFloat()
     }

     // :implements
     override fun vx_string() : String {
       return vxdecimal
     }")
 :doc "A clean version of float like Java BigDecimal.")

(type error
 :doc "Error Type")

(type float
 :default 0.0
 :traits  [number]
 :create
  (native
   :cpp
    "// :header
     float vx_p_float = 0;
     float vx_float() const;"
   :csharp
    "internal float vxfloat = 0;

     // :implements
     public float vx_float() {
       return vxfloat;
     }"
   :java
    "protected float vxfloat = 0;

     @Override
     public float vx_float() {
       return vxfloat;
     }"
   :kotlin
    "internal var vxfloat : Float = 0f

     // :implements
     override fun vx_float() : Float {
       return vxfloat
     }")
 :test (test
        4.5
        (float 4.5))
 :doc  "Standard Floating Point Number")

(type func : func
 :create
  (native
   :cpp
    "// :header
     vx_core::Type_funcdef vx_funcdef() const;")
 :test (test
        5
        (let
         [funcvar : + := +]
         (funcvar 2 3)))
 :doc "Original Function Class.")

(type funcdef : struct
 :properties
  [pkgname : string
   name    : string
   idx     : int
   type    : any
   async   : boolean]
 :create
  (native
   :cpp
    "// :header
     static vx_core::Type_funcdef vx_funcdef_new(
       std::string pkgname,
       std::string name,
       long idx,
       bool async,
       vx_core::Type_any typ
     );")
 :doc "Func Definition Class for inspecting properties.")

(type funclist : list
 :allowtypes [func]
 :test (test
        2
        (length
         (funclist
          + -)))
 :doc "List of Func.")

(type funcmap : map
 :allowtypes [func]
 :doc "Map of Func.")

(type int
 :default     0
 :allowvalues [infinity neginfinity]
 :traits      [number]
 :create
  (native
   :cpp
    "// :header
     long vx_p_int = 0;
     long vx_int() const;"
   :csharp
    "internal int vxint = 0;

     // :implements
     public int vx_int() {
       return vxint;
     }"
   :java
    "protected int vxint = 0;

     @Override
     public int vx_int() {
       return vxint;
     }"
   :kotlin
    "internal var vxint : Int = 0

     // :implements
     override fun vx_int() : Int {
       return vxint
     }")
 :test (test-true  (is-int 4))
       (test-true  (is-int "4"))
       (test-true  (is-int infinity))
       (test-true  (is-int neginfinity))
       (test-true  (is-int notanumber))
       (test-false (is-int "a"))
       (test-false (is-int 5.5))
 :doc  "A simple integer.")

(type intlist : list
 :allowtypes [int]
 :doc "A list of int.")

(type intmap : map
 :allowtypes [int]
 :doc "A map of int.")

(type list : list
 :allowtypes [any]
 :create
  (native
   :cpp
    "// :header
     vx_core::vx_Type_listany vx_p_list;
     vx_core::vx_Type_listany vx_list() const;
     vx_core::Type_any vx_get_any(vx_core::Type_int index) const;
     vx_core::Type_any vx_new_from_list(vx_core::vx_Type_listany listval) const;")
 :doc "A simple untyped list.")

(type listtype : type
 :doc "A generic type that extends :list.")

(type locale : struct
 :doc "Localization data.")

(type map : map
 :allowtypes [any]
 :create
  (native
   :cpp
    "// :header
     std::vector<std::string> vx_p_keys;
     vx_core::vx_Type_mapany vx_p_map;
     vx_core::vx_Type_mapany vx_map() const;
     vx_core::Type_any vx_get_any(vx_core::Type_string key) const;
     vx_core::Type_boolean vx_set(vx_core::Type_string name, vx_core::Type_any value);
     vx_core::Type_any vx_new_from_map(vx_core::vx_Type_mapany mapval) const;")
 :doc "A simple untyped map.")

(type maptype : type
 :doc "A generic type that extends :map.")

(type mempool : struct
 :properties [valuepool : value]
 :create
  (native
   :java
    "private int vx_max = 20;

     private Map<String, Deque<Core.Type_any>> vx_maplistany = new ConcurrentHashMap<>();

     @Override
     public <T extends Core.Type_any> T vx_restore(final T generic_any_1) {
       T output = null;
       String typename = Core.f_typename_from_any(generic_any_1).vx_string();
       Deque<Core.Type_any> listany = this.vx_maplistany.get(typename);
       if (listany == null) {
       } else if (!listany.isEmpty()) {
         Core.Type_any any = listany.remove();
         if (any != null) {
           output = Core.f_any_from_any(generic_any_1, any);
         }
       }
       return output;
     }

     @Override
     public void vx_recycle(final Core.Type_any addany) {
       String typename = Core.f_typename_from_any(addany).vx_string();
       Deque<Core.Type_any> listany = this.vx_maplistany.get(typename);
       boolean isdestroy = true;
       int imax = this.vx_max;
       if (imax == 0) {
       } else if (listany == null) {
        isdestroy = false;
        listany = new ConcurrentLinkedDeque<Core.Type_any>();
        listany.add(addany);
        this.vx_maplistany.put(typename, listany);
       } else {
        int ilen = listany.size();
        if (ilen < imax) {
          listany.add(addany);
        }
       }
       if (isdestroy) {
         // destroy
       }
     }

     @Override
     public void vx_recyclelist(final List<Core.Type_any> addlistany) {
       for (Core.Type_any addany : addlistany) {
         this.vx_recycle(addany);
       }
     }")
 :doc "Memory Pool")

(type msg : struct
 :properties
  [code     : string  :doc "Message Code"
   detail   : any     :doc "Message Detail"
   path     : string  :doc "Message Path"
   severity : int     :doc "Message Severity"
   text     : string  :doc "Message Text"]
 :create
  (native
   :cpp
    "// :header
     std::exception err;"
   :csharp
    "public Exception? err = null;"
   :java
    "public Exception err = null;"
   :kotlin
    "var err : Exception? = null")
 :doc "Message Type for error handling")

(type msgblock : struct
 :properties
  [msgs      : msglist
   msgblocks : msgblocklist]
 :test (test
        (decimal
         (msgblock
          :msgs
           (msglist
            (msg
             :text "Err"))))
        (decimal
         (msg
          :text "Err")))
       (test
        (decimal
         (msgblock
          :msgs
           (msglist
            (msg :text "Err"))))
        (let : decimal
         [mymsgblock : msgblock :=
          (msgblock
           (msg
            :text "Err"))]
         (decimal
          (copy
           mymsgblock
           mymsgblock))))
 :doc "Block of Messages. Note: Identical msgblocks are suppressed.")

(type msgblocklist : list
 :allowtypes [msgblock]
 :test (test
        (msgblocklist
         (msgblock
          (msg :text "Err")))
        (let : msgblocklist
         [mymsgblock : msgblock :=
          (msgblock
           (msg :text "Err"))]
         (msgblocklist
          mymsgblock
          mymsgblock)))
 :doc "List of Message Blocks. Note: Identical msgblocks are suppressed.")

(type msglist : list
 :allowtypes [msg]
 :test (test
        (msglist
         (msg :text "Err"))
        (let : msglist
         [mymsg : msg :=
          (msg :text "Err")]
         (msglist
          mymsg
          mymsg)))
 :doc "List of Messages. Note: Identical msgs are suppressed.")

(type none
 :doc "No Type. No type is returned at all. e.g. Void")

(type notype
 :doc "No Type that allows no Types as a Value")

(type number
 :default    0
 :allowtypes [int float decimal]
 :doc "A generic number that could be int, float, or decimal.")

(type numberlist : list
 :allowtypes [number]
 :doc "A list of number.")

(type numbermap : map
 :allowtypes [number]
 :doc "A map of number.")

(type package : struct
 :properties
  [pkgname  : string
   constmap : constmap
   funcmap  : funcmap
   typemap  : typemap
   emptymap : map]
 :doc "A package that store types, consts and funcs.")

(type packagemap : map
 :allowtypes [package])

(type permission : struct
 :properties [id : string]
 :doc "Permission")

(type permissionlist : list
 :allowtypes [permission]
 :doc "List of Permission")

(type permissionmap : map
 :allowtypes [permission]
 :doc "Map of Permission")

(type project : struct
 :properties [packagemap : packagemap]
 :doc "A project.")

(type security : struct
 :properties
  [allowfuncs    : funclist
   permissions   : permissionlist
   permissionmap : permissionmap]
 :doc        "Security rules")

(type session : struct
 :properties
  [user           : user
   connectlist    : connectlist
   connectmap     : connectmap
   locale         : locale
   translation    : translation
   translationmap : translationmap]
 :doc "Session")

(type setting : struct
 :properties
  [pathmap : stringmap]
 :doc "Settings")

(type state : struct
 :properties
  [statelistenermap : statelistenermap]
 :doc "State. Note that this type is has mutable values.")

(type statelistener : struct
 :properties
  [name       : string
   value      : any
   fn-boolean : boolean<-none]
 :doc "A listener to trigger functions on state change.")

(type statelistenermap : map
 :allowtypes [statelistener]
 :mutable
 :doc "Mutable map of statelisteners")

(type string : string
 :default ""
 :create
  (native
   :cpp
    "// :header
     std::string vx_p_string = “”;
     std::string vx_string() const;"
   :csharp
    "internal string vxstring = “”;

     // :implements
     public string vx_string() {
       return vxstring;
     }"
   :java
    "protected String vxstring = “”;

     @Override
     public String vx_string() {
       return vxstring;
     }"
   :kotlin
    "internal var vxstring : String = “”

     // :implements
     override fun vx_string() : String {
       return vxstring
     }")
 :test (test "a" (string "a"))
       (test "ab" (string "a" "b"))
 :doc  "A simple string.")

(type stringlist : list
 :allowtypes [string]
 :test (test
        (new : stringlist "a" "b" "c")
        (stringlist
         (anylist
          "a"
          (stringlist "b" "c"))))
 :doc "A list of string.")

(type stringlistlist : list
 :allowtypes [stringlist]
 :doc "A list of stringlist.")

(type stringmap : map
 :allowtypes [string]
 :doc "A map of string.")

(type stringmutablemap : map
 :allowtypes [string]
 :mutable
 :doc "A mutable map of string. Note: Mutables are dangerous.")

(type struct : struct
 :create
  (native
   :cpp
    "// :header
     vx_core::vx_Type_mapany vx_map() const;
     vx_core::Type_any vx_get_any(vx_core::Type_string key) const;")
 :doc "Struct is the type of all structures/objects with properties.")

(type thenelse : struct
 :properties
  [code    : string
   value   : any
   values  : list
   fn-cond : boolean<-func
   fn-any  : any<-func]
 :doc "An object used in if and switch functions.")

(type thenelselist : list
 :allowtypes [thenelse]
 :doc "A list of thenelse.")

(type translation : struct
 :properties
  [name    : string
   wordmap : stringmap]
 :doc "i18 language translation.")

(type translationlist : list
 :allowtypes [translation]
 :doc "i18 language translation list.")

(type translationmap : map
 :allowtypes [translation]
 :doc "i18 language translation map.")

(type type : type
 :doc     "Original Type Class")

(type typedef : struct
 :properties
  [pkgname        : string
   name           : string
   extends        : string
   allowfuncs     : funclist
   allowtypes     : typelist
   allowvalues    : anylist
   disallowfuncs  : funclist
   disallowtypes  : typelist
   disallowvalues : anylist
   properties     : argmap
   proplast       : arg
   traits         : typelist]
 :create
  (native
   :cpp
    "// :header
     static vx_core::Type_typedef vx_typedef_new(
       std::string pkgname,
       std::string name,
       std::string extend,
       vx_core::Type_typelist traits,
       vx_core::Type_typelist allowtypes,
       vx_core::Type_typelist disallowtypes,
       vx_core::Type_funclist allowfuncs,
       vx_core::Type_funclist disallowfuncs,
       vx_core::Type_anylist allowvalues,
       vx_core::Type_anylist disallowvalues,
       vx_core::Type_argmap properties
     );")
 :doc "Type Definition Class for inspecting Type properties.")

(type typelist : list
 :allowtypes [any]
 :doc "List of Types")

(type typemap : map
 :allowtypes [any]
 :doc "Map of Any Type Class")

(type user : struct
 :properties
  [security : security
   username : string
   token    : string]
 :doc "User Type")

(type value : struct
 :properties
  [next : any
   refs : int])

(const false : boolean
 :test (test-false false))

(const global : project
 :doc "Global variable for project data.")

(const infinity : int
 (native
  :js "Infinity")
 :doc "Infinity. Returned during unusual calculations.")

(const mempool-active : mempool
 :doc "Active Value Memory Pool")

(const msg-info : int
 0
 :doc "Message is just information")

(const msg-warning : int
 1
 :doc "Message is a Warning")

(const msg-error : int
 2
 :doc "Message is an Error")

(const msg-severe : int
 3
 :doc "Message is a Severe Error")

(const neginfinity : int
 (native
  :js "-Infinity")
 :doc "Negative Infinity. Returned during unusual calculations.")

(const newline : string
 "\n"
 :doc "New line constant")

(const notanumber : int
 (native
  :js "NaN")
 :doc "Not a number. Returned during invalid calculations.")

(const nothing : string
 "nothing"
 :doc "Nothing Value. Opposite of every other value. e.g. Nil, Null")

(const path-test-resources : string
 :doc "The test path from project file")

(const quote : string
 `"`
 :doc "Quotation mark constant")

(const true : boolean
 (native
  :cpp    "true"
  :csharp "true"
  :java   "true"
  :js     "true")
 :test (test-true true))

(func . : any
 [target     : any
  method     : string
  parameters : anylist :...]
 (native
  :js "target[method].apply(parameters)")
 :alias "dotmethod"
 :sideeffects "Depends on object"
 :doc "Not Recommened: Support for Object Oriented dot notation. e.g. (this.foo 'a') = this.foo('a')")

(func + : int
 [num1 : int
  num2 : int]
 (native
  :cpp
   "long result = num1->vx_int() + num2->vx_int();
    output = vx_core::vx_new_int(result);"
  :csharp
   "int result = num1.vx_int() + num2.vx_int();
    output = Vx.Core.vx_new_int(result);"
  :java
   "int result = num1.vx_int() + num2.vx_int();
    output = Core.vx_new_int(result);"
  :js
   "num1 + num2"
  :kotlin
   "val result : Int = num1.vx_int() + num2.vx_int()
    output = vx_core.vx_new_int(result)")
 :alias "plus"
 :test (test 5 (+ 2 3))
       (test 3 (+ 5 -2))
 :doc "Math int plus")

(func + : number
 [num1 : number
  num2 : number]
 (native
  :cpp
   "float result = vx_core::vx_float_from_number(num1) + vx_core::vx_float_from_number(num2);
    output = vx_core::vx_new_float(result);"
  :csharp
   "float result = Vx.Core.vx_float_from_number(num1) + Vx.Core.vx_float_from_number(num2);
    output = Vx.Core.vx_new_float(result);"
  :java
   "float result = Core.vx_float_from_number(num1) + Core.vx_float_from_number(num2);
    output = Core.vx_new_float(result);"
  :js
   "num1 + num2"
  :kotlin
   "val result : Float = vx_core.vx_float_from_number(num1) + vx_core.vx_float_from_number(num2)
    output = vx_core.vx_new_float(result)")
 :alias "plus"
 :test (test 5 (+ 2  3))
       (test 3 (+ 5 -2))
 :doc "Math number plus")

(func + : int
 [nums : intlist :...]
 (any<-list-start-reduce
  nums
  0
  (fn : int
   [total : int
    num   : int]
   (+ total num)))
 :alias "plus"
 :doc   "Math int plus")

(func + : number
 [nums : numberlist :...]
 (any<-list-start-reduce
  nums
  0
  (fn : number
   [total : number
    num   : number]
   (+ total num)))
 :alias "plus"
 :doc   "Math number plus")

(func +1 : int
 [num : int]
 (+ num 1)
 :alias "plus1"
 :test (test  3 (+1  2))
       (test -1 (+1 -2))
 :doc "Math int plus 1")

(func - : int
 [num1 : int
  num2 : int]
 (native
  :cpp
   "long result = num1->vx_int() - num2->vx_int();
    output = vx_core::vx_new_int(result);"
  :csharp
   "int result = num1.vx_int() - num2.vx_int();
    output = Vx.Core.vx_new_int(result);"
  :java
   "int result = num1.vx_int() - num2.vx_int();
    output = Core.vx_new_int(result);"
  :js
   "num1 - num2"
  :kotlin
   "val result : Int = num1.vx_int() - num2.vx_int()
    output = vx_core.vx_new_int(result)")
 :alias "minus"
 :test (test 1 (- 3 2))
       (test 7 (- 5 -2))
 :doc "Math int minus")

(func - : number
 [num1 : number
  num2 : number]
 (native
  :cpp
   "float result = vx_core::vx_float_from_number(num1) - vx_core::vx_float_from_number(num2);
    output = vx_core::vx_new_float(result);"
  :csharp
   "float result = Vx.Core.vx_float_from_number(num1) - Vx.Core.vx_float_from_number(num2);
    output = Vx.Core.vx_new_float(result);"
  :java
   "float result = Core.vx_float_from_number(num1) - Core.vx_float_from_number(num2);
    output = Core.vx_new_float(result);"
  :js
   "num1 - num2"
  :kotlin
   "val result : Float = vx_core.vx_float_from_number(num1) - vx_core.vx_float_from_number(num2)
    output = vx_core.vx_new_float(result)")
 :alias "minus"
 :test (test 5 (+ 2 3))
       (test 3 (+ 5 -2))
 :doc "Math number minus")

(func - : int
 [nums : intlist :...]
 (any<-list-start-reduce
  nums
  0
  (fn : int
   [total : int
    num   : int]
   (- total num)))
 :alias "minus"
 :doc   "Math integer minus")

(func - : number
 [nums : numberlist :...]
 (any<-list-start-reduce
  nums
  0
  (fn : number
   [total : number
    num   : number]
   (- total num)))
 :alias "minus"
 :doc   "Math number minus")

(func -1 : int
 [num : int]
 (- num 1)
 :alias "minus1"
 :test (test  1 (-1  2))
       (test -3 (-1 -2))
 :doc "Math int minus 1")

(func * : int
 [num1 : int
  num2 : int]
 (native
  :cpp
   "long result = num1->vx_int() * num2->vx_int();
    output = vx_core::vx_new_int(result);"
  :csharp
   "int result = num1.vx_int() * num2.vx_int();
    output = Vx.Core.vx_new_int(result);"
  :java
   "int result = num1.vx_int() * num2.vx_int();
    output = Core.vx_new_int(result);"
  :js
   "num1 * num2"
  :kotlin
   "val result : Int = num1.vx_int() * num2.vx_int()
    output = vx_core.vx_new_int(result)")
 :alias "multiply"
 :test (test 6 (* 3 2))
       (test -10 (* 5 -2))
 :doc "Math int multiply")

(func * : number
 [num1 : number
  num2 : number]
 (native
  :cpp
   "float result = vx_core::vx_float_from_number(num1) * vx_core::vx_float_from_number(num2);
    output = vx_core::vx_new_float(result);"
  :csharp
   "float result = Vx.Core.vx_float_from_number(num1) * Vx.Core.vx_float_from_number(num2);
    output = Vx.Core.vx_new_float(result);"
  :java
   "float result = Core.vx_float_from_number(num1) * Core.vx_float_from_number(num2);
    output = Core.vx_new_float(result);"
  :js
   "num1 * num2"
  :kotlin
   "val result : Float = vx_core.vx_float_from_number(num1) * vx_core.vx_float_from_number(num2)
    output = vx_core.vx_new_float(result)")
 :alias "multiply"
 :test (test 6.4 (* 3.2 2))
       (test -10.2 (* 5.1 -2))
 :doc "Math multipy")

(func * : int
 [nums : intlist :...]
 (any<-list-start-reduce
  nums
  1
  (fn : int
   [total : int
    num   : int]
   (* total num)))
 :alias "multiply"
 :test (test 24 (* 3 2 4))
       (test -20 (* 5 -2 2))
 :doc "Math multiply")

(func * : number
 [nums : numberlist :...]
 (any<-list-start-reduce
  nums
  1
  (fn : number
   [total : number
    num   : number]
   (* total num)))
 :alias "multiply"
 :test (test 24 (* 3 2 4))
       (test -20 (* 5 -2 2))
 :doc "Math multiply")

(func / : number
 [num1 : number
  num2 : number]
 (native
  :cpp
   "float float1 = vx_core::vx_float_from_number(num1);
    float float2 = vx_core::vx_float_from_number(num2);
    if (float1 == 0) {
    } else if (float2 == 0) {
      output = vx_core::c_notanumber;
    } else {
      float result = float1 / float2;
      output = vx_core::vx_new_float(result);
    }"
  :csharp
   "float float1 = Vx.Core.vx_float_from_number(num1);
    float float2 = Vx.Core.vx_float_from_number(num2);
    if (float1 == 0) {
    } else if (float2 == 0) {
      output = Vx.Core.c_notanumber;
    } else {
      float result = float1 / float2;
      output = Vx.Core.vx_new_float(result);
    }"
  :java
   "float float1 = Core.vx_float_from_number(num1);
    float float2 = Core.vx_float_from_number(num2);
    if (float1 == 0) {
    } else if (float2 == 0) {
      output = Core.c_notanumber;
    } else {
      float result = float1 / float2;
      output = Core.vx_new_float(result);
    }"
  :js
   "num1 / num2"
  :kotlin
   "val float1 : Float = vx_core.vx_float_from_number(num1)
    val float2 : Float = vx_core.vx_float_from_number(num2)
    if (float1 == 0f) {
    } else if (float2 == 0f) {
      output = vx_core.c_notanumber
    } else {
      val result : Float = float1 / float2
      output = vx_core.vx_new_float(result)
    }")
 :alias "divide"
 :test (test 3 (/ 6 2))
       (test -5 (/ 10 -2))
 :doc "Math divide")

(func = : boolean
 [val1 : any
  val2 : any]
 (native
  :cpp
   "bool isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      std::string str1 = vx_core::vx_string_from_any(val1);
      std::string str2 = vx_core::vx_string_from_any(val2);
      if (str1 == str2) {
        isequal = true;
      }
    }
    output = vx_core::vx_new_boolean(isequal);"
  :csharp
   "bool isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      Vx.Core.Type_string strval1 = Vx.Core.f_string_from_any(val1);
      Vx.Core.Type_string strval2 = Vx.Core.f_string_from_any(val2);
      if (strval1.vx_string() == (strval2.vx_string())) {
        isequal = true;
      }
    }
    output = Vx.Core.vx_new_boolean(isequal);"
  :java
   "boolean isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      Core.Type_string strval1 = Core.f_string_from_any(val1);
      Core.Type_string strval2 = Core.f_string_from_any(val2);
      if (strval1.vx_string().equals(strval2.vx_string())) {
        isequal = true;
      }
    }
    output = Core.vx_new_boolean(isequal);"
  :js
   "vx_core.vx_eq(val1, val2)"
  :kotlin
   "var isequal : Boolean = false
    if (val1 == val2) {
      isequal = true
    } else {
      val strval1 : vx_core.Type_string = vx_core.f_string_from_any(val1)
      val strval2 : vx_core.Type_string = vx_core.f_string_from_any(val2)
      if (strval1.vx_string().equals(strval2.vx_string())) {
        isequal = true
      }
    }
    output = vx_core.vx_new_boolean(isequal)")
 :alias "eq"
 :test (test-true (= true true))
       (test-true (= 2 2))
       (test-true (= "a" "a"))
       (test-true
        (=
         (stringlist "a" "b" "c")
         (new : stringlist "a" "b" "c")))
       (test-true
        (=
         (stringmap :a "1" :b "2")
         (new : stringmap :a "1" :b "2")))
 :doc "Boolean equal/equivalent")

(func = : boolean
 [values : anylist :...]
 (any<-list-start-reduce-next : boolean
  values
  false
  (fn : boolean
   [reduce  : boolean
    current : any
    next    : any]
   (and reduce (= current next))))
 :alias "eq"
 :test (test-false (= 2 2 3))
 :doc "Boolean equal/equivalent")

(func == : boolean
 [val1 : any
  val2 : any]
 (native
  :cpp
   "bool isequal = vx_core::vx_eqeq(val1, val2);
    output = vx_core::vx_new_boolean(isequal);"
  :csharp
   "bool isequal = Vx.Core.vx_eqeq(val1, val2);
    output = Vx.Core.vx_new_boolean(isequal);"
  :java
   "boolean isequal = Core.vx_eqeq(val1, val2);
    output = Core.vx_new_boolean(isequal);"
  :js
   "output = val1 == val2"
  :kotlin
   "val isequal : Boolean = vx_core.vx_eqeq(val1, val2)
    output = vx_core.vx_new_boolean(isequal)")
 :alias "eqeq"
 :test (test-true (== 0 0))
       (test-true (== "" ""))
 :doc "Strict equality check. Note that all non-empty, non-constants will not be equal.")

(func ! : boolean
 [value : boolean :doc "Thing to not"]
 (native
  :cpp    "vx_core::vx_new_boolean(!value->vx_boolean());"
  :csharp "Vx.Core.vx_new_boolean(!value.vx_boolean());"
  :java   "Core.vx_new_boolean(!value.vx_boolean());"
  :js     "!value"
  :kotlin "vx_core.vx_new_boolean(!value.vx_boolean())")
 :alias "not"
 :test (test-false false)
       (test-false (! true))
 :doc "Boolean not")

(func != : boolean
 [val1 : any
  val2 : any]
 (! (= val1 val2))
 :alias "ne"
 :test (test-ne true false)
       (test-ne "a" "b")
 :doc "Returns true if the first arg is not equal to any of the other arg.")

(func !== : boolean
 [val1 : any
  val2 : any]
 (! (== val1 val2))
 :alias "neqeq"
 :doc   "Returns true if the first arg is not strictly equal to any of the other arg.")

(func !-empty : boolean
 [text : string]
 (! (is-empty text))
 :alias "notempty"
 :doc   "Returns true if text is not empty.")

(func !-empty : boolean
 [value : any]
 (! (is-empty value))
 :alias "notempty"
 :doc "Returns true if value is not empty.")

(func < : boolean
 [val1 : any
  val2 : any]
 (switch
  (compare val1 val2)
  (case -1 true)
  (else    false))
 :alias "lt"
 :test (test-true (< 2 3))
 :doc "Returns true if the first arg is less than all of the other args")

(func < : boolean
 [values : anylist :...]
 (any<-list-start-reduce-next : boolean
  values
  true
  (fn : boolean
   [reduce  : boolean
    current : any
    next    : any]
   (and reduce (< current next))))
 :alias "lt"
 :test (test-true
        (< 2 3))
       (test-true
        (< "b" "d" "z"))
 :doc "Returns true if the first arg is less than all of the other args")

(func <= : boolean
 [val1 : any
  val2 : any]
 (! (> val1 val2))
 :alias "le"
 :test  (test-true (<= 2 3))
 :doc   "Returns true if the first arg is less or equal than all of the other args")

(func <= : boolean
 [args : anylist :...]
 (! (> args))
 :alias "le"
 :test  (test-true (<= "b" "d" "z"))
 :doc   "Returns true if the first arg is less or equal than all of the other args")

(func <- : any-1
 [value  : any-1
  fnlist : any<-anylist :...]
 :alias chainfirst
 :test  (test
         (*
          (+
           (- 5 3)
           3)
          2)
         (<-
          5
          (- 3)
          (+ 3)
          (* 2)))
 :doc "This is a special function that applies a value as the first argument for the first function.
       The result is then used as the first argument on the next function, etc. Sometimes this
       improves readability.")

(func <<- : any-1
 [value  : any-1
  fnlist : any<-anylist :...]
 :alias chainlast
 :test  (test
         (* (+ (- 3 5) 3) 2)
         (<<-
          5
          (- 3)
          (+ 3)
          (* 2)))
 :doc "This is a special function that applies a value as the last argument for the first function.
       The result is then used as the last argument on the next function, etc. Sometimes this
       improves readability.")

(func > : boolean
 [val1 : any
  val2 : any]
 (switch
  (compare val1 val2)
  (case 1 true)
  (else   false))
 :alias "gt"
 :test  (test-true (> 3 2))
 :doc   "Returns true if the first arg is greater than all of the other args")

(func > : boolean
 [values : anylist :...]
 (any<-list-start-reduce-next : boolean
  values
  true
  (fn : boolean
   [reduce  : boolean
    current : any
    next    : any]
   (and
    reduce
    (> current next))))
 :alias "gt"
 :test  (test-true (> "z" "y" "b"))
 :doc   "Returns true if the first arg is greater than all of the other args")

(func >= : boolean
 [val1 : any
  val2 : any]
 (! (< val1 val2))
 :alias "ge"
 :test  (test-true (>= 3 2))
 :doc   "Returns true if val1 is greater or equal to val2")

(func >= : boolean
 [args : anylist :...]
 (! (< args))
 :alias "ge"
 :test  (test-true (>= "z" "b" "b"))
 :doc   "Returns true if the first arg is greater or equal than all of the other args")

(func allowfuncs<-security : funclist
 [security : security]
 (:allowfuncs security)
 :doc "Returns allowfuncs from a given security.")

(func allowtypenames<-typedef : stringlist
 [vtypedef : typedef]
 (typenames<-typelist (allowtypes<-typedef vtypedef))
 :doc "Return allow name list from type")

(func allowtypes<-typedef : typelist
 [vtypedef : typedef]
 (native
  :cpp
   "vtypedef->allowtypes();"
  :csharp
   "vtypedef.allowtypes();"
  :java
   "vtypedef.allowtypes();"
  :js
   "vtypedef['vx_value']['allowtypes']"
  :kotlin
   "vtypedef.allowtypes()")
 :doc "Return allow type list from type")

(func and : boolean
 [val1 : boolean
  val2 : boolean]
 (native
  :cpp
   "if (val1->vx_boolean() && val2->vx_boolean()) {
      output = vx_core::c_true;
    } else {
      output = vx_core::c_false;
    }"
  :csharp
   "if (val1.vx_boolean() && val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }"
  :java
   "if (val1.vx_boolean() && val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }"
  :js
   "if (val1 && val2) {
      output = true
    } else {
      output = false
    }"
  :kotlin
   "if (val1.vx_boolean() && val2.vx_boolean()) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }")
 :test (test-true
        (and true true))
       (test-false
        (and true false))
 :doc "Returns true if all values are true")

(func and : boolean
 [values : booleanlist :...]
 (switch : boolean
  (length values)
  (case 0 true)
  (case 1 (:1 values))
  (else
   (any<-list-start-reduce-next : boolean
    values
    true
    (fn : boolean
     [reduce  : boolean
      current : boolean
      next    : boolean]
     (and reduce (and current next)))
   )))
 :test (test-true
        (and true true true))
       (test-false
        (and true true false))
 :doc "Returns true if all values are true")

(func any<-any : any-1
 [value : any-2]
 (native
  :cpp
   "output = vx_core::vx_any_from_any(generic_any_1, value);"
  :csharp
   "if (value is T tval) {
      output = tval;
    }"
  :java
   "@SuppressWarnings(“unchecked”)
    output = (T)value;"
  :js
   "value"
  :kotlin
   "@Suppress(“UNCHECKED_CAST”)
    output = value as T")
 :doc "Function Type taking any value any-2 and returning generic any-1")

(func any<-any-async : any-1
 [value : any-2]
 :async
 :doc "Function Type taking any value any-2 and returning generic any-1")

(func any<-any-context : any-1
 [value : any-2]
 (native
  :csharp
   "if (value is T tval) {
      output = tval;
    }"
  :java
   "@SuppressWarnings(“unchecked”)
    output = (T)value;"
  :kotlin
   "@Suppress(“UNCHECKED_CAST”)
    output = (value as T)")
 :context
 :doc "Function Type taking any value any-2 and returning generic any-1 using context")

(func any<-any-context-async : any-1
 [value : any-2]
 :async
 :context
 :doc "Generic Function taking any value any-2 and returning generic any-1")

(func any<-any-key-value : any-1
 [current : any-1
  key     : string
  value   : any-2]
 :doc "Generic Function returning Generic any-1 from a any-1, a key, and a value.")

(func any<-int : any-1
 [value : int]
 :doc "Generic Function returning Generic any-1 from an int")

(func any<-func : any-1
 []
 :doc "Generic Function returning Generic any-1 with any parameters")

(func any<-func-async : any-1
 []
 :async
 :doc "Generic Function returning Generic any-1 with any parameters")

(func any<-int-any : any-1
 [num   : int
  value : any-2]
 :doc "Generic Function returning Generic any-1 from an int and a value")

(func any<-key-value : any-1
 [key   : string
  value : any-2]
 :doc "Generic Function returning Generic any-1 from a key and a value")

(func any<-key-value-async : any-1
 [key   : string
  value : any-2]
 :async
 :doc "Generic Function returning Asynchronous Generic any-1 from a key and a value")

(func any<-list : any-1
 [values : list-1
  index  : int]
 (native
  :cpp
   "long intindex = index->vx_int();
    vx_core::vx_Type_listany listvalue = values->vx_list();
    long intsize = vx_core::vx_int_from_sizet(listvalue.size());
    if (intindex <= intsize) {
      vx_core::Type_any value = listvalue[intindex - 1];
      output = vx_core::vx_any_from_any(generic_any_1, value);
    }"
  :csharp
   "int intindex = index.vx_int();
    int intsize = values.vx_list().Count;
    if (intindex <= intsize) {
      List<Vx.Core.Type_any> listvalue = values.vx_list();
      Vx.Core.Type_any value = listvalue[intindex - 1];
      output = Vx.Core.f_any_from_any(generic_any_1, value);
    }"
  :java
   "int intindex = index.vx_int();
    int intsize = values.vx_list().size();
    if (intindex <= intsize) {
      List<Core.Type_any> listvalue = values.vx_list();
      Core.Type_any value = listvalue.get(intindex - 1);
      output = Core.f_any_from_any(generic_any_1, value);
    }"
  :js
   "if (index <= values.length) {
      output = values[index - 1]
    }"
  :kotlin
   "val intindex : Int = index.vx_int()
    val intsize : Int = values.vx_list().size
    if (intindex <= intsize) {
      val listvalue : List<vx_core.Type_any> = values.vx_list()
      val value : vx_core.Type_any = listvalue.get(intindex - 1)
      output = vx_core.f_any_from_any(generic_any_1, value)
    }")
 :test (test
        "b"
        (any<-list
         (list "a" "b" "c")
         2))
       (test
        "b"
        (:2 (stringlist "a" "b" "c")))
 :doc "Returns nth value from a list or none if out of bounds")

(func any<-list-start-reduce : any-1
 [list      : list-2
  valstart  : any-1
  fn-reduce : any<-reduce]
 (native
  :cpp
   "vx_core::Type_any work = valstart;
    std::vector<vx_core::Type_any> listval = list->vx_list();
    for (vx_core::Type_any item : listval) {
      work = fn_reduce->vx_any_from_reduce(work, item);
    };
    output = vx_core::vx_any_from_any(generic_any_1, work);"
  :csharp :auto
  :java   :auto
  :js
   "output = valstart
    const fn = fn_reduce['vx_value']
    if (fn) {
      for (const item of list) {
        output = fn(output, item)
      }
    }"
  :kotlin :auto)
 :test (test
        24
        (any<-list-start-reduce : int
         (intlist 3 2 4)
         1
         (fn : int
          [total : int
           num   : int]
          (* total num))))
 :doc "Returns a val from a list reduce operation")

(func any<-list-start-reduce-next : any-1
 [list           : list-2
  valstart       : any-1
  fn-reduce-next : any<-reduce-next]
 (native
  :cpp
   "vx_core::Type_any result = vx_core::vx_any_from_list_result_next(generic_any_1, list, valstart, fn_reduce_next);
    output = vx_core::vx_any_from_any(generic_any_1, result);"
  :csharp :auto
  :java
   "output = valstart;
    final List<Core.Type_any> listval = list.vx_list();
    Core.Type_any current = Core.e_any;
    boolean first = true;
    for (final Core.Type_any next : listval) {
      if (first) {
        first = false;
      } else {
        output = fn_reduce_next.vx_any_from_reduce_next(generic_any_1, output, current, next);
      }
      current = next;
    }"
  :js
   "output = valstart
    const fn = fn_reduce_next['vx_value']
    if (fn) {
      let current = vx_core.e_any
      let first = true
      for (const next of list) {
        if (first) {
          first = false
        } else {
          output = fn(output, current, next)
        }
        current = next
      }
    }"
  :kotlin :auto)
 :doc "Returns a val from a list reduce operation")

(func any<-map : any-1
 [valuemap : map-1
  key      : string]
 (native
  :cpp
   "vx_core::Type_any val = valuemap->vx_get_any(key);
    output = vx_core::vx_any_from_any(generic_any_1, val);"
  :csharp
   "Vx.Core.vx_any_from_map(generic_any_1, valuemap, key);"
  :java
   "Core.vx_any_from_map(generic_any_1, valuemap, key);"
  :js
   "if (key.startsWith(':')) {
      key = key.substring(1)
    }
    const mapval = valuemap['vx_value']
    let val = mapval[key]
    if (val != undefined) {
      output = val
    }"
  :kotlin
   "vx_core.vx_any_from_map(generic_any_1, valuemap, key)")
 :test (test
        "v2"
        (any<-map
         (stringmap
          :a "v1"
          :b "v2"
          :c "v3")
         :b))
 :doc "Returns value from a map or empty if not found")

/*
(func any<-map-else : any-1
 [valuemap  : map-1
  key       : string
  valueelse : any-1]
 (let : any-1
  [value : any-1 := (any<-map
                     valuemap
                     key)]
  (if : any-1
   (then
    (!-empty value)
    value)
   (else
    valueelse)))
 :test (test
        "v2"
        (any<-map-else : string
         (stringmap
          :a "v1"
          :c "v3")
         :b
         "v2"))
 :doc "Returns value from a map or valueelse if not found")
*/

(func any<-map-start-reduce : any-1
 [map       : map-1
  start     : any-1
  fn-reduce : any<-any-key-value :: any-1 :: any-1]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto
  :kotlin :auto)
 :test (test
        "xayb"
        (any<-map-start-reduce
         (stringmap
          :a "x"
          :b "y")
         ""
         (fn : string
          [current : string
           key     : string
           value   : any]
          (copy current
           value
           key))))
 :doc "Returns a value by reducing each element of a map.")

(func any<-none : any-1
 []
 :doc "Function Type returning Generic any-1 with no parameters")

(func any<-none-async : any-1 :async
 []
 :doc "Function Type returning Generic any-1 with no parameters")

(func any<-reduce : any-1
 [result : any-1
  item   : any-2])

(func any<-reduce-async : any-1 :async
 [result : any-1
  item   : any-2])

(func any<-reduce-next : any-1
 [result  : any-1
  current : any-2
  next    : any-2])

(func any<-reduce-next-async : any-1 :async
 [result  : any-1
  current : any-2
  next    : any-2])

(func any<-struct : any-1
 [vstruct : struct-2
  key     : string]
 (native
  :cpp
   "vx_core::Type_any val = vstruct->vx_get_any(key);
    output = vx_core::vx_any_from_any(generic_any_1, val);"
  :csharp
   "Vx.Core.Type_any val = vstruct.vx_any(key);
    output = Vx.Core.f_any_from_any(generic_any_1, val);"
  :java
   "Core.Type_any val = vstruct.vx_any(key);
    output = Core.f_any_from_any(generic_any_1, val);"
  :js
   "const subvalmap = vstruct['vx_value']
    if (subvalmap != undefined) {
      if (key.startsWith(':')) {
        key = key.substring(1)
      }
      const val = subvalmap[key]
      if (val != undefined) {
        output = val
      }
    }"
  :kotlin
   "val value : vx_core.Type_any = vstruct.vx_any(key)
    output = vx_core.f_any_from_any(generic_any_1, value);")
 :test (test
        "sname"
        (any<-struct : string
         (translation
          :name "sname")
         :name))
       (test
        "sname"
        (any<-struct : string
         (translation
          :name "sname")
         "name"))
       (test
        "sname"
        (any<-struct : string
         (translation
          :name "sname")
         ":name"))
 :doc "Returns value from a struct")

(func async : any-1 :async
 [value : any-1]
 (native
  :csharp
   "output = Vx.Core.vx_async_new_from_value(value);"
  :java
   "output = Core.vx_async_new_from_value(value);"
  :js
   "value"
  :kotlin
   "output = vx_core.vx_async_new_from_value(value)")
 :doc "Returns an asynchonous version value. This exists mostly for type-casting.")

(func boolean<-any : boolean
 [value : any-1]
 :doc "Function Type taking generic any-1 and returning boolean")

(func boolean<-func : boolean
 []
 :doc "Function Type returning boolean with any parameters")

(func boolean<-none : boolean
 []
 :doc "Function Type returning boolean with no parameters")

(func boolean-permission<-func : boolean
 [func : func]
 (contains
  (allowfuncs<-security
   (security<-context))
  func)
 :context
 :doc "Returns true if the given func has permission.")

(func boolean-write<-map-name-value : boolean
 [valuemap : map-1
  name     : string
  value    : any-1]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto
  :kotlin :auto)
 :test (test
        (stringmutablemap
         :b "y"
         :a "x")
        (let : stringmutablemap
         [smap : stringmutablemap :=
           (stringmutablemap
            :b "y")
          iswrite : boolean :=
           (boolean-write<-map-name-value
            smap :a "x")]
         smap))
       (test
        (stringmutablemap
         :a "x")
        (let : stringmutablemap
         [smap : stringmutablemap :=
           (stringmutablemap
            :b "y"
            :a "x")
          iswrite : boolean :=
           (boolean-write<-map-name-value
            smap :b "")]
         smap))
 :sideeffects
  "Alters a mutable map. Warning: vxlisp is immutable by design, so this function can produce unexpected results."
 :doc "Returns true if it alters a mutable map false if it fails.")

(func case : thenelse
 [values : list-1
  fn-any : any<-func]
 (thenelse
  :code   :casemany
  :values values
  :fn-any fn-any))

(func case : thenelse
 [value  : any-1
  fn-any : any<-func]
 (thenelse
  :code   :case
  :value  value
  :fn-any fn-any))

(func compare : int
 [val1 : any
  val2 : any]
 (native
  :cpp
   "long intresult = vx_core::vx_compare(val1, val2);
    output = vx_core::vx_new_int(intresult);"
  :csharp :auto
  :java
   "int intresult = 0;
    if ((val1 instanceof Core.Type_number) && (val2 instanceof Core.Type_number)) {
      Core.Type_number num1 = (Core.Type_number)val1;
      Core.Type_number num2 = (Core.Type_number)val2;
      float float1 = Core.vx_new(Core.t_float, num1).vx_float();
      float float2 = Core.vx_new(Core.t_float, num2).vx_float();
      if (float1 < float2) {
        intresult = -1;
      } else if (float1 > float2) {
        intresult = 1;
      }
    } else {
      String stringval1 = Core.f_string_from_any(val1).vx_string();
      String stringval2 = Core.f_string_from_any(val2).vx_string();
      int compare = stringval1.compareTo(stringval2);
      if (compare > 0) {
        intresult = 1;
      } else if (compare < 0) {
        intresult = -1;
      }
    }
    output = Core.vx_new_int(intresult);"
  :js
   "if (val1 == val2) {
      output = 0
    } else if (val1 < val2) {
      output = -1
    } else {
      output = 1
    }"
  :kotlin :auto)
 :test (test 1 (compare 3 2))
       (test 1 (compare "z" "a"))
 :doc "Returns 0 if vals are equal, 1 if val1 > val2, -1 if val1 < val2")

(func constdef<-any : constdef
 [value : any]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto
  :kotlin :auto)
 :test (test
        (constdef
         :pkgname "vx/core"
         :name "false"
         :type boolean)
        (constdef<-any false))
 :doc "Returns a constdef, or empty, from any if the value is a constant.")

(func constname<-any : string
 [value : any]
 (let : string
  [cnstdef : constdef := (constdef<-any value)]
  (if : string
   (then (is-empty cnstdef) "")
   (else
    (string
     (:pkgname cnstdef)
     "/"
     (:name cnstdef)))))
 :test (test
        "vx/core/false"
        (constname<-any false))
 :doc "Returns the full name of a constant or blank if not a constant.")

(func contains : boolean
 [text : string
  find : string]
 (native
  :cpp
   "bool check = vx_boolean_from_string_find(text->vx_string(), find->vx_string());
    output = vx_core::vx_new_boolean(check);"
  :csharp
   "bool check = vx_boolean_from_string_find(text.vx_string(), find.vx_string());
    output = Vx.Core.vx_new_boolean(check);"
  :java
   "boolean check = vx_boolean_from_string_find(
      text.vx_string(),
      find.vx_string());
    output = Core.vx_new_boolean(check);"
  :js
   "vx_core.vx_boolean_from_string_find(text, find)"
  :kotlin
   "val check : Boolean = vx_boolean_from_string_find(
      text.vx_string(),
      find.vx_string())
    output = vx_core.vx_new_boolean(check)")
 :test (test-true  (contains "abcde" "cd"))
       (test-false (contains "abcde" "dc"))
 :doc  "Returns true if the given list contains the given value.")

(func contains : boolean
 [values : list-2 :doc "Any list"
  find   : any    :doc "Any value"]
 (native
  :cpp
   "bool booleanresult = false;
    vx_core::vx_Type_listany listvalues = values->vx_list();
    for (vx_core::Type_any item : listvalues) {
      vx_core::Type_boolean iseq = vx_core::f_eq(item, find);
      if (iseq->vx_boolean()) {
        booleanresult = true;
        break;
      }
    }
    output = vx_core::vx_new_boolean(booleanresult);"
  :csharp :auto
  :java
   "boolean booleanresult = false;
    List<Core.Type_any> listvalues = values.vx_list();
    for (Core.Type_any item : listvalues) {
      Core.Type_boolean iseq = Core.f_eq(item, find);
      if (iseq.vx_boolean()) {
        booleanresult = true;
        break;
      }
    }
    output = Core.vx_new_boolean(booleanresult);"
  :js
   "values.includes(find)"
  :kotlin :auto)
 :test (test-true
        (contains (stringlist "1" "2" "3") "2"))
       (test-true
        (contains (intlist 1 2 3) 2))
       (test-false
        (contains (list 1 "2" 3) 2))
 :doc  "Returns true if the given list contains the given value.")

(func context-main : context
 [args : anylist :...]
 (context)
 :doc "Returns the default context for app main execution. Arguments come from the command line.")

(func copy : any-1
 [value  : any-1
  values : anylist :...]
 (native
  :cpp
   "vx_core::vx_Type_listany listany = vx_core::vx_listany_from_anylist(
      values);
    T* output = vx_core::vx_copy(
      generic_any_1, value, listany);"
  :csharp
   "Vx.Core.Type_any[] arrayany = Vx.Core.vx_arrayany_from_anylist(
      values
    );
    object[] arrayobj = (Vx.Core.Type_any[])arrayany;
    T tvalue = (T)value;
    Vx.Core.Type_any anyvalue = tvalue.vx_copy(arrayobj);
    T output = (T)anyvalue;"
  :java
   "@SuppressWarnings(“unchecked”)
    Core.Type_any[] arrayany = Core.vx_arrayany_from_anylist(
      values
    );
    Object[] arrayobj = (Core.Type_any[])arrayany;
    T output = (T)(value.vx_copy(arrayobj));"
  :js
   "vx_core.f_new_from_type(value, ...values)"
  :kotlin
   "val arrayany : Array<vx_core.Type_any> = vx_core.vx_arrayany_from_anylist(
      values
    )
    val valuecopy : vx_core.Type_any = value.vx_copy(*arrayany)
    val output : T = valuecopy as T")
 :bigospace :n
 :bigotime :n
 :test (test
        (stringmap
         :a "1"
         :b "2")
        (copy
         (stringmap :a "1")
         :b "2"))
 :doc "Returns a copy of a given value with the given values added or updated.")

(func else : thenelse
 [fn-any : any<-func]
 (thenelse
  :code   :else
  :fn-any fn-any))

(func empty : any-1
 [type : any-1]
 (native
  :cpp
   "T* output = vx_core::vx_any_from_any(type, type->vx_empty());"
  :csharp
   "T output = Vx.Core.vx_empty(type);"
  :java
   "T output = Core.vx_empty(type);"
  :js
   "vx_core.vx_empty(type)"
  :kotlin
   "val output : T = vx_core.vx_empty(type)")
 :test (test false  (empty boolean))
       (test ""     (empty string))
       (test (list) (empty list))
       (test (map)  (empty map))
 :doc "Returns the empty value for a given type. Can be called using (empty type) or simply (type)")

(func extends<-any : string
 [value : any-1]
 (extends<-typedef (typedef<-any value)))

(func extends<-typedef : string
 [vtypedef : typedef]
 (:extends vtypedef)
 :doc "Get the basetype of a given type")

(func first<-list : any-1
 [values : list-1]
 (any<-list values 1)
 :doc "Returns first value"
 :test (test
        "b"
        (first<-list
         (stringlist
          "b"
          "c"))))

(func first<-list-any<-any : any-1
 [values      : list-1
  fn-any<-any : any<-any]
 (native
  :cpp
   "std::vector<vx_core::Type_any> listvalue = values->vx_list();
    for (vx_core::Type_any value : listvalue) {
      if (value != vx_core::c_nothing) {
        vx_core::Type_any any = fn_any_from_any->vx_any_from_any(value);
        output = vx_core::vx_any_from_any(generic_any_1, any);
        break;
      }
    }"
  :csharp
   "List<Vx.Core.Type_any> listvalue = values.vx_list();
    foreach (Vx.Core.Type_any value in listvalue) {
      if (value != Vx.Core.c_nothing) {
        output = fn_any_from_any.vx_any_from_any(generic_any_1, value);
        break;
      }
    }"
  :java
   "List<Core.Type_any> listvalue = values.vx_list();
    for (Core.Type_any value : listvalue) {
      if (value != Core.c_nothing) {
        output = fn_any_from_any.vx_any_from_any(generic_any_1, value);
        break;
      }
    }"
  :js
   "output = " nothing "
    const fn = fn_any_from_any['vx_value']
    if (fn) {
      for (let index=0;index < values.length;index++) {
        output = fn(generic, values[index])
        if (output != " nothing ") {
          break
        }
      }
    }"
  :kotlin
   "val listvalue : List<vx_core.Type_any> = values.vx_list()
    for (value : vx_core.Type_any in listvalue) {
      if (value != vx_core.c_nothing) {
        output = fn_any_from_any.vx_any_from_any(generic_any_1, value)
        break
      }
    }")
 :doc "Returns first value that is not nothing"
 :test (test
        "b"
        (first<-list-any<-any : string
         (list nothing "b" "c")
         resolve)))

(func float<-string : float
 [text : string]
 (native
  :cpp
   "float num = vx_core::vx_float_from_string(text->vx_string());
    output = vx_core::vx_new_float(num);"
  :csharp
   "float num = Vx.Core.vx_float_from_string(text.vx_string());
    output = Vx.Core.vx_new_float(num);"
  :java
   "float num = Core.vx_float_from_string(text.vx_string());
    output = Core.vx_new_float(num);"
  :js
   "vx_core.vx_float_from_string(text);"
  :kotlin
   "val num : Float = vx_core.vx_float_from_string(text.vx_string())
    output = vx_core.vx_new_float(num)")
 :test (test
        (float 2.3)
        (float<-string
         "2.3"))
 :doc "Returns float from a given string.")

(func fn : any-1
 [parameters : arglist
  fn-any : any<-func]
 :doc "Shell for lambda function calls")

(func funcdef<-func : funcdef
 [value : func]
 (native
  :cpp
   "value->vx_funcdef();"
  :csharp
   "value.vx_funcdef();"
  :java
   "value.vx_funcdef();"
  :kotlin
   "value.vx_funcdef()")
 :doc "Returns the definition of a function")

(func funcname<-funcdef : string
 [funcdef : funcdef]
 (string (:pkgname funcdef) "/" (:name funcdef))
 :doc "Get the name of a given funcdef")

/*
(func if : any-1
 [clause  : boolean
  fn-then : any<-func]
 :doc "Logical lazy If function. Returns empty value if false.")
*/

(func if : any-1
 [clause : boolean
  then   : any-1]
 (native
  :cpp
   "if (clause->vx_boolean()) {
      output = then;
    }"
  :csharp
   "if (clause.vx_boolean()) {
      output = then;
    }"
  :java
   "if (clause.vx_boolean()) {
      output = then;
    }"
  :js
   "if (clause) {
      output = then
    }"
  :kotlin
   "if (clause.vx_boolean()) {
      output = then
    }")
 :test (test
        "a"
        (if (= 2 2) "a"))
       (test
        ""
        (if : string
         (= 1 2)
         "a"))
 :doc  "Logical If function")

/*
(func if : any-1
 [clause  : boolean
  fn-then : any<-func
  fn-else : any<-func]
 :doc "Logical lazy If function")
*/

(func if : any-1
 [clause  : boolean
  thenval : any-1
  elseval : any-1]
 (native
  :cpp
   "if (clause->vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    }"
  :csharp
   "if (clause.vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    }"
  :java
   "if (clause.vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    }"
  :js
   "if (clause) {
      output = thenval
    } else {
      output = elseval
    }"
  :kotlin
   "if (clause.vx_boolean()) {
      output = thenval
    } else {
      output = elseval
    }")
 :test (test
        "a"
        (if
         (= 2 2)
         "a"
         "b"))
       (test
        "b"
        (if
         (= 1 2)
         "a"
         "b"))
 :doc "Logical If function")

(func if : any-1
 [thenelselist : thenelselist :...]
 (native
  :cpp
   "vx_core::Type_any any = vx_core::vx_if_thenelselist(generic_any_1, thenelselist);
    output = vx_core::vx_any_from_any(generic_any_1, any);"
  :csharp :auto
  :java :auto
  :js
   "let fn_any = null
    for (const thenelseval of thenelselist) {
      const thenelse = thenelseval['vx_value']
      const code = thenelse['code']
      switch (code) {
      case ':then':
        const fn_cond = thenelse['fn-cond']
        const fn = fn_cond['vx_value']
        const cond = fn()
        if (cond == true) {
          fn_any = thenelse['fn-any']
        }
        break
      case ':else':
        fn_any = thenelse['fn-any']
        break
      }
      if (fn_any != null) {
        const fn = fn_any['vx_value']
        output = fn()
        break
      }
    }"
  :kotlin :auto)
 :test (test-true
        (if
         (then (= 2 3) false)
         (then (!= 3 3) false)
         (else (! false))))
 :doc "Logical lazy If function with (then) (else) clauses")

(func int<-func : int
 []
 :doc "Function Type returning int with any parameters")

(func int<-string : int
 [value : string]
 (switch : int
  value
  (case "notanumber"  notanumber)
  (case "infinity"    infinity)
  (case "neginfinity" neginfinity)
  (else
   (native
    :cpp
     "// :capture value
      vx_core::Type_int intresult = vx_core::e_int;
      try {
        std::string sval = value->vx_string();
        long ival = std::stoll(sval);
        intresult = vx_core::vx_new_int(ival);
      } catch (std::exception ex) {
        intresult = vx_core::c_notanumber;
      }
      return intresult;"
    :csharp
     "Vx.Core.Type_int intresult = Vx.Core.e_int;
      string strval = value.vx_string();
      try {
        float floatresult = float.Parse(strval);
        int iresult = (int)floatresult;
        intresult = Vx.Core.vx_new_int(iresult);
      } catch (Exception) {
        intresult = Vx.Core.c_notanumber;
      }
      return intresult;"
    :java
     "Core.Type_int intresult = Core.e_int;
      String strval = value.vx_string();
      try {
        float floatresult = Float.parseFloat(strval);
        int iresult = (int)floatresult;
        intresult = Core.vx_new_int(iresult);
      } catch (Exception ex) {
        intresult = Core.c_notanumber;
      }
      return intresult;"
    :js
     "parseInt(value)"
    :kotlin
     "var intresult : vx_core.Type_int = vx_core.e_int
      val strval : String = value.vx_string()
      try {
        val floatresult : Float = strval.toFloat()
        val iresult : Int = floatresult.toInt()
        intresult = vx_core.vx_new_int(iresult)
      } catch (ex : Exception) {
        intresult = vx_core.c_notanumber
      }
      intresult"
    )
  )
 )
 :test (test 4 (int<-string "4"))
       (test 5 (int<-string "5.4"))
       (test 5 (int<-string "5.9"))
       (test notanumber  (int<-string "notanumber"))
       (test infinity    (int<-string "infinity"))
       (test neginfinity (int<-string "neginfinity"))
 :doc  "Function Type converting string to int")

(func is-empty : boolean
 [text : string]
 (native
  :cpp
   "if (text->vx_p_iref == -2) {
      output = vx_core::c_true;
    }"
  :csharp
   "if (text.vx_string().Length == 0) {
      output = Vx.Core.c_true;
    }"
  :java
   "if (text.vx_string().length() == 0) {
      output = Core.c_true;
    }"
  :js
   "if (text.length == 0) {
      output = vx_core.c_true
    }"
  :kotlin
   "if (text.vx_string().length == 0) {
      output = vx_core.c_true
    }")
 :doc "Returns true if text is empty.")

(func is-empty : boolean
 [value : any]
 (native
  :cpp
   "if (value == value->vx_empty()) {
      output = vx_core::c_true;
    }"
  :csharp
   "if (value == value.vx_empty()) {
      output = Vx.Core.c_true;
    } else {
      output = Vx.Core.c_false;
    }"
  :java
   "if (value == value.vx_empty()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }"
  :js
   "const type = vx_core.f_type_from_any(value)
    if (value == vx_core.f_empty(type)) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }"
  :kotlin
   "if (value == value.vx_empty()) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }")
 :test (test-true (is-empty false))
       (test-true (is-empty ""))
       (test-true (is-empty (list)))
       (test-true (is-empty (map)))
 :doc "Returns true if an value is empty")

(func is-endswith : boolean
 [text : string
  find : string]
 (native
  :cpp
   "std::string stext = text->vx_string();
    std::string sfind = find->vx_string();
    if (vx_core::vx_boolean_from_string_ends(stext, sfind)) {
      output = vx_core::c_true;
    }"
  :csharp
   "string stext = text.vx_string();
    string sfind = find.vx_string();
    if (stext.EndsWith(sfind)) {
      output = Vx.Core.c_true;
    }"
  :java
   "String stext = text.vx_string();
    String sfind = find.vx_string();
    if (stext.endsWith(sfind)) {
      output = Core.c_true;
    }"
  :js
   "if (text.endsWith(find)) {
      output = vx_core.c_true
    }"
  :kotlin
   "val stext : String = text.vx_string()
    val sfind : String = find.vx_string()
    if (stext.endsWith(sfind)) {
      output = vx_core.c_true
    }")
 :doc "Returns true if text ends with find.")

(func is-error : boolean
 [value : any-1]
 (let : any-1
  [msgblock : msgblock := (msgblock<-any value)]
  (if : boolean
   (then 
    (!-empty msgblock) true)))
 :test (test-true
        (is-error
         (stringlist
          (msg
           :code "My Err"))))
 :doc "Returns true if value has an error.")

(func is-func : boolean
 [value : any]
 (native
  :cpp
   "vx_core::Type_string extend = " (extends<-any value) ";
    std::string sextend = extend->vx_string();
    vx_core::vx_release(extend);
    if (sextend == “:func”) {
      output = vx_core::c_true;
    }"
  :csharp
   "if (value is Vx.Core.Type_func) {
      output = Vx.Core.c_true;
    }"
  :java
   "if (value instanceof Core.Type_func) {
      output = Core.c_true;
    }"
  :js
   "const extend = " (extends<-any value) "
    if (extend == ':func') {
      output = vx_core.c_true
    }"
  :kotlin
   "if (value is vx_core.Type_func) {
      output = vx_core.c_true
    }")
 :doc "Returns true if value is a function.")

(func is-int : boolean
 [value : any]
 (native
  :cpp
   "bool result = vx_core::vx_is_int(value);
    output = vx_core::vx_new_boolean(result);"
  :csharp
   "bool result = Vx.Core.vx_is_int(value);
    output = Vx.Core.vx_new_boolean(result);"
  :java
   "boolean result = Core.vx_is_int(value);
    output = Core.vx_new_boolean(result);"
  :js "vx_core.vx_is_int(value)"
  :kotlin
   "val result : Boolean = vx_core.vx_is_int(value)
    output = vx_core.vx_new_boolean(result)")
 :test (test-true
        (is-int 2))
       (test-true
        (is-int "2"))
       (test-true
        (is-int infinity))
       (test-true
        (is-int "infinity"))
 :doc "Returns true if the value is an integer.")

(func is-float : boolean
 [value : any]
 (native
  :cpp
   "bool result = vx_core::vx_is_float(value);
    output = vx_core::vx_new_boolean(result);"
  :csharp
   "bool result = Vx.Core.vx_is_float(value);
    output = Vx.Core.vx_new_boolean(result);"
  :java
   "boolean result = Core.vx_is_float(value);
    output = Core.vx_new_boolean(result);"
  :js "vx_core.vx_is_float(value)"
  :kotlin
   "val result : Boolean = vx_core.vx_is_float(value)
    output = vx_core.vx_new_boolean(result)")
 :doc "Returns true if the value is a float.")

(func is-number : boolean
 [value : any]
 (switch : boolean
  (typename<-any value)
  (case (list
         "vx/core/decimal"
         "vx/core/float"
         "vx/core/int"
         "vx/core/number") true)
  (else false))
 :test (test-true  (is-number 5))
       (test-true  (is-number 5.5))
       (test-false (is-number "a"))
 :doc "Return true if value is a number")

(func is-pass<-permission : boolean
 [permission : permission]
 (let : boolean
  [id     : string     := (:id permission)
   lookup : permission := (permission<-id-context id)]
  (= lookup permission))
 :context
 :doc "Returns true if permission passes.")

(func last<-list : any-1
 [values : list-1]
 (let
  [len : int := (length values)]
  (any<-list values len))
 :test (test
        "c"
        (last<-list
         (stringlist
          "b"
          "c")))
 :doc "Returns last value")

(func length : int
 [text : string]
 (native
  :cpp
   "long len = text->vx_string().length();
    output = vx_core::vx_new_int(len);"
  :csharp
   "int len = text.vx_string().Length;
    output = Vx.Core.vx_new_int(len);"
  :java
   "int len = text.vx_string().length();
    output = Core.vx_new_int(len);"
  :js
   "text.length"
  :kotlin
   "val len : Int = text.vx_string().length
    output = vx_core.vx_new_int(len)")
 :test (test
        4
        (length "abcd"))
       (test
        0
        (length ""))
 :doc "Returns length of a string.")

(func length : int
 [values : list-1]
 (native
  :cpp
   "long len = vx_core::vx_int_from_sizet(values->vx_list().size());
    if (len > 0) {
      output = vx_core::vx_new_int(len);
    }"
  :csharp
   "int intresult = values.vx_list().Count();
    output = Core.vx_new_int(intresult);"
  :java
   "int intresult = values.vx_list().size();
    output = Core.vx_new_int(intresult);"
  :js "values.length"
  :kotlin
   "val intresult : Int = values.vx_list().size
    output = vx_core.vx_new_int(intresult)")
 :test (test
        3
        (length
         (stringlist "a" "b" "c")))
 :doc "Returns the currently used size/length of a list")

(func length : int
 [valuemap : map-1]
 (length
  (stringlist<-map valuemap))
 :doc "Returns the length of the given map.")

(func let : any-1
 [args   : arglist
  fn-any : any<-func :: any-1]
 (native
  :cpp
   "vx_core::Type_any any = fn_any->vx_any_from_func();
    output = vx_core::vx_any_from_any(generic_any_1, any);"
  :csharp
   "fn_any.vx_any_from_func(generic_any_1);"
  :java
   "fn_any.vx_any_from_func(generic_any_1);"
  :js
   "const fn = fn_any['vx_value']
    if (fn) {
      output = fn()
    }"
  :kotlin
   "fn_any.vx_any_from_func(generic_any_1)")
 :test (test
        7
        (let
         [v1 : int := 2
          v2 : int := (+ v1 3)]
         (+ v1 v2))))

(func let-async : any-1 :async
 [args         : arglist
  fn-any-async : any<-func-async]
 (native
  :cpp
   "fn_any_async->vx_any_from_func_async(generic_any_1);"
  :csharp
   "fn_any_async.vx_any_from_func_async(generic_any_1);"
  :java
   "fn_any_async.vx_any_from_func_async(generic_any_1);"
  :js
   "const fn = fn_any_async['vx_value']
    if (fn) {
      output = await fn()
    }"
  :kotlin
   "fn_any_async.vx_any_from_func_async(generic_any_1)")
 :doc "Same as normal let but returns async values.")

(func list<-list : list-1
 [values : list-2]
 (list<-list : list-1
  values
  (fn : any
   [value : any]
   value))
 :test (test
        (stringlist "10" "20")
        (list<-list : stringlist
         (anylist "10" "20")))
 :doc "Return a list with allowed values from another list")

(func list<-list : list-1
 [values      : list-2
  fn-any<-any : any<-any]
 (native
  :cpp
   "vx_core::vx_Type_listany list_value = values->vx_list();
    vx_core::vx_Type_listany list_result = vx_core::vx_listany_from_listany_fn(list_value, [fn_any_from_any](vx_core::Type_any val) {
      return fn_any_from_any->vx_any_from_any(val);
    });
    vx_core::Type_any anylist = generic_list_1->vx_new(list_result);
    output = vx_core::vx_any_from_any(generic_list_1, anylist);"
  :csharp :auto
  :java
   "List<Core.Type_any> list_value = values.vx_list();
    List<Core.Type_any> list_result = Core.arraylist_from_arraylist_fn(list_value, (val) -> {
      return fn_any_from_any.vx_any_from_any(generic_list_1, val);
    });
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));"
  :js
   "const fn = fn_any_from_any['vx_value']
    if (fn) {
      output = values.map(fn)
      output['vx_type'] = generic_list_1
    }"
  :kotlin :auto)
 :doc "Returns a list of processed items from another list")

(func list<-list-async  : list-1 :async
 [values                : list-2
  fn-any<-any-async : any<-any-async]
 (native
  :cpp
   "vx_core::vx_Type_listany list_value = values->vx_list();
    vx_core::vx_Type_listasync list_async_result = vx_core::vx_listasync_from_listany_fn(list_value, [fn_any_from_any_async](vx_core::Type_any val) {
      return fn_any_from_any_async->vx_any_from_any_async(vx_core::vx_type(val), val);
    });
    output = vx_core::vx_async_new_from_listasync(generic_list_1, list_async_result);"
  :csharp :auto
  :java   :auto
  :js
   "const fn = fn_any_from_any_async['vx_value']
    if (fn) {
      const listfuture = values.map(fn)
      const future = Promise.all(listfuture)
      output = await future
      output['vx_type'] = generic_list_1
    }"
  :kotlin :auto)
 :doc "Returns an asynchronous list of the processed asynchronous items from another list")

(func list<-list-intany : list-1
 [values          : list-2
  fn-any<-int-any : any<-int-any]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto
  :kotlin :auto)
 :test (test
        (stringlist "a1" "b2")
        (list<-list-intany : stringlist
         (stringlist "a" "b")
         (fn : stringlist
          [index : int
           value : string]
          (string value index))))
 :doc "Returns a list of processed items from another list")

(func list<-map : list-1
 [valuemap : map-2]
 (list<-map : list-1
  valuemap
  (fn : any
   [key   : string
    value : any]
   value))
 :test (test
        (stringlist "a1" "b2")
        (list<-map : stringlist
         (stringmap
          :x "a1"
          :y "b2")))
 :doc "Returns a list of allowed values from a map.")

(func list<-map : list-1
 [valuemap          : map-2
  fn-any<-key-value : any<-key-value]
 (native
  :cpp :auto
  :csharp :auto
  :java
   "Map<String, Core.Type_any> map_value = valuemap.vx_map();
    List<Core.Type_any> listresult = Core.arraylist_from_linkedhashmap_fn(map_value, (key, val) -> {
      Core.Type_string valkey = Core.vx_new_string(key);
      return fn_any_from_key_value.vx_any_from_key_value(Core.t_any, valkey, val);
    });
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(listresult));"
  :js
   "vx_core.vx_list_from_map_fn(generic_list_1, valuemap, fn_any_from_key_value)"
  :kotlin :auto)
 :test (test
        (stringlist "a1" "b2")
        (list<-map : stringlist
         (stringmap "a" "1" "b" "2")
         (fn : string
          [key   : string
           value : string]
          (string key value))))
 :doc "Returns a list from a map by applying a function to each key value.")

(func list<-map-async : list-1 :async
 [valuemap                : map-2
  fn-any<-key-value-async : any<-key-value-async])

(func list<-type : any
 [type : any]
 (native
  :js
   "output = []
    output['vx_type'] = type")
 :doc "Create an empty list from a type. Used internally for default lists")

(func log : any
 [value : any]
 (native
  :cpp
   "vx_core::vx_log(value);
    output = value;"
  :csharp
   "Vx.Core.vx_log(value);
    output = value;"
  :java
   "Core.vx_log(value);
    output = value;"
  :js
   "const text = vx_core.f_string_from_any(value)
    console.log(text)
    output = value"
  :kotlin
   "vx_core.vx_log(value)
    output = value")
 :doc "Writes a value to the console.")

(func log : any-1
 [text  : string
  value : any-1]
 (native
  :cpp
   "vx_core::vx_log(text);
    vx_core::vx_log(value);
    output = value;"
  :csharp
   "Vx.Core.vx_log(text);
    Vx.Core.vx_log(value);
    output = value;"
  :java
   "Core.vx_log(text);
    Core.vx_log(value);
    output = value;"
  :js
   "console.log(text)
    const svalue = vx_core.f_string_from_any(value)
    console.log(svalue)
    output = value"
  :kotlin
   "vx_core.vx_log(text)
    vx_core.vx_log(value)
    output = value")
 :doc "Writes a string and a value to the console.")

(func log-error : any-1
 [value : any-1]
 (if : any-1
  (then
   (is-error value)
   (log value))
  (else value))
 :doc "Write a value if it has an error.")

(func main : string
 [args : anylist :...]
 (string args)
 :doc "The default function for app main execution. Arguments come from the command line.")

(func map<-list : map-1
 [vallist     : list-2
  fn-any<-any : any<-any :: string]
 (native
  :cpp
   "vx_core::vx_Type_listany listany = vallist->vx_list();
    vx_core::vx_Type_mapany mapany = vx_core::vx_map_from_list(listany, fn_any_from_any);
    output = vx_core::vx_new_map(generic_map_1, mapany);"
  :csharp :auto
  :java
   "List<Core.Type_any> listval = vallist.vx_list();
    Map<String, Core.Type_any> mapresult = Core.vx_map_from_list_fn(listval, (val) -> {
      return fn_any_from_any.vx_any_from_any(Core.t_string, val);
    });
    output = Core.f_any_from_any(generic_map_1, output.vx_new_from_map(mapresult));"
  :js
   "const valmap = {}
    vallist.map(value => {
      const fn = fn_any_from_any['vx_value']
      if (fn) {
        const key = fn(value)
        valmap[key] = value
      }
    })
    output = {
      vx_type: generic_map_1,
      vx_value: valmap
    }"
  :kotlin :auto)
 :test (test
        (stringmap
         "keya" "a"
         "keyb" "b")
        (map<-list : stringmap
         (stringlist "a" "b")
         (fn : string
          [value : string]
          (string "key" value))))
 :doc "Returns a map from a list by applying a function to generate a key for each value.")

(func map<-map : map-1
 [valuemap : map-2]
 (map<-map : map-1
  valuemap
  (fn : any
   [key   : string
    value : any]
   value))
 :test (test
        (stringmap :a "1")
        (map<-map : stringmap
         (anymap :a "1")))
 :doc "Return a map with allowed values from another map")

(func map<-map : map-1
 [valuemap          : map-2
  fn-any<-key-value : any<-key-value]
 (native
  :cpp
   "vx_core::Type_any map = vx_core::vx_map_from_map_fn(generic_map_1, valuemap, fn_any_from_key_value);
    output = vx_core::vx_any_from_any(generic_map_1, map);"
  :csharp
   "Vx.Core.vx_map_from_map_fn(generic_map_1, valuemap, fn_any_from_key_value);"
  :java
   "Core.vx_map_from_map_fn(
      generic_map_1,
      valuemap,
      fn_any_from_key_value);"
  :js
   "vx_core.vx_map_from_map_fn(
      generic_map_1,
      valuemap,
      fn_any_from_key_value)"
  :kotlin
   "vx_core.vx_map_from_map_fn(
      generic_map_1,
      valuemap,
      fn_any_from_key_value)")
 :test (test
        (stringmap
         :a "a1"
         :b "b2")
        (map<-map : stringmap
         (stringmap
          :a "1"
          :b "2")
         (fn : string
          [key : string
           value : string]
          (string key value))))
 :doc "Returns a map from a map by applying a function to each key value.")

(func msg<-error : msg
 [error : string]
 (msg
  :severity msg-error
  :text error)
 :doc "Returns a msg from error string")

(func msg<-error : msg
 [code   : string
  detail : any]
 (msg
  :code code
  :detail detail
  :severity msg-error)
 :doc "Returns a msg from error code and detail")

(func msg<-error : msg
 [path   : string
  code   : string
  detail : any]
 (msg
  :code     code
  :path     path
  :severity msg-error
  :detail   detail)
 :doc "Returns a msg from error path code and detail")

(func msg<-warning : msg
 [warning : string]
 (msg
  :severity msg-warning
  :text warning)
 :doc "Returns a msg from a warning string")

(func msgblock<-any : msgblock
 [value : any]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto
  :kotlin :auto)
 :doc "Returns a msgblock from any")

(func msgblock<-msgblock-msg : msgblock
 [origblock : msgblock
  addmsg    : msg]
 (copy origblock addmsg)
 :doc "Return a new Msgblock with the added msg")

(func msgblock<-msgblock-msgblock : msgblock
 [origblock : msgblock
  addblock  : msgblock]
 (msgblock origblock addblock)
 :doc "Return a new Msgblock with the added block")

(func name<-typedef : string
 [vtypedef : typedef]
 (:name vtypedef)
 :doc "Returns the name from a typedef.")

(func native : any-1
 [clauses : anylist :...]
 :doc "Native Function Call")

(func native<-any : any
 [value : any-1]
 (native
  :js
   "output = value
    switch (typeof value) {
    case 'boolean':
    case 'number':
    case 'string':
      break
    default:
      const extend = " (extends<-any value) "
      switch (extend) {
      case ':list':
        output = [...value]
        break
      case ':func':
      case ':map':
      case ':struct':
        output = value['vx_value']
        break
      }
      break
    }")
  :doc "Returns native value of value object")

(func new : any-1
 [values : anylist :...]
 (native
  :cpp
   "vx_core::vx_Type_listany listany = vx_core::vx_listany_from_anylist(
      values);
    output = vx_core::vx_new(
      generic_any_1, listany);"
  :csharp
   "Vx.Core.Type_any[] arrayany = Vx.Core.vx_arrayany_from_anylist(
      values
    );
    object[] arrayobj = (Vx.Core.Type_any[])arrayany;
    output = (T)(generic_any_1.vx_new(arrayobj));"
  :java
   "Core.Type_any[] arrayany = Core.vx_arrayany_from_anylist(
      values
    );
    Object[] arrayobj = (Core.Type_any[])arrayany;
    output = (T)(generic_any_1.vx_new(arrayobj));"
  :js
   "vx_core.vx_new(generic_any_1, values)"
  :kotlin
   "val arrayany : Array<vx_core.Type_any> = vx_core.vx_arrayany_from_anylist(
      values
    )
    val anyvalue : vx_core.Type_any = generic_any_1.vx_new(*arrayany)
    output = anyvalue as T")
 :test (test true (new : boolean true))
       (test 4 (new : int 4))
       (test 5.4 (new : float 5.4))
       (test "a" (new : string "a"))
       (test
        (stringlist "a" "b" "c")
        (new : stringlist "a" "b" "c"))
       (test
        (stringmap :a "1" :b "2")
        (new : stringmap :a "1" :b "2"))
 :doc "Create a new Value of Type A")

(func new<-type : any-1
 [type   : any-1
  values : anylist :...]
 (native
  :cpp
   "vx_core::vx_Type_listany listany = vx_core::vx_listany_from_anylist(
      values);
    T* output = vx_core::vx_new(
      type, listany);"
  :csharp
   "Vx.Core.Type_any[] arrayany = Vx.Core.vx_arrayany_from_anylist(
      values
    );
    object[] arrayobj = (Vx.Core.Type_any[])arrayany;
    T output = (T)(type.vx_new(arrayobj));"
  :java
   "Core.Type_any[] arrayany = Core.vx_arrayany_from_anylist(
      values
    );
    Object[] arrayobj = (Core.Type_any[])arrayany;
    T output = (T)(type.vx_new(arrayobj));"
  :js
   "vx_core.vx_new(type, values)"
  :kotlin
   "val arrayany : Array<vx_core.Type_any> = vx_core.vx_arrayany_from_anylist(
      values
    )
    val anyvalue : vx_core.Type_any = type.vx_new(*arrayany)
    val output : T = anyvalue as T")
 :test (test true (new<-type boolean true))
       (test 4 (new<-type int 4))
       (test 5.4 (new<-type float 5.4))
       (test "a" (new<-type string "a"))
       (test
        (stringlist "a" "b" "c")
        (new<-type stringlist "a" "b" "c"))
       (test
        (stringmap :a "1" :b "2")
        (new<-type stringmap :a "1" :b "2"))
 :doc "Create a new Value of Type A")

(func number<-func : number
 []
 :doc "Function Type returning number with any parameters")

(func or : boolean
 [val1 : boolean
  val2 : boolean]
 (native
  :cpp
   "if (val1->vx_boolean() || val2->vx_boolean()) {
      output = vx_core::c_true;
    } else {
      output = vx_core::c_false;
    }"
  :csharp
   "if (val1.vx_boolean() || val2.vx_boolean()) {
      output = Vx.Core.c_true;
    } else {
      output = Vx.Core.c_false;
    }"
  :java
   "if (val1.vx_boolean() || val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }"
  :js
   "if (val1 || val2) {
      output = true
    } else {
      output = false
    }"
  :kotlin
   "if (val1.vx_boolean() || val2.vx_boolean()) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }")
 :doc  "Returns true if any value is true"
 :test (test-true (or true true))
       (test-true (or true false))
       (test-false (or false false)))

(func or : boolean
 [values : booleanlist :...]
 (any<-list-start-reduce-next : boolean
  values
  false
  (fn : boolean
   [reduce  : boolean
    current : boolean
    next    : boolean]
   (or reduce (or current next))))
 :doc  "Returns true if any value is true"
 :test (test-true (or false true false))
       (test-false (or false false false)))

(func package-global<-name : package
 [name : string]
 (any<-map
  (:packagemap global)
  name)
 :doc "Returns a package from global with the given name.")

(func packagename<-typedef : string
 [vtypedef : typedef]
 (:pkgname vtypedef)
 :doc "Returns the package name from a typedef.")

(func path<-context-path : string
 [path : string]
 (path<-setting-path
  (setting<-context)
  path)
 :context
 :doc "Returns a path from a context")

(func path<-setting-path : string
 [session : setting
  path    : string]
 :doc "Returns a path from a setting")

(func permission<-id-context : permission
 [id : string]
 (let
  [user          : user          := (user<-context)
   security      : security      := (:security user)
   permissionmap : permissionmap := (:permissionmap security)]
  (:id permissionmap))
 :context
 :doc "Return a permission from context by id")

(func properties<-typedef : argmap
 [vtypedef : typedef]
 (:properties vtypedef)
 :doc "Return property map from typedef")

(func proplast<-typedef : arg
 [vtypedef : typedef]
 (:proplast vtypedef)
 :doc "Return last property from typedef")

(func resolve : any-1
 [value : any-1]
 value
 :test (test "a" (resolve "a")))

(func resolve : any-1
 [fn-any : any<-func]
 (native
  :cpp
   "if (fn_any) {
      vx_core::Type_any any = fn_any->vx_any_from_func();
      output = vx_core::vx_any_from_any(generic_any_1, any);
    }"
  :csharp
   "if (fn_any == null) {
    } else if (fn_any == Vx.Core.e_any_from_func) {
    } else {
      output = fn_any.vx_any_from_func(generic_any_1);
    }"
  :java
   "if (fn_any == null) {
    } else if (fn_any == Core.e_any_from_func) {
    } else {
      output = fn_any.vx_any_from_func(generic_any_1);
    }"
  :js
   "const typedef = " (typedef<-any fn-any) "
    const extend = vx_core.f_extends_from_typedef(typedef)
    switch (extend) {
    case ':func':
      const fn = fn_any['vx_value']
      if (fn) {
        output = fn()
      }
      break
    default:
      output = fn_any
      break
    }"
  :kotlin
   "if (fn_any == null) {
    } else if (fn_any == vx_core.e_any_from_func) {
    } else {
      output = fn_any.vx_any_from_func(generic_any_1)
    }")
 :test (test 4 (resolve (fn : int [] (+ 1 3)))))

(func resolve-async : any-1 :async
 [fn-any : any<-func-async]
 (native
  :cpp
   "if (fn_any) {
      output = fn_any->vx_any_from_func_async(generic_any_1);
    }"
  :csharp
   "if (fn_any == null) {
    } else if (fn_any == Vx.Core.e_any_from_func_async) {
    } else {
      output = fn_any.vx_any_from_func_async(generic_any_1);
    }"
  :java
   "if (fn_any == null) {
    } else if (fn_any == Core.e_any_from_func_async) {
    } else {
      output = fn_any.vx_any_from_func_async(generic_any_1);
    }"
  :js
   "const typedef = " (typedef<-any fn-any) "
    const extend = vx_core.f_extends_from_typedef(typedef)
    switch (extend) {
    case ':func':
      const fn = fn_any['vx_value']
      if (fn) {
        output = await fn()
      }
      break
    default:
      output = fn_any
      break
    }"
  :kotlin
   "if (fn_any == null) {
    } else if (fn_any == vx_core.e_any_from_func_async) {
    } else {
      output = fn_any.vx_any_from_func_async(generic_any_1)
    }")
 :test (test 4 (resolve : int (fn : int [] (+ 1 3)))))

(func resolve-first : any-1
 [clauses : list-1 :...]
 (first<-list-any<-any
  clauses
  resolve)
 :doc "Returns the first value that is not nothing")

(func resolve-list : list-1
 [clauses : list-1]
 (list<-list clauses resolve))

(func security<-context : security
 (security<-user (user<-context))
 :context
 :doc "Return security from the given context.")

(func security<-user : security
 [user : user]
 (:security user)
 :doc "Return security from the given user.")

(func session<-context : session
 (:session context)
 :context
 :doc "Returns session from a context")

(func setting<-context : setting
 (:setting context)
 :context
 :doc "Returns setting from a context")

(func string-repeat : string
 [text   : string
  repeat : int]
 (native
  :cpp
   "std::string stringtext = vx_core::vx_string_from_string_repeat(text->vx_string(), repeat->vx_int());
    output = vx_core::vx_new_string(stringtext);"
  :csharp :auto
  :java
   "String stringtext = text.vx_string();
    int intrepeat = repeat.vx_int();
    String stringresult = stringtext.repeat(intrepeat);
    output = Core.vx_new_string(stringresult);"
  :js "text.repeat(repeat)"
  :kotlin :auto)
 :test (test "abab" (string-repeat "ab" 2)))

(func string<-any : string
 [value : any]
 (string<-any-indent value 0 true)
 :test (test "true"  (string<-any true))
       (test "4"     (string<-any 4))
       (test "5.4"   (string<-any 5.4))
       (test "\"a\"" (string<-any "a"))
       (test
        "(stringlist
          \"a\"
          \"b\"
          \"c\")"
        (string<-any (stringlist "a" "b" "c")))
       (test
        "(stringmap
          :a \"1\"
          :b \"2\")"
        (string<-any (stringmap :a "1" :b "2")))
 :doc "Return a string representation of a value")

(func string<-any-indent : string
 [value    : any
  indent   : int
  linefeed : boolean]
 (native
  :cpp
   "std::string soutput = vx_core::vx_string_from_any_indent(value, indent->vx_int(), linefeed->vx_boolean(), false);
    output = vx_core::vx_new_string(soutput);"
  :csharp :auto
  :java :auto
  :js
   "output = vx_core.vx_string_from_any_indent(value, indent, linefeed)"
  :kotlin :auto)
 :doc "Return a string representation of a value")

(func string<-func : string
 []
 :doc "Function Type returning string with any parameters")

(func string<-string-find-replace : string
 [text    : string
  find    : string
  replace : string]
 (native
  :cpp    :auto
  :csharp :auto
  :java   :auto
  :js     :auto
  :kotlin :auto)
 :test (test
        "a!b!c"
        (string<-string-find-replace
         "axybxyc"
         "xy"
         "!"))
 :doc "Returns a string with all instances of find replaced by replace.")

(func stringlist<-map : stringlist
 [map : map-1]
 (list<-map : stringlist
  map
  (fn : string
   [key   : string
    value : any]
   key))
 :test (test
        (stringlist "b" "a")
        (stringlist<-map
         (intmap
          :b 1
          :a 2)))
 :doc "Returns a stringlist of keys from any map in entry order.")

(func switch : any-1
 [value        : any-2
  thenelselist : thenelselist :...]
 (native
  :cpp
   "vx_core::Type_any any = vx_core::vx_switch(generic_any_1, value, thenelselist);
    output = vx_core::vx_any_from_any(generic_any_1, any);"
  :csharp :auto
  :java
   "Core.Func_any_from_func fn_any = null;
    List<Core.Type_thenelse> listthenelse = thenelselist.vx_listthenelse();
    for (Core.Type_thenelse thenelse : listthenelse) {
      Core.Type_string code = thenelse.code();
      switch (code.vx_string()) {
      case “:case”:
        Core.Type_any value2 = thenelse.value();
        Core.Type_boolean iseq = Core.f_eq(value, value2);
        if (iseq.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case “:casemany”:
        Core.Type_list values = thenelse.values();
        Core.Type_boolean iscontain = Core.f_contains_1(values, value);
        if (iscontain.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case “:else”:
        fn_any = thenelse.fn_any();
        break;
      }
      if (fn_any != null) {
        break;
      }
    }
    if (fn_any != null) {
      output = fn_any.vx_any_from_func(generic_any_1);
    }"
  :js
   "let fn_any = null
    if (thenelselist.length > 0) {
      for (let valthenelse of thenelselist) {
        const thenelse = valthenelse['vx_value']
        const code = thenelse['code']
        switch (code) {
        case ':case':
          const value2 = thenelse['value']
          if (value2 == value) {
            fn_any = thenelse['fn-any']
          } else if (typeof value2 == 'number') {
            // special handling of notanumber
            if (isNaN(value) && isNaN(value2)) {
              fn_any = thenelse['fn-any']
            }
          }
          break
        case ':casemany':
          const values = thenelse['values']
          if (values.includes(value)) {
            fn_any = thenelse['fn-any']
          }
          break
        case ':else':
          fn_any = thenelse['fn-any']
          break
        }
        if (fn_any != null) {
          break
        }
      }
      if (fn_any != null) {
        const fn = fn_any['vx_value']
        if (fn) {
          output = fn()
        }
      }
    }"
  :kotlin :auto)
 :test (test 1
        (switch : int
         "d"
         (case (list "b" "c" "d") 1)
         (else 2)))
 :doc "Returns a value based on a logical switch")

(func then : thenelse
 [fn-cond : boolean<-func
  fn-any  : any<-func]
 (thenelse
  :code    :then
  :fn-cond fn-cond
  :fn-any  fn-any)
 :doc "Returns a thenelse struct from a given condition function and value function")

(func traits<-typedef : typelist
 [vtypedef : typedef]
 (:traits vtypedef)
 :doc "Get the traits of a given typedef")

(func type<-any : any
 [value : any-1]
 (native
  :cpp
   "value->vx_type();"
  :csharp
   "output = value.vx_type();"
  :java
   "output = value.vx_type();"
  :js
   "switch (typeof value) {
    case 'boolean':
      output = " boolean "
      break
    case 'number':
      switch (value) {
      case " infinity ":
      case " neginfinity ":
      case " notanumber ":
        output = " int "
        break
      default:
        const strval = '' + value
        if (strval.indexOf('.') < 0) {
          output = " int "
        } else {
          output = " float "
        }
        break
      }
      break
    case 'string':
      output = " string "
      break
    case 'function':
      output = " func "
      break
    default:
      output = value['vx_type']
      if (output == vx_core.t_type) {
        output = value
      }
      break
    }"
  :kotlin
   "output = value.vx_type()")
 :test (test
        boolean
        (type<-any false))
       (test
        int
        (type<-any 5))
       (test
        string
        (type<-any "a"))
 :doc  "Gets the Type of a given Value")

(func typedef<-any : typedef
 [value : any]
 (typedef<-type (type<-any value))
 :doc  "Gets the typedef of a given value")

(func typedef<-type : typedef
 [value : any]
 (native
  :cpp
   "value->vx_typedef();"
  :csharp
   "value.vx_typedef();"
  :java
   "value.vx_typedef();"
  :js
   "output = value"
  :kotlin
   "value.vx_typedef()")
 :doc  "Gets the typedef of a given type")

(func typename<-any : string
 [value : any-2]
 (typename<-type (type<-any value))
 :test (test "vx/core/boolean" (typename<-any false))
       (test "vx/core/int"     (typename<-any 5))
       (test "vx/core/string"  (typename<-any "a"))
 :doc  "Gets the typename of a given value")

(func typename<-type : string
 [type : any]
 (typename<-typedef (typedef<-type type))
 :doc "Get the name of a given type")

(func typename<-typedef : string
 [vtypedef : typedef]
 (string (:pkgname vtypedef) "/" (:name vtypedef))
 :doc "Get the name of a given type")

(func typenames<-typelist : stringlist
 [typelist : typelist]
 (list<-list : stringlist
  typelist
  (fn : string
   [type : any]
   (typename<-type type)))
 :doc "Get the names from a type list")

(func user<-context : user
 (:user (session<-context))
 :context
 :doc "Returns the current user from context.")
