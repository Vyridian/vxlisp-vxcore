#include <exception>
#include <iostream>
#include <map>
#include <sstream>
#include <string>
#include <vector>
#include "core.hpp"

namespace vx_core {

// :body

  long refcount = 0;

  vx_core::vx_Type_listany emptylistany;
  vx_core::vx_Type_mapany emptymapany;

  // class vx_Class_async {
    // dispose
    void vx_Class_async::vx_dispose() {
      if (this->lambdavars.size() > 0) {
        vx_core::vx_release_one(this->lambdavars);
        this->lambdavars.clear();
      }
      vx_core::vx_release_one(this->value);
      this->value = NULL;
      vx_core::vx_release_one_async(this->async_parent);
      this->async_parent = NULL;
      vx_core::vx_Type_future future = this->future;
      if (future) {
        this->future = NULL;
        delete future;
      }
      vx_core::vx_release_one_async(this->listasync);
    }
    // sync_value
    vx_core::Type_any vx_Class_async::sync_value() {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = this->value;
      if (!value) {
        vx_core::vx_Type_future future = this->future;
        if (future) {
          future->wait();
          value = future->get();
          this->future = NULL;
          delete future;
        }
      }
      if (!value) {
        vx_core::vx_Type_async async_parent = this->async_parent;
        if (async_parent) {
          vx_core::Type_any parentvalue = async_parent->sync_value();
          vx_core::vx_Type_fn_any_from_any fn = this->fn;
          if (!fn) {
            value = parentvalue;
          } else {
            value = fn(parentvalue);
            this->fn = NULL;
          }
          vx_core::vx_reserve(value);
          this->async_parent = NULL;
          vx_core::vx_release_one_async(async_parent);
          if (this->lambdavars.size() > 0) {
            vx_core::vx_release_one(this->lambdavars);
            this->lambdavars.clear();
          }
        }
      }
      if (!value) {
        vx_core::vx_Type_listasync listasync = this->listasync;
        if (listasync.size() > 0) {
          vx_core::vx_Type_listany listany;
          for (vx_core::vx_Type_async asyncsub : listasync) {
            vx_core::Type_any any = asyncsub->sync_value();
            vx_core::vx_release_one_except_async(asyncsub, any);
            listany.push_back(any);
          }
          this->listasync.clear();
          value = this->type->vx_new(listany);
          vx_core::vx_reserve(value);
        }
      }
      if (value) {
        this->value = value;
        output = value;
      }
      return output;
    }
  // }

  // vx_any_from_func_1(generic_any_1, func, args...)
  vx_core::Type_any vx_any_from_func_1(vx_core::Type_any generic_any_1, vx_core::Type_replfunc func, vx_core::vx_Type_listany args) {
    vx_core::Type_anylist anylist = vx_core::vx_new_anylist(args);
    vx_core::Type_any output = func->vx_repl(anylist);
    return output;
  }

  // vx_any_from_list_result_next(generic_any_1, list, any<-reduce-next)
  vx_core::Type_any vx_any_from_list_result_next(vx_core::Type_any generic_any_1, vx_core::Type_list list, vx_core::Type_any valstart, vx_core::Func_any_from_reduce_next fn_reduce_next) {
    vx_core::Type_any output = valstart;
    vx_core::vx_Type_listany listval = list->vx_list();
    vx_core::Type_any current = vx_core::e_any;
    bool first = true;
    for (vx_core::Type_any next : listval) {
      if (first) {
        first = false;
      } else {
        output = fn_reduce_next->vx_any_from_reduce_next(output, current, next);
      }
      current = next;
    }
    return output;
  }

  // vx_any_from_map_start_reduce(generic_any_1, map, any<-any-key-value)
  vx_core::Type_any vx_any_from_map_start_reduce(vx_core::Type_any generic_any_1, vx_core::Type_map map, vx_core::Type_any start, vx_core::Func_any_from_any_key_value fn_reduce) {
    vx_core::Type_any output = start;
    std::map<std::string, vx_core::Type_any> mapval = map->vx_map();
    for (auto const& [skey, value] : mapval) {
      vx_core::Type_string key = vx_core::vx_new_string(skey);
      output = fn_reduce->vx_any_from_any_key_value(output, key, value);
    }
    return output;
  }

  // vx_anylist_from_arraystring(long, array<string>, boolean)
  vx_core::Type_anylist vx_anylist_from_arraystring(long ilen, char* arraystring[], bool isskipfirst) {
    std::vector<std::string> liststring = vx_core::vx_liststring_from_arraystring(ilen, arraystring);
    std::vector<vx_core::Type_any> listval;
    bool isfirst = true;
    for (std::string sval : liststring) {
      if (isfirst && isskipfirst) {
      } else {
        vx_core::Type_string val = vx_core::vx_new_string(sval);
        vx_core::vx_reserve(val);
        listval.push_back(val);
      }
      isfirst = false;
    }
    vx_core::Class_anylist* anylist = new vx_core::Class_anylist();
    anylist->vx_p_list = listval;
    vx_core::Type_anylist output = anylist;
    return output;
  }

  // vx_argmap_from_listarg(List<arg>)
  vx_core::Type_argmap vx_argmap_from_listarg(
    std::initializer_list<vx_core::Type_arg> listarg) {
    std::vector<std::string> listkey;
    std::map<std::string, vx_core::Type_arg> maparg;
    for (vx_core::Type_arg arg : listarg) {
      std::string name = arg->name()->vx_string();
      std::string key = ":" + name;
      listkey.push_back(key);
      maparg[name] = arg;
    }
    vx_core::Type_argmap output = new vx_core::Class_argmap();
    output->vx_p_keys = listkey;
    output->vx_p_map = maparg;
    return output;
  }

  // vx_async_from_async_fn(async, type, lambdavars, fn<any>(any))
  vx_core::vx_Type_async vx_async_from_async_fn(vx_core::vx_Type_async async, vx_core::Type_any type, vx_core::vx_Type_listany lambdavars, vx_core::vx_Type_fn_any_from_any fn) {
    vx_core::vx_Type_async output = new vx_core::vx_Class_async();
    output->type = type;
    output->async_parent = async;
    output->fn = fn;
    output->lambdavars = lambdavars;
    vx_core::vx_reserve(lambdavars);
    vx_core::vx_reserve_async(async);
    return output;
  }

  // vx_async_new_from_future(T, future<T>)
  vx_core::vx_Type_async vx_async_new_from_future(vx_core::Type_any generic_any_1, vx_core::vx_Type_future future) {
    vx_core::vx_Type_async output = new vx_core::vx_Class_async();
    output->type = generic_any_1;
    output->future = future;
    return output;
  }

  // vx_async_new_from_listasync(T, List<async>)
  vx_core::vx_Type_async vx_async_new_from_listasync(
    vx_core::Type_any generic_list_1,
    vx_core::vx_Type_listasync listasync) {
    vx_core::vx_Type_async output;
    if (listasync.size() == 0) {
      output = vx_core::vx_async_new_from_value(generic_list_1->vx_empty());
    } else {
      output = new vx_core::vx_Class_async();
      output->type = generic_list_1;
      output->listasync = listasync;
      vx_core::vx_reserve_async(listasync);
    }
    return output;
  }

  // vx_async_new_from_value(any)
  vx_core::vx_Type_async vx_async_new_from_value(vx_core::Type_any value) {
    vx_core::vx_Type_async output = new vx_core::vx_Class_async();
    output->type = value->vx_type();
    output->value = value;
    vx_core::vx_reserve(value);
    return output;
  }

  // vx_boolean_from_string_ends(string, string)
  bool vx_boolean_from_string_ends(std::string text, std::string ends) {
    bool output = false;
    if (text.length() < ends.length()) {
    } else {
      output = text.substr(text.length() - ends.length()) == ends;
    }
    return output;
  }

  // vx_boolean_from_string_find(string, string)
  bool vx_boolean_from_string_find(std::string text, std::string find) {
    bool output = false;
    if (text.find(find) != std::string::npos) {
      output = true;
    }
    return output;
  }

  // vx_boolean_from_string_starts(string, string)
  bool vx_boolean_from_string_starts(std::string text, std::string starts) {
    bool output = false;
    if (text.rfind(starts, 0) == 0) {
      output = true;
    }
    return output;
  }

  // vx_boolean_from_type_trait(type, type)
  bool vx_boolean_from_type_trait(vx_core::Type_any type, vx_core::Type_any trait) {
    bool output = false;
    if (type == trait) {
      output = true;
    } else {
      vx_core::Type_typedef typdef = type->vx_typedef();
      vx_core::Type_typelist traits = typdef->traits();
      vx_core::vx_Type_listany list = traits->vx_list();
      output = (std::find(list.begin(), list.end(), trait) != list.end());
      vx_core::vx_release(typdef);
    }
    return output;
  }

  // vx_boolean_write_from_map_name_value(map, string, any)
  vx_core::Type_boolean vx_boolean_write_from_map_name_value(vx_core::Type_map valuemap, vx_core::Type_string name, vx_core::Type_any value) {
    return valuemap->vx_set(name, value);
  }

  // vx_compare(any, any)
  long vx_compare(vx_core::Type_any val1, vx_core::Type_any val2) {
    long output = 0;
    vx_core::Type_boolean isnumber1 = vx_core::f_is_number(val1);
    vx_core::Type_boolean isnumber2 = vx_core::f_is_number(val2);
    if (isnumber1->vx_boolean() && isnumber2->vx_boolean()) {
      vx_core::Type_number num1 = vx_core::vx_any_from_any(vx_core::t_number, val1);
      vx_core::Type_number num2 = vx_core::vx_any_from_any(vx_core::t_number, val2);
      float float1 = vx_core::vx_float_from_number(num1);
      float float2 = vx_core::vx_float_from_number(num2);
      if (float1 < float2) {
        output = -1;
      } else if (float1 > float2) {
        output = 1;
      }
    } else {
      std::string stringval1 = vx_core::vx_string_from_any(val1);
      std::string stringval2 = vx_core::vx_string_from_any(val2);
      int compare = stringval1.compare(stringval2);
      if (compare > 0) {
        output = 1;
      } else if (compare < 0) {
        output = -1;
      }
    }
    vx_core::vx_release({isnumber1, isnumber2});
    return output;
  }

  // vx_constdefnew(string, string)
  vx_core::Type_constdef vx_constdef_new(std::string pkgname, std::string name) {
    vx_core::Type_constdef output = new vx_core::Class_constdef();
    output->vx_p_pkgname = vx_core::vx_new_string(pkgname);
    output->vx_p_name = vx_core::vx_new_string(name);
    return output;
  }

  // vx_eqeq(any, any)
  bool vx_eqeq(vx_core::Type_any val1, vx_core::Type_any val2) {
    bool output = false;
    if (val1 == val2) {
      output = true;
    } else if (val1->vx_msgblock() != vx_core::e_msgblock) {
    } else if (val2->vx_msgblock() != vx_core::e_msgblock) {
    } else {
      vx_core::Type_any type1 = val1->vx_type();
      vx_core::Type_any type2 = val2->vx_type();
      if (type1 != type2) {
      } else if (type1 == vx_core::t_int) {
        vx_core::Type_int valint1 = vx_core::vx_any_from_any(vx_core::t_int, val1);
        vx_core::Type_int valint2 = vx_core::vx_any_from_any(vx_core::t_int, val2);
        if (valint1->vx_int() == valint2->vx_int()) {
          output = true;
        }
      } else if (type1 == vx_core::t_float) {
        vx_core::Type_float valfloat1 = vx_core::vx_any_from_any(vx_core::t_float, val1);
        vx_core::Type_float valfloat2 = vx_core::vx_any_from_any(vx_core::t_float, val2);
        if (valfloat1->vx_float() == valfloat2->vx_float()) {
          output = true;
        }
      } else if (type1 == vx_core::t_decimal) {
        vx_core::Type_decimal valdecimal1 = vx_core::vx_any_from_any(vx_core::t_decimal, val1);
        vx_core::Type_decimal valdecimal2 = vx_core::vx_any_from_any(vx_core::t_decimal, val2);
        if (valdecimal1->vx_string() == valdecimal2->vx_string()) {
          output = true;
        }
      } else if (type1 == vx_core::t_string) {
        vx_core::Type_string valstring1 = vx_core::vx_any_from_any(vx_core::t_string, val1);
        vx_core::Type_string valstring2 = vx_core::vx_any_from_any(vx_core::t_string, val2);
        if (valstring1->vx_string() == valstring2->vx_string()) {
          output = true;
        }
      }
    }
    return output;
  }

  // vx_float_from_number(number)
  float vx_float_from_number(vx_core::Type_number num) {
    float output = 0;
    vx_core::Type_any type = num->vx_type();
    if (type == vx_core::t_float) {
      vx_core::Type_float floatval = vx_core::vx_any_from_any(vx_core::t_float, num);
      output = floatval->vx_float();
    } else if (type == vx_core::t_int) {
      vx_core::Type_int intval = vx_core::vx_any_from_any(vx_core::t_int, num);
      output = intval->vx_int();
    } else if (type == vx_core::t_decimal) {
      vx_core::Type_decimal decval = vx_core::vx_any_from_any(vx_core::t_decimal, num);
      output = decval->vx_float();
    }
    return output;
  }

  // vx_float_from_string(string)
  float vx_float_from_string(std::string text) {
    float output = std::stof(text);
    return output;
  }

  // vx_funclist_from_listfunc(List<func>)
  vx_core::Type_funclist vx_funclist_from_listfunc(
    std::initializer_list<vx_core::Type_func> listfunc) {
    for (vx_core::Type_func fnc : listfunc) {
      vx_core::vx_reserve(fnc);
    }
    vx_core::Type_funclist output = new vx_core::Class_funclist();
    output->vx_p_list = listfunc;
    return output;
  }

  // vx_global_package_set(string, map<any>, map<any>, map<func>)
  void vx_global_package_set(
    std::string pkgname,
    vx_core::vx_Type_mapany maptype,
    vx_core::vx_Type_mapany mapconst,
    vx_core::vx_Type_mapfunc mapfunc) {
    vx_core::Class_typemap* typemap = new vx_core::Class_typemap;
    typemap->vx_p_map = maptype;
    vx_core::Class_constmap* constmap = new vx_core::Class_constmap;
    constmap->vx_p_map = mapconst;
    vx_core::Class_funcmap* funcmap = new vx_core::Class_funcmap;
    funcmap->vx_p_map = mapfunc;
    vx_core::Class_package* pkg = new vx_core::Class_package;
    vx_core::vx_reserve({constmap, typemap, funcmap, pkg});
    pkg->vx_p_constmap = constmap;
    pkg->vx_p_typemap = typemap;
    pkg->vx_p_funcmap = funcmap;
    vx_core::Class_project* project = dynamic_cast<vx_core::Class_project*>(vx_core::c_global);
    vx_core::Class_packagemap* packagemap = dynamic_cast<vx_core::Class_packagemap*>(project->vx_p_packagemap);
    if (packagemap == NULL) {
      packagemap = new vx_core::Class_packagemap;
      vx_core::vx_reserve(packagemap);
      project->vx_p_packagemap = packagemap;
    }
    std::map<std::string, vx_core::Type_package> mappackage(packagemap->vx_p_map);
    mappackage.insert({pkgname, pkg});
    packagemap->vx_p_map = mappackage;
  }

  // vx_if_thenelselist(type, thenelselist)
  vx_core::Type_any vx_if_thenelselist(
    vx_core::Type_any generic_any_1,
    vx_core::Type_thenelselist thenelselist) {
    vx_core::Type_any output = vx_core::vx_empty(generic_any_1);
    std::vector<vx_core::Type_thenelse> listthenelse = thenelselist->vx_listthenelse();
    vx_core::Func_any_from_func fn_any = vx_core::e_any_from_func;
    for (vx_core::Type_thenelse thenelse : listthenelse) {
      vx_core::Type_string code = thenelse->code();
      std::string scode = code->vx_string();
      if (scode == ":then") {
        vx_core::Func_boolean_from_func fn_cond = thenelse->fn_cond();
        vx_core::Type_boolean cond = fn_cond->vx_boolean_from_func();
        bool iscond = cond->vx_boolean();
        vx_core::vx_release(cond);
        if (iscond) {
          fn_any = thenelse->fn_any();
          break;
        }
      } else if (scode == ":else") {
        fn_any = thenelse->fn_any();
        break;
      }
    }
    if (fn_any == vx_core::e_any_from_func) {
    } else if (fn_any == fn_any->vx_empty()) {
    } else {
      output = fn_any->vx_any_from_func();
    }
    return output;
  }

  // vx_int_from_sizet(size_t)
  long vx_int_from_sizet(
    std::size_t size) {
    long output = 0;
    if (size == std::string::npos) {
      output = -1;
    } else if (size > 100000000) {
      output = 100000000;
    } else {
      output = static_cast<long>(size);
    }
    return output;
  }

  // vx_int_from_string(string)
  int vx_int_from_string(
    std::string text) {
    int output = std::stoi(text);
    return output;
  }

  // vx_is_float(string)
  bool vx_is_float(std::string value) {
    bool output = true;
    bool isfirst = true;
    bool isdecimal = false;
    for (char c : value) {
      if (('0' <= c) && (c <= '9')) {
      } else if ((c == '-') && isfirst) {
      } else if (c == '.') {
        if (isdecimal) {
          output = false;
        } else {
          isdecimal = true;
        }
      } else {
        output = false;
      }
      isfirst = false;
    }
    return output;
  }

  // vx_is_float(any)
  bool vx_is_float(vx_core::Type_any value) {
    bool output = true;
    vx_core::Type_any typ = vx_core::f_type_from_any(value);
    if (typ == vx_core::t_int) {
      output = true;
    } else if (typ == vx_core::t_float) {
      output = true;
    } else if (typ == vx_core::t_decimal) {
      output = true;
    } else if (typ == vx_core::t_string) {
      vx_core::Type_string valuestring = vx_core::vx_any_from_any(vx_core::t_string, value);
      output = vx_core::vx_is_float(valuestring->vx_string());
    }
    return output;
  }

  // vx_is_int(string)
  bool vx_is_int(std::string value) {
    bool output = true;
    if (value == "notanumber") {
      output = true;
    } else if (value == "infinity") {
      output = true;
    } else if (value == "neginfinity") {
      output = true;
    } else {
      bool isfirst = true;
      for (char c : value) {
        if (('0' <= c) && (c <= '9')) {
        } else if ((c == '-') && isfirst) {
        } else {
          output = false;
        }
        isfirst = false;
      }
    }
    return output;
  }

  // vx_is_int(any)
  bool vx_is_int(vx_core::Type_any value) {
    bool output = false;
    if (value == vx_core::c_infinity) {
      output = true;
    } else if (value == vx_core::c_neginfinity) {
      output = true;
    } else if (value == vx_core::c_notanumber) {
      output = true;
    } else {
      vx_core::Type_any type = value->vx_type();
      if (type == vx_core::t_int) {
        output = true;
      } else if (type == vx_core::t_float) {
        vx_core::Type_float valfloat = vx_core::vx_any_from_any(vx_core::t_float, value);
        float floatval = valfloat->vx_float();
        if ((int)floatval == floatval) {
          output = true;
        }
      } else if (type == vx_core::t_decimal) {
        vx_core::Type_decimal valdec = vx_core::vx_any_from_any(vx_core::t_decimal, value);
        std::string strval = valdec->vx_string();
        output = vx_core::vx_is_int(strval);
      } else if (type == vx_core::t_string) {
        vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, value);
        std::string strval = valstr->vx_string();
        output = vx_core::vx_is_int(strval);
      }
    }
    return output;
  }

  // vx_list_from_array(arrayval)
  vx_core::vx_Type_listany vx_list_from_array(vx_core::vx_Type_listarg vals) {
    vx_core::vx_Type_listany output;
    output = vx_core::vx_Type_listany{vals};
    return output;
  }

  // vx_list_from_list_intany_helper(generic_list_1, list-2, any<-int-any)
  vx_core::Type_list vx_list_from_list_intany_helper(vx_core::Type_list generic_list_1, vx_core::Type_list valuelist, vx_core::Func_any_from_int_any fn_any_from_int_any) {
    vx_core::Type_list output = vx_core::vx_empty(generic_list_1);
    std::vector<vx_core::Type_any> listany = valuelist->vx_list();
    long size = vx_core::vx_int_from_sizet(listany.size());
    if (size > 0) {
      std::vector<vx_core::Type_any> listout;
      for (long i = 0; i < size; i++) {
        vx_core::Type_int vali = vx_core::vx_new_int(i+1);
        vx_core::Type_any value = listany[i];
        vx_core::vx_reserve({vali, value});
        vx_core::Type_any outval = fn_any_from_int_any->vx_any_from_int_any(vali, value);
        vx_core::vx_release_one_except({vali, value}, outval);
        listout.push_back(outval);
      }
      output = vx_core::vx_new_list(generic_list_1, listout);
    }
    return output;
  }

  // vx_list_from_map_1(generic_list_1, map, fn-any<-key-value)
  vx_core::Type_any vx_list_from_map_1(vx_core::Type_any generic_list_1, vx_core::Type_map valuemap, vx_core::Func_any_from_key_value fn_any_from_key_value) {
    std::vector<std::string> keys = valuemap->vx_p_keys;
    vx_core::vx_Type_mapany map_value = valuemap->vx_map();
    vx_core::vx_Type_listany list_result;
    for (std::string key : keys) {
      vx_core::Type_any val = map_value[key];
      vx_core::Type_string valkey = vx_core::vx_new_string(key);
      vx_core::vx_reserve(valkey);
      vx_core::Type_any result = fn_any_from_key_value->vx_any_from_key_value(valkey, val);
      vx_core::vx_release_one_except(valkey, result);
      list_result.push_back(result);
    }
    vx_core::Type_any output = generic_list_1->vx_new(list_result);
    vx_core::vx_release_except(valuemap, output);
    return output;
  }

  // vx_list_join_from_list_fn(generic_list_1, list, fn-any<-any)
  vx_core::Type_any vx_list_join_from_list_fn(vx_core::Type_any generic_list_1, vx_core::Type_list values, vx_core::Func_any_from_any fn_any_from_any) {
    vx_core::vx_Type_listany list_value = values->vx_list();
    vx_core::vx_Type_listany list_result;
    for (vx_core::Type_any val : list_value) {
      vx_core::Type_any listoflist = fn_any_from_any->vx_any_from_any(val);
      vx_core::vx_reserve(listoflist);
      vx_core::Type_string extends = vx_core::f_extends_from_any(listoflist);
      std::string sextends = extends->vx_string();
      vx_core::vx_release(extends);
      if (sextends == ":list") {
        vx_core::Type_list vallist = vx_core::vx_any_from_any(vx_core::t_list, listoflist);
        vx_core::vx_Type_listany listval = vallist->vx_list();
        vx_core::vx_reserve(listval);
        for (vx_core::Type_any val : listval) {
          list_result.push_back(val);
        }
      }
      vx_core::vx_release_one(listoflist);
    }
    vx_core::Type_any output = vx_core::vx_new_list(generic_list_1, list_result);
    vx_core::vx_release_one(list_result);
    vx_core::vx_release_except(values, output);
    return output;
  }

  // vx_listany_from_listany_fn(List<any>, (Function (any) : any))
  vx_core::vx_Type_listany vx_listany_from_listany_fn(
    vx_core::vx_Type_listany list_any,
    vx_core::vx_Type_fn_any_from_any fn) {
    vx_core::vx_Type_listany output;
    for (vx_core::Type_any any : list_any) {
      vx_core::Type_any value = fn(any);
      output.push_back(value);
    }
    return output;
  }

  // vx_listasync_from_listany_fn(List<any>, (Function (any) : any))
  vx_core::vx_Type_listasync vx_listasync_from_listany_fn(
    vx_core::vx_Type_listany list_any,
    vx_core::vx_Type_fn_async_from_any fn) {
    vx_core::vx_Type_listasync output;
    for (vx_core::Type_any any : list_any) {
      vx_core::vx_Type_async async = fn(any);
      output.push_back(async);
    }
    return output;
  }

  // vx_liststring_from_arraystring(long, array<string>)
  std::vector<std::string> vx_liststring_from_arraystring(long ilen, char* arraystring[]) {
    std::vector<std::string> output;
    output.reserve(ilen);
    if (ilen > 0) {
      output.assign(arraystring, arraystring + ilen);
    }
    return output;
  }

  // vx_log()
  void vx_log() {
    std::cout << vx_core::refcount << std::endl;
  }

  // vx_log(int)
  void vx_log(long ival) {
    std::cout << ival << std::endl;
  }

  // vx_log(text)
  void vx_log(std::string sval) {
    std::cout << sval << std::endl;
  }

  // vx_log(any)
  void vx_log(vx_core::Type_any val) {
    if (!val) {
      vx_core::vx_log("null");
    } else {
      std::string sval = vx_core::vx_string_from_any(val);
      vx_core::vx_log(sval);
    }
  }

  // vx_log(async)
  void vx_log(vx_core::vx_Type_async async) {
    if (!async) {
      vx_core::vx_log("null");
    } else {
      std::string sval = vx_core::vx_string_from_async(async);
      vx_core::vx_log(sval);
    }
  }

  // vx_log(list<any>)
  void vx_log(
    vx_core::vx_Type_listany listany) {
    for (vx_core::Type_any any : listany) {
      vx_core::vx_log(any);
    }
  }

  // vx_log(string, string)
  void vx_log(
    std::string code,
    std::string text) {
    vx_core::vx_log(code + ": " + vx_core::vx_string_from_int(vx_core::refcount) + "\n" + text);
  }

  // vx_log(string, any)
  void vx_log(
    std::string code,
    vx_core::Type_any val) {
    if (!val) {
      vx_core::vx_log(code, "null");
    } else {
      std::string sval = vx_core::vx_string_from_any_refcount(val);
      vx_core::vx_log(code, sval);
    }
  }

  // vx_log(string, async)
  void vx_log(
    std::string code,
    vx_core::vx_Type_async async) {
    if (!async) {
      vx_core::vx_log(code, "null");
    } else {
      std::string sval = vx_core::vx_string_from_async_refcount(async);
      vx_core::vx_log(code, sval);
    }
  }

  // vx_map_from_list(listany, any<-any)
  vx_core::vx_Type_mapany vx_map_from_list(
    vx_core::vx_Type_listany listany,
    vx_core::Func_any_from_any fn_any_from_any) {
    vx_core::vx_Type_mapany output;
    for (vx_core::Type_any item : listany) {
      vx_core::Type_any keyany = fn_any_from_any->vx_any_from_any(item);
      std::string key = "";
      if (keyany->vx_type() == vx_core::t_string) {
        vx_core::Type_string keystring = vx_core::vx_any_from_any(vx_core::t_string, keyany);
        key = keystring->vx_string();
      } else {
        key = vx_core::vx_string_from_any(item);
      }
      vx_core::vx_release(keyany);
      if (key != "") {
        output.insert({key, item});
      }
    }
    return output;
  }

  // vx_map_from_map_fn(generic_map_1, map, fn-any<-key-value)
  vx_core::Type_any vx_map_from_map_fn(
    vx_core::Type_map generic_map_1,
    vx_core::Type_map valuemap,
    vx_core::Func_any_from_key_value fn_any_from_key_value) {
    vx_core::Type_any output = vx_core::f_empty(generic_map_1);
    vx_core::vx_Type_mapany mapvalue = valuemap->vx_map();
    vx_core::vx_Type_mapany mapnew;
    if (mapvalue.size() > 0) {
      vx_core::Type_typedef typdef = vx_core::f_typedef_from_any(
        generic_map_1
      );
      vx_core::Type_typelist allowtypes = vx_core::f_allowtypes_from_typedef(
        typdef
      );
      std::vector<vx_core::Type_any> lallowtypes = allowtypes->vx_list();
      vx_core::vx_release(allowtypes);
      for (auto const& [key, value] : mapvalue) {
        vx_core::Type_string valkey = vx_core::vx_new_string(key);
        vx_core::vx_reserve(valkey);
        vx_core::Type_any chgvalue = fn_any_from_key_value->vx_any_from_key_value(
          valkey, value
        );
        vx_core::vx_release_one_except(valkey, value);
        vx_core::Type_any chgtype = chgvalue->vx_type();
        if (vx_core::vx_boolean_from_list_find(lallowtypes, chgtype)) {
          mapnew[key] = chgvalue;
        } else {
          vx_core::vx_release({chgvalue});
        }
      }
      output = generic_map_1->vx_new_from_map(
        mapnew
      );
    }
    return output;
  }

  // vx_memory_leak_test()
  bool vx_memory_leak_test() {
    bool output = true;
    if (vx_core::refcount > 0) {
      vx_core::vx_log("Error: Memory Leak:" + vx_core::vx_string_from_int(vx_core::refcount));
      output = false;
    }
    return output;
  }

  // vx_memory_leak_test(string, int)
  bool vx_memory_leak_test(
    std::string id,
    long initialcount) {
    bool output = true;
    if (vx_core::refcount - initialcount != 0) {
      vx_core::vx_log("Error: " + id + ", Memory Leak:" + vx_core::vx_string_from_int(vx_core::refcount));
      output = false;
    }
    return output;
  }

  // vx_memory_leak_test(string, int, int)
  bool vx_memory_leak_test(
    std::string id,
    long initialcount,
    long expectedcount) {
    bool output = true;
    long actualcount = vx_core::refcount - initialcount;
    if (actualcount != expectedcount) {
      vx_core::vx_log("Error: " + id + ", Memory Leak, Expected:" + vx_core::vx_string_from_int(expectedcount) + ", Actual:" + vx_core::vx_string_from_int(actualcount));
      output = false;
    }
    return output;
  }

  // vx_msg_from_errortext(string)
  vx_core::Type_msg vx_msg_from_errortext(
    const std::string errortext) {
    vx_core::Type_msg output = new vx_core::Class_msg();
    vx_core::Type_string string_error = vx_core::vx_new_string(errortext);
    vx_core::vx_reserve(string_error);
    output->vx_p_text = string_error;
    output->vx_p_severity = vx_core::c_msg_severe;
    return output;
  }

  // vx_msg_from_exception(string, exception)
  vx_core::Type_msg vx_msg_from_exception(
    const std::string text,
    std::exception err) {
    vx_core::Type_msg output = new vx_core::Class_msg();
    output->vx_p_text = vx_core::vx_new_string(text);
    output->vx_p_severity = vx_core::c_msg_severe;
    output->err = err;
    return output;
  }

  // vx_msgblock_from_copy_listval(msgblock, List<any>)
  vx_core::Type_msgblock vx_msgblock_from_copy_listval(
    vx_core::Type_msgblock msgblock,
    vx_core::vx_Type_listany vals) {
    vx_core::Type_msgblock output = vx_core::e_msgblock;
    std::vector<vx_core::Type_msgblock> listmsgblock;
    if (msgblock) {
      vx_core::Type_msgblock origmsgblock = msgblock->vx_msgblock();
      if (origmsgblock) {
        std::vector<vx_core::Type_msgblock> origlistmsgblock = origmsgblock->msgblocks()->vx_p_list;
        listmsgblock.insert(listmsgblock.end(), origlistmsgblock.begin(), origlistmsgblock.end());
      }
    }
    for (vx_core::Type_any subval : vals) {
      vx_core::Type_msgblock submsgblock = subval->vx_p_msgblock;
      if (submsgblock) {
        listmsgblock.push_back(submsgblock);
      }
    }
    vx_core::Type_msgblocklist msgblocks;
    if (listmsgblock.size() > 0) {
      for (vx_core::Type_any any : listmsgblock) {
        vx_core::vx_reserve(any);
      }
      msgblocks = new vx_core::Class_msgblocklist();
      msgblocks->vx_p_list = listmsgblock;
      output = new vx_core::Class_msgblock();
      output->vx_p_msgblocks = msgblocks;
    } else if (msgblock) {
      vx_core::vx_reserve(msgblock);
      output = msgblock;
    }
    return output;
  }

  // vx_new_anylist(any...)
  vx_core::Type_anylist vx_new_anylist(
    vx_core::vx_Type_listany listany) {
    return vx_core::vx_new(vx_core::t_anylist, listany);
  }

  // vx_new_arg(string, type, bool, bool)
  vx_core::Type_arg vx_new_arg(
    std::string name,
    vx_core::Type_any type) {
    vx_core::Type_string namestring = vx_core::vx_new_string(name);
    vx_core::vx_reserve({namestring});
    vx_core::Type_arg output = new vx_core::Class_arg();
    output->vx_p_name = namestring;
    return output;
  }

  // vx_new_boolean(boolean)
  vx_core::Type_boolean vx_new_boolean(bool isval) {
    vx_core::Type_boolean output = vx_core::c_false;
    if (isval) {
      output = vx_core::c_true;
    }
    return output;
  }

  // vx_new_decimal_from_float(float)
  vx_core::Type_decimal vx_new_decimal_from_float(float fval) {
    vx_core::Type_decimal output = vx_core::e_decimal;
    if (fval != 0) {
      output = new vx_core::Class_decimal();
      output->vx_p_decimal = vx_core::vx_string_from_float(fval);
    }
    return output;
  }

  // vx_new_decimal_from_string(string)
  vx_core::Type_decimal vx_new_decimal_from_string(
    std::string sval) {
    vx_core::Type_decimal output = vx_core::e_decimal;
    if (sval != "") {
      output = new vx_core::Class_decimal();
      output->vx_p_decimal = sval;
    }
    return output;
  }

  // vx_new_float(float)
  vx_core::Type_float vx_new_float(float fval) {
    vx_core::Type_float output = vx_core::e_float;
    if (fval != 0) {
      output = new vx_core::Class_float();
      output->vx_p_float = fval;
    }
    return output;
  }

  // vx_new_int(long)
  vx_core::Type_int vx_new_int(long ival) {
    vx_core::Type_int output = vx_core::e_int;
    if (ival != 0) {
      output = new vx_core::Class_int();
      output->vx_p_int = ival;
    }
    return output;
  }

  // vx_new_string(string)
  vx_core::Type_string vx_new_string(std::string text) {
    vx_core::Type_string output;
    if (text == "") {
      output = vx_core::e_string;
    } else {
      output = new vx_core::Class_string();
      output->vx_p_string = text;
    }
    return output;
  }

  // vx_ref(any)
  long vx_ref(vx_core::Type_any any) {
    long output = 0;
    if (any) {
      output = any->vx_p_iref;
    }
    return output;
  }

  // vx_ref_minus(any)
  long vx_ref_minus(vx_core::Type_any any) {
    long output = -1;
    if (any) {
      output = any->vx_p_iref;
      if (output > 0) {
        output -= 1;
        any->vx_p_iref = output;
      }
    }
    return output;
  }

  // vx_ref_plus(any)
  long vx_ref_plus(vx_core::Type_any any) {
    long output = -1;
    if (any) {
      output = any->vx_p_iref;
      if (output >= 0) {
        output += 1;
        any->vx_p_iref = output;
      }
    }
    return output;
  }

  // vx_release(any)
  void vx_release(vx_core::Type_any any) {
    if (!any) {
    } else if (any->vx_p_iref == 0) {
      delete any;
    }
  }

  // vx_release(any...)
  void vx_release(vx_core::vx_Type_listany listany) {
    for (vx_core::Type_any any : listany) {
      vx_core::vx_release(any);
    }
  }

  // vx_release_async(async)
  void vx_release_async(vx_core::vx_Type_async async) {
    if (!async) {
    } else if (async->vx_p_iref == 0) {
      delete async;
    }
  }

  // vx_release_except(any, except)
  void vx_release_except(
    vx_core::Type_any any,
    vx_core::Type_any except) {
    vx_core::vx_ref_plus(except);
    vx_core::vx_release(any);
    vx_core::vx_ref_minus(except);
  }

  // vx_release_except(any..., except)
  void vx_release_except(
    vx_core::vx_Type_listany listany,
    vx_core::Type_any except) {
    vx_core::vx_ref_plus(except);
    vx_core::vx_release(listany);
    vx_core::vx_ref_minus(except);
  }

  // vx_release_except_async(async, except)
  void vx_release_except_async(
    vx_core::vx_Type_async async,
    vx_core::Type_any except) {
    vx_core::vx_ref_plus(except);
    vx_core::vx_release_async(async);
    vx_core::vx_ref_minus(except);
  }

  // vx_release_one(any)
  void vx_release_one(
    vx_core::Type_any any) {
    if (any) {
      long iref = vx_core::vx_ref_minus(any);
      if (iref == 0) {
        delete any;
      }
    }
  }

  // vx_release_one(any...)
  void vx_release_one(
    vx_core::vx_Type_listany listany) {
    for (vx_core::Type_any any : listany) {
      vx_core::vx_release_one(any);
    }
  }

  // vx_release_one_async(async)
  void vx_release_one_async(
    vx_core::vx_Type_async async) {
    if (async) {
      long iref = async->vx_p_iref;
      if (iref > 0) {
        iref -= 1;
        if (iref == 0) {
          delete async;
        } else {
          async->vx_p_iref = iref;
        }
      }
    }
  }

  // vx_release_one_async(async...)
  void vx_release_one_async(
    vx_core::vx_Type_listasync listasync) {
    for (vx_core::vx_Type_async async : listasync) {
      vx_core::vx_release_one_async(async);
    }
  }

  // vx_release_one_except(any, except)
  void vx_release_one_except(
    vx_core::Type_any any,
    vx_core::Type_any except) {
    vx_core::vx_ref_plus(except);
    vx_core::vx_release_one(any);
    vx_core::vx_ref_minus(except);
  }

  // vx_release_one_except(any..., except)
  void vx_release_one_except(
    vx_core::vx_Type_listany listany,
    vx_core::Type_any except) {
    vx_core::vx_ref_plus(except);
    vx_core::vx_release_one(listany);
    vx_core::vx_ref_minus(except);
  }

  // vx_release_one_except_async(async, except)
  void vx_release_one_except_async(
    vx_core::vx_Type_async async,
    vx_core::Type_any except) {
    vx_core::vx_ref_plus(except);
    vx_core::vx_release_one_async(async);
    vx_core::vx_ref_minus(except);
  }

  // vx_release_one_except_async(async..., except)
  void vx_release_one_except_async(
    vx_core::vx_Type_listasync listasync,
    vx_core::Type_any except) {
    vx_core::vx_ref_plus(except);
    vx_core::vx_release_one_async(listasync);
    vx_core::vx_ref_minus(except);
  }

  // vx_reserve(any)
  void vx_reserve(
    vx_core::Type_any any) {
    if (any) {
      vx_core::vx_ref_plus(any);
    }
  }

  // vx_reserve(any...)
  void vx_reserve(
    vx_core::vx_Type_listany listany) {
    for (vx_core::Type_any any : listany) {
      vx_core::vx_ref_plus(any);
    }
  }

  // vx_reserve_async(async)
  void vx_reserve_async(
    vx_core::vx_Type_async async) {
    if (async) {
      long iref = async->vx_p_iref;
      if (iref >= 0) {
        iref += 1;
        async->vx_p_iref = iref;
      }
    }
  }

  // vx_reserve_async(listasync)
  void vx_reserve_async(
    vx_core::vx_Type_listasync listasync) {
    for (vx_core::vx_Type_async async : listasync) {
      vx_core::vx_reserve_async(async);
    }
  }

  // vx_reserve_context(context)
  void vx_reserve_context(
    vx_core::Type_context context) {
    context->vx_p_iref = -2;
    vx_core::refcount = 0;
  }

  // vx_reserve_empty(any)
  void vx_reserve_empty(
    vx_core::Type_any any) {
    if (any->vx_p_iref == 0) {
      any->vx_p_iref = -2;
      vx_core::refcount -= 1;
    }
  }

  // vx_reserve_type(any)
  void vx_reserve_type(
    vx_core::Type_any any) {
    if (any->vx_p_iref == 0) {
      any->vx_p_iref = -1;
      vx_core::refcount -= 1;
    }
  }

  // vx_string_from_any(val)
  std::string vx_string_from_any(
    vx_core::Type_any value) {
    return vx_core::vx_string_from_any_indent(value, 0, true, false);
  }

  // vx_string_from_any_indent(val, indent, linefeed, refcount)
  std::string vx_string_from_any_indent(
    vx_core::Type_any value,
    long indent,
    bool linefeed,
    bool refcount) {
    std::string output = "";
    std::string text = "";
    if (indent > 50) {
      text = "Error: Max Depth Exceeded";
    } else if (!value) {
      text = "null";
    } else {
      std::string indenttext = vx_core::vx_string_from_string_repeat(" ", indent);
      vx_core::Type_any type = value->vx_type();
      vx_core::Type_typedef typdef = type->vx_typedef();
      vx_core::Type_constdef constdef = value->vx_constdef();
      std::string typedefname = typdef->name()->vx_string();
      std::string pkgname = typdef->pkgname()->vx_string();
      if (pkgname != "vx/core") {
        typedefname = pkgname + "/" + typedefname;
      }
      if (constdef != nullptr) {
        text = constdef->name()->vx_string();
        pkgname = constdef->pkgname()->vx_string();
        if (pkgname != "vx/core") {
         text = pkgname + "/" + text;
        }
      } else if (value == type) {
        text = typedefname;
      } else if (type == vx_core::t_boolean) {
        vx_core::Type_boolean valbool = vx_core::vx_any_from_any(
          vx_core::t_boolean, value);
        if (valbool->vx_boolean()) {
          text = "true";
        } else {
          text = "false";
        }
      } else if (type == vx_core::t_decimal) {
        vx_core::Type_decimal valdec = vx_core::vx_any_from_any(
          vx_core::t_decimal, value);
        text = valdec->vx_string();
        if (refcount || valdec->vx_p_msgblock) {
          text = "(decimal \"" + text + "\"";
          if (refcount) {
            text += "\n" + indenttext + " :refcount " + vx_core::vx_string_from_int(
              vx_core::vx_ref(value));
          }
          if (valdec->vx_p_msgblock) {
            std::string msgtext = vx_core::vx_string_from_any_indent(
              valdec->vx_msgblock(), indent + 1, linefeed, refcount);
            text += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
          }
          text += ")";
        }
      } else if (type == vx_core::t_float) {
        vx_core::Type_float valfloat = vx_core::vx_any_from_any(
          vx_core::t_float, value);
        text = vx_core::vx_string_from_float(
          valfloat->vx_float());
        if (vx_core::vx_boolean_from_string_ends(text, ".0")) {
          text = vx_core::vx_string_from_string_start_end(
            text, 0, text.length() - 2);
        }
        if (refcount || valfloat->vx_p_msgblock) {
          text = "(float \"" + text + "\"";
          if (refcount) {
            text += "\n" + indenttext + " :refcount " + vx_core::vx_string_from_int(
              vx_core::vx_ref(value));
          }
          if (valfloat->vx_p_msgblock) {
            std::string msgtext = vx_core::vx_string_from_any_indent(
              valfloat->vx_msgblock(), indent + 1, linefeed, refcount);
            text += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
          }
          text += ")";
        }
      } else if (type == vx_core::t_int) {
        if (value == vx_core::c_notanumber) {
          text = "notanumber";
        } else if (value == vx_core::c_infinity) {
          text = "infinity";
        } else if (value == vx_core::c_neginfinity) {
          text = "neginfinity";
        } else {
          vx_core::Type_int valint = vx_core::vx_any_from_any(
            vx_core::t_int, value);
          text = std::to_string(valint->vx_int());
          if (refcount || valint->vx_p_msgblock) {
            text = "(int \"" + text + "\"";
            if (refcount) {
              text += "\n" + indenttext + " :refcount " + vx_core::vx_string_from_int(
                vx_core::vx_ref(value));
            }
            if (valint->vx_p_msgblock) {
              std::string msgtext = vx_core::vx_string_from_any_indent(
                valint->vx_msgblock(), indent + 1, linefeed, refcount);
              text += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
            }
            text += ")";
          }
        }
      } else if (type == vx_core::t_string) {
        vx_core::Type_string valstring = vx_core::vx_any_from_any(
          vx_core::t_string, value);
        std::string sval = valstring->vx_string();
        sval = vx_core::vx_string_from_string_find_replace(
          sval, "\"", "\\\"");
        if (refcount || valstring->vx_p_msgblock) {
          text = "(string \"" + sval + "\"";
          if (refcount) {
            text += "\n" + indenttext + " :refcount " + vx_core::vx_string_from_int(
              vx_core::vx_ref(value));
          }
          if (valstring->vx_p_msgblock) {
            std::string msgtext = vx_core::vx_string_from_any_indent(
              valstring->vx_msgblock(), indent + 1, linefeed, refcount);
            text += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
          }
          text += ")";
        } else {
          text = "\"" + sval + "\"";
        }
      } else if (value == type->vx_empty()) {
        text = "(" + typedefname + ")";
      } else {
        std::string extend = typdef->extend()->vx_string();
        if (extend == ":list") {
          vx_core::Type_list vallist = vx_core::vx_any_from_any(
            vx_core::t_list, value);
          long indentint = indent;
          indentint += 1;
          vx_core::vx_Type_listany listval = vallist->vx_list();
          for (vx_core::Type_any valsub : listval) {
            std::string ssub = vx_core::vx_string_from_any_indent(
              valsub, indentint, linefeed, refcount);
            text += "\n " + indenttext + ssub;
          }
          if (vallist->vx_p_msgblock) {
            std::string msgtext = vx_core::vx_string_from_any_indent(
              vallist->vx_msgblock(), indentint, linefeed, refcount);
            text += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
          }
          if (refcount) {
            text += "\n" + indenttext + " :refcount " + vx_core::vx_string_from_int(
              vallist->vx_p_iref);
          }
          text = "(" + typedefname + text + ")";
        } else if (extend == ":map") {
          vx_core::Type_map valmap = vx_core::vx_any_from_any(
            vx_core::t_map, value);
          long indentint = indent;
          indentint += 2;
          vx_core::vx_Type_mapany mapval = valmap->vx_map();
          for (auto const& [ckey, valsub] : mapval) {
            std::string key = ckey;
            if (!vx_boolean_from_string_starts(key, ":")) {
              key = ":" + key;
            }
            std::string strval = vx_core::vx_string_from_any_indent(
              valsub, indentint, linefeed, refcount);
            if (vx_boolean_from_string_find(strval, "\n")) {
              strval = "\n  " + indenttext + strval;
            } else {
              strval = " " + strval;
            }
            text += "\n" + indenttext + " " + key + strval;
          }
          if (valmap->vx_p_msgblock) {
            std::string msgtext = vx_core::vx_string_from_any_indent(
              valmap->vx_msgblock(), indentint, linefeed, refcount);
            text += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
          }
          if (refcount) {
            text += "\n" + indenttext + " :refcount " + vx_core::vx_string_from_int(
              valmap->vx_p_iref);
          }
          text = "(" + typedefname + text + ")";
        } else if (extend == ":struct") {
          vx_core::Type_struct valstruct = vx_core::vx_any_from_any(
            vx_core::t_struct, value);
          vx_core::vx_Type_mapany mapval = valstruct->vx_map();
          vx_core::Type_argmap properties = typdef->properties();
          std::vector<std::string> keys = properties->vx_p_keys;
          long indentint = indent;
          indentint += 2;
          for (std::string key : keys) {
            vx_core::Type_any valsub = mapval[key];
            if (!valsub) {
            } else if (valsub != valsub->vx_empty()) {
              std::string strval = vx_core::vx_string_from_any_indent(
                valsub, indentint, linefeed, refcount);
              if (vx_boolean_from_string_find(strval, "\n")) {
                strval = "\n  " + indenttext + strval;
              } else {
                strval = " " + strval;
              }
              text += "\n" + indenttext + " " + key + strval;
            }
          }
          if (valstruct->vx_p_msgblock) {
            std::string msgtext = vx_core::vx_string_from_any_indent(
              valstruct->vx_msgblock(), indentint, linefeed, refcount);
            text += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
          }
          if (refcount) {
            text += "\n" + indenttext + " :refcount " + vx_core::vx_string_from_int(
              valstruct->vx_p_iref);
          }
          text = "(" + typedefname + text + ")";
        } else if (extend == ":func") {
          vx_core::Type_func valfunc = vx_core::vx_any_from_any(
            vx_core::t_func, value);
          text = typedefname;
          if (valfunc->vx_p_msgblock) {
            text = vx_core::vx_string_from_any_indent(
              valfunc->vx_msgblock(), indent, linefeed, refcount);
            text += "\n" + indenttext + " :msgblock\n  " + indenttext + text;
          }
          if (refcount) {
            text += "\n" + indenttext + " :refcount " + vx_core::vx_string_from_int(
              valfunc->vx_p_iref);
          }
          text = "(" + text + ")";
        }
      }
      vx_core::vx_release(typdef);
    }
    output = text;
    return output;
  }

  // vx_string_from_any_refcount(val)
  std::string vx_string_from_any_refcount(
    vx_core::Type_any value) {
    return vx_core::vx_string_from_any_indent(
      value, 0, true, true);
  }

  // vx_string_from_async(async)
  std::string vx_string_from_async(
    vx_core::vx_Type_async async) {
    return vx_core::vx_string_from_async_indent(
      async, 0, true, false);
  }

  // vx_string_from_async_indent(async, indent, linefeed, refcount)
  std::string vx_string_from_async_indent(
    vx_core::vx_Type_async async,
    long indent,
    bool linefeed,
    bool refcount) {
    std::string output = "";
    if (indent > 50) {
      output = "Error: Max Depth Exceeded";
    } else if (!async) {
      output = "null";
    } else {
      std::string indenttext = vx_core::vx_string_from_string_repeat(
        " ", indent);
      output = indenttext + "(async";
      vx_core::Type_any type = async->type;
      if (type) {
        vx_core::Type_typedef typdef = type->vx_typedef();
        std::string typedefname = typdef->name()->vx_string();
        std::string pkgname = typdef->pkgname()->vx_string();
        std::string extend = typdef->extend()->vx_string();
        vx_core::vx_release(typdef);
        if (pkgname != "vx/core") {
          typedefname = pkgname + "/" + typedefname;
        }
        output += "\n " + indenttext + ":type " + typedefname;
      }
      vx_core::Type_any val = async->value;
      if (val) {
        std::string text = vx_core::vx_string_from_any_indent(
          val, indent + 1, linefeed, refcount);
        output += "\n " + indenttext + ":value " + text;
      }
      vx_core::vx_Type_listasync listasync = async->listasync;
      if (listasync.size() > 0) {
        std::string text = "";
        for (vx_core::vx_Type_async async_sub : listasync) {
          text += "\n" + vx_core::vx_string_from_async_indent(
            async_sub, indent + 2, linefeed, refcount);
        }
        output += "\n " + indenttext + ":listasync (" + text + ")";
      }
      vx_core::vx_Type_future future = async->future;
      if (future) {
        output += "\n " + indenttext + ":future future";
      }
      vx_core::vx_Type_listany lambdavars = async->lambdavars;
      if (lambdavars.size() > 0) {
        std::string text = "";
        for (vx_core::Type_any valsub : lambdavars) {
          std::string ssub = vx_core::vx_string_from_any_indent(
            valsub, indent + 2, linefeed, refcount);
          text += "\n  " + indenttext + ssub;
        }
        output += "\n " + indenttext + ":lambdavars (" + text + ")";
      }
      vx_core::vx_Type_fn_any_from_any fn = async->fn;
      if (fn) {
        output += "\n " + indenttext + ":fn fn";
      }
      vx_core::vx_Type_async asyncparent = async->async_parent;
      if (asyncparent) {
        std::string text = vx_core::vx_string_from_async_indent(
          asyncparent, indent + 2, linefeed, refcount);
        output += "\n " + indenttext + ":async_parent\n" + text;
      }
      if (refcount) {
        output += "\n " + indenttext + ":refcount " + vx_core::vx_string_from_int(
          async->vx_p_iref);
      }
      output += ")";
    }
    return output;
  }

  // vx_string_from_async_refcount(async)
  std::string vx_string_from_async_refcount(
    vx_core::vx_Type_async async) {
    return vx_core::vx_string_from_async_indent(
      async, 0, true, true);
  }

  // vx_string_from_int(long)
  std::string vx_string_from_int(long value) {
    return std::to_string(value);
  }

  // vx_string_from_float(float)
  std::string vx_string_from_float(float value) {
    std::stringstream sstream;
    sstream << value;
    std::string output = sstream.str();
    return output;
  }

  // vx_string_from_liststring_pos(list<string>, long)
  std::string vx_string_from_liststring_pos(
    std::vector<std::string> liststring,
    long pos) {
    std::string output = "";
    if (pos < vx_core::vx_int_from_sizet(liststring.size())) {
      output = liststring[pos];
    }
    return output;
  }

  // vx_string_from_string_find_replace(string, string, string)
  std::string vx_string_from_string_find_replace(
    std::string text,
    std::string find,
    std::string replace) {
    std::string output = text;
    if (!find.empty()) {
      size_t pos = output.find(find);
      while (pos != std::string::npos) {
        output.replace(pos, find.size(), replace);
        pos = output.find(find, pos + replace.size());
      }
    }
    return output;
  }

  // vx_string_from_string_find_replace(string, string, string)
  vx_core::Type_string vx_string_from_string_find_replace(
    vx_core::Type_string text,
    vx_core::Type_string find,
    vx_core::Type_string replace) {
    std::string stext = vx_core::vx_string_from_string_find_replace(
      text->vx_string(), find->vx_string(), replace->vx_string());
    vx_core::Type_string output = vx_core::vx_new_string(stext);
    return output;
  }

  // vx_string_from_string_find_replacefirst(string, string, string)
  std::string vx_string_from_string_find_replacefirst(
    std::string text,
    std::string find,
    std::string replacefirst) {
    std::string output = text;
    size_t start_pos = output.find(find);
    if (start_pos != std::string::npos) {
      output.replace(start_pos, find.length(), replacefirst);
    }
    return output;
  }

  // vx_string_from_string_repeat(string, int)
  std::string vx_string_from_string_repeat(
    std::string text,
    long repeat) {
    std::string output = "";
    for (int i = 0; i < repeat; i++) {
      output += text;
    }
    return output;
  }

  // vx_string_from_string_start(string, int)
  std::string vx_string_from_string_start(
    std::string text,
    long start) {
    return vx_core::vx_string_from_string_start_end(
      text, start, text.length());
  }

  // vx_string_from_string_start_end(string, int, int)
  std::string vx_string_from_string_start_end(
    std::string text,
    long start,
    long end) {
    std::string output = "";
    long maxlen = text.length();
    if (end < 0) {
      end += maxlen;
    }
    if (start < 1) {
    } else if (start > end) {
    } else if (start > maxlen) {
    } else {
      if (end >= maxlen) {
        end = maxlen;
      }
      long len = end - start + 1;
      output = text.substr(start - 1, len);
    }
    return output;
  }

  // vx_switch(type, val, thenelselist)
  vx_core::Type_any vx_switch(
    vx_core::Type_any generic_any_1,
    vx_core::Type_any val,
    vx_core::Type_thenelselist thenelselist) {
    vx_core::Type_any output = vx_core::vx_empty(generic_any_1);
    vx_core::Func_any_from_func fn_any = NULL;
    std::vector<vx_core::Type_thenelse> listthenelse = thenelselist->vx_listthenelse();
    for (vx_core::Type_thenelse thenelse : listthenelse) {
      vx_core::Type_string code = thenelse->code();
      std::string scode = code->vx_string();
      if (scode == ":case") {
        vx_core::Type_any value = thenelse->value();
        vx_core::Type_boolean iseq = vx_core::f_eq(val, value);
        if (iseq->vx_boolean()) {
          fn_any = thenelse->fn_any();
        }
      } else if (scode == ":casemany") {
        vx_core::Type_list values = thenelse->values();
        vx_core::Type_boolean iscontain = vx_core::f_contains_1(values, val);
        if (iscontain->vx_boolean()) {
          fn_any = thenelse->fn_any();
        }
      } else if (scode == ":else") {
        fn_any = thenelse->fn_any();
      }
      if (fn_any) {
        break;
      }
    }
    if (fn_any) {
      output = fn_any->vx_any_from_func();
    }
    return output;
  }

  // vx_typelist_from_listany(list<any>)
  vx_core::Type_typelist vx_typelist_from_listany(
    vx_core::vx_Type_listany listany) {
    vx_core::Type_typelist output = new vx_core::Class_typelist();
    output->vx_p_list = listany;
    vx_core::vx_reserve(listany);
    return output;
  }

  //class Abstract_replfunc {
    vx_core::Type_any Abstract_replfunc::vx_repl(
      vx_core::Type_anylist arglist) {
      return vx_core::e_any;
    }
  //}

  //class Abstract_replfunc_async {
    vx_core::vx_Type_async Abstract_replfunc_async::vx_repl(
      vx_core::Type_anylist arglist) {
      return vx_core::vx_async_new_from_value(vx_core::e_any);
    }
  //}

  //class Class_boolean {

    bool Class_boolean::vx_boolean() const {
      return this->vx_p_boolean;
    }

  //}

  //class Class_decimal {
    float Class_decimal::vx_float() const {
      return vx_core::vx_float_from_string(vx_p_decimal);
    }

    std::string Class_decimal::vx_string() const {
      return vx_p_decimal;
    }
  //}

  //class Class_float {
    float Class_float::vx_float() const {
      return vx_p_float;
    }
  //}

  //class Class_funcdef {
    vx_core::Type_funcdef Class_funcdef::vx_funcdef_new(
      std::string pkgname,
      std::string name,
      long idx,
      bool async,
      vx_core::Type_any typ
    ) {
      vx_core::Type_funcdef output = new vx_core::Class_funcdef();
      output->vx_p_pkgname = vx_core::vx_new_string(pkgname);
      output->vx_p_name = vx_core::vx_new_string(name);
      output->vx_p_idx = vx_core::vx_new_int(idx);
      output->vx_p_async = vx_core::vx_new_boolean(async);
      output->vx_p_type = typ;
      return output;
    }
  //}

  //class Class_int {
    long Class_int::vx_int() const {
      return this->vx_p_int;
    }
  //}

  //class Class_string {
    std::string Class_string::vx_string() const {
      return this->vx_p_string;
    }
  //}

  //class Class_typedef {
    vx_core::Type_typedef Class_typedef::vx_typedef_new(
      std::string spkgname,
      std::string sname,
      std::string sextend,
      vx_core::Type_typelist traits,
      vx_core::Type_typelist allowtypes,
      vx_core::Type_typelist disallowtypes,
      vx_core::Type_funclist allowfuncs,
      vx_core::Type_funclist disallowfuncs,
      vx_core::Type_anylist allowvalues,
      vx_core::Type_anylist disallowvalues,
      vx_core::Type_argmap properties) {
      vx_core::Type_typedef output = new vx_core::Class_typedef();
      vx_core::Type_string pkgname = vx_core::vx_new_string(spkgname); 
      vx_core::Type_string name = vx_core::vx_new_string(sname); 
      vx_core::Type_string extend = vx_core::vx_new_string(sextend); 
      output->vx_p_pkgname = pkgname;
      output->vx_p_name = name;
      output->vx_p_extend = extend;
      output->vx_p_traits = traits;
      output->vx_p_allowtypes = allowtypes;
      output->vx_p_disallowtypes = disallowtypes;
      output->vx_p_allowfuncs = disallowfuncs;
      output->vx_p_disallowfuncs = disallowfuncs;
      output->vx_p_allowvalues = disallowvalues;
      output->vx_p_disallowvalues = disallowvalues;
      output->vx_p_properties = properties;
      vx_core::vx_reserve({
        pkgname,
        name,
        extend,
        traits,
        allowtypes,
        disallowtypes,
        disallowfuncs,
        disallowfuncs,
        disallowvalues,
        disallowvalues,
        properties
      });
      return output;
    }

  //}


  // (type any)
  // class Class_any {
    Abstract_any::~Abstract_any() {}

    Class_any::Class_any() : Abstract_any::Abstract_any() {
      vx_core::refcount += 1;
    }

    Class_any::~Class_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_any::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_any, vals);
    }

    vx_core::Type_any Class_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_any output = vx_core::e_any;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        }
      }
      output = new vx_core::Class_any();
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_any::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_any::vx_empty() const {return vx_core::e_any;}
    vx_core::Type_any Class_any::vx_type() const {return vx_core::t_any;}

    vx_core::Type_typedef Class_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any", // name
        "", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type list)
  // class Class_list {
    Abstract_list::~Abstract_list() {}

    Class_list::Class_list() : Abstract_list::Abstract_list() {
      vx_core::refcount += 1;
    }

    Class_list::~Class_list() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_list::vx_list() const {
      return this->vx_p_list;
    }

    // vx_get_any(index)
    vx_core::Type_any Class_list::vx_get_any(vx_core::Type_int index) const {
      vx_core::Type_any output = vx_core::e_any;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_any> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_list::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_list output = vx_core::e_list;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_any> list;
      for (auto const& valsub : listval) {
        list.push_back(valsub);
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_list();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_list::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_list, vals);
    }

    vx_core::Type_any Class_list::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_list output = vx_core::e_list;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_list val = vx_core::vx_any_from_any(vx_core::t_list, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_any> listval = val->vx_list();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else {
          listval.push_back(valsub);
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_list();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_list::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_list::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_list::vx_empty() const {return vx_core::e_list;}
    vx_core::Type_any Class_list::vx_type() const {return vx_core::t_list;}

    vx_core::Type_typedef Class_list::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_any}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type map)
  // class Class_map {
    Abstract_map::~Abstract_map() {}

    Class_map::Class_map() : Abstract_map::Abstract_map() {
      vx_core::refcount += 1;
    }

    Class_map::~Class_map() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_map::vx_map() const {
      vx_core::vx_Type_mapany output = this->vx_p_map;
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_map::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_any) {
        vx_core::Type_any newval = vx_core::vx_any_from_any(vx_core::t_any, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_any oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_any) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_any(key)
    vx_core::Type_any Class_map::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      const vx_core::Class_map* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_any> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_any);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_map::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_map output = vx_core::e_map;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_any> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        map[key] = val;
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_map();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_map::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_map, vals);
    }

    vx_core::Type_any Class_map::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_map output = vx_core::e_map;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_map valmap = vx_core::vx_any_from_any(vx_core::t_map, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_any> mapval = valmap->vx_map();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_any valany = valsub;
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_map();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_map::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_map::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_map::vx_empty() const {return vx_core::e_map;}
    vx_core::Type_any Class_map::vx_type() const {return vx_core::t_map;}

    vx_core::Type_typedef Class_map::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "map", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_any}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_map::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type struct)
  // class Class_struct {
    Abstract_struct::~Abstract_struct() {}

    Class_struct::Class_struct() : Abstract_struct::Abstract_struct() {
      vx_core::refcount += 1;
    }

    Class_struct::~Class_struct() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        
      });
    }

    // vx_get_any(key)
    vx_core::Type_any Class_struct::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_struct::vx_map() const {
      vx_core::vx_Type_mapany output;
      return output;
    }

    vx_core::Type_any Class_struct::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_struct, vals);
    }

    vx_core::Type_any Class_struct::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_struct output = vx_core::e_struct;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_struct val = vx_core::vx_any_from_any(vx_core::t_struct, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_struct::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_struct::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_struct::vx_empty() const {return vx_core::e_struct;}
    vx_core::Type_any Class_struct::vx_type() const {return vx_core::t_struct;}

    vx_core::Type_typedef Class_struct::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "struct", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_struct::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type msg)
  // class Class_msg {
    Abstract_msg::~Abstract_msg() {}

    Class_msg::Class_msg() : Abstract_msg::Abstract_msg() {
      vx_core::refcount += 1;
    }

    Class_msg::~Class_msg() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_code,
        this->vx_p_detail,
        this->vx_p_path,
        this->vx_p_severity,
        this->vx_p_text
      });
    }

    // code()
    vx_core::Type_string Class_msg::code() const {
      vx_core::Type_string output = this->vx_p_code;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // detail()
    vx_core::Type_any Class_msg::detail() const {
      vx_core::Type_any output = this->vx_p_detail;
      if (!output) {
        output = vx_core::e_any;
      }
      return output;
    }

    // path()
    vx_core::Type_string Class_msg::path() const {
      vx_core::Type_string output = this->vx_p_path;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // severity()
    vx_core::Type_int Class_msg::severity() const {
      vx_core::Type_int output = this->vx_p_severity;
      if (!output) {
        output = vx_core::e_int;
      }
      return output;
    }

    // text()
    vx_core::Type_string Class_msg::text() const {
      vx_core::Type_string output = this->vx_p_text;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_msg::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":code") {
        output = this->code();
      } else if (skey == ":detail") {
        output = this->detail();
      } else if (skey == ":path") {
        output = this->path();
      } else if (skey == ":severity") {
        output = this->severity();
      } else if (skey == ":text") {
        output = this->text();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_msg::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":code"] = this->code();
      output[":detail"] = this->detail();
      output[":path"] = this->path();
      output[":severity"] = this->severity();
      output[":text"] = this->text();
      return output;
    }

    vx_core::Type_any Class_msg::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_msg, vals);
    }

    vx_core::Type_any Class_msg::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_msg output = vx_core::e_msg;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_msg val = vx_core::vx_any_from_any(vx_core::t_msg, copyval);
      vx_core::Type_string vx_p_code = val->code();
      vx_core::Type_any vx_p_detail = val->detail();
      vx_core::Type_string vx_p_path = val->path();
      vx_core::Type_int vx_p_severity = val->severity();
      vx_core::Type_string vx_p_text = val->text();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (key == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            key = valstr->vx_string();
          }
        } else {
          if (false) {
          } else if (key == ":code") {
            if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_code = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            }
          } else if (key == ":detail") {
            if (valsubtype == vx_core::t_any) {
              ischanged = true;
              vx_p_detail = vx_core::vx_any_from_any(vx_core::t_any, valsub);
            }
          } else if (key == ":path") {
            if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_path = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            }
          } else if (key == ":severity") {
            if (valsubtype == vx_core::t_int) {
              ischanged = true;
              vx_p_severity = vx_core::vx_any_from_any(vx_core::t_int, valsub);
            }
          } else if (key == ":text") {
            if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_text = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            }
          }
          key = "";
        }
      }
      if (ischanged) {
        output = new vx_core::Class_msg();
        if (output->vx_p_code != vx_p_code) {
          if (output->vx_p_code) {
            vx_core::vx_release_one(output->vx_p_code);
          }
          output->vx_p_code = vx_p_code;
          vx_core::vx_reserve(vx_p_code);
        }
        if (output->vx_p_detail != vx_p_detail) {
          if (output->vx_p_detail) {
            vx_core::vx_release_one(output->vx_p_detail);
          }
          output->vx_p_detail = vx_p_detail;
          vx_core::vx_reserve(vx_p_detail);
        }
        if (output->vx_p_path != vx_p_path) {
          if (output->vx_p_path) {
            vx_core::vx_release_one(output->vx_p_path);
          }
          output->vx_p_path = vx_p_path;
          vx_core::vx_reserve(vx_p_path);
        }
        if (output->vx_p_severity != vx_p_severity) {
          if (output->vx_p_severity) {
            vx_core::vx_release_one(output->vx_p_severity);
          }
          output->vx_p_severity = vx_p_severity;
          vx_core::vx_reserve(vx_p_severity);
        }
        if (output->vx_p_text != vx_p_text) {
          if (output->vx_p_text) {
            vx_core::vx_release_one(output->vx_p_text);
          }
          output->vx_p_text = vx_p_text;
          vx_core::vx_reserve(vx_p_text);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock vx_core::Class_msg::vx_msgblock() const {return vx_core::e_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_msg::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_msg::vx_empty() const {return vx_core::e_msg;}
    vx_core::Type_any Class_msg::vx_type() const {return vx_core::t_msg;}

    vx_core::Type_typedef Class_msg::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msg", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "code", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "detail", // name
            vx_core::t_any // type
          ),
          vx_core::vx_new_arg(
            "path", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "severity", // name
            vx_core::t_int // type
          ),
          vx_core::vx_new_arg(
            "text", // name
            vx_core::t_string // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msg::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type msglist)
  // class Class_msglist {
    Abstract_msglist::~Abstract_msglist() {}

    Class_msglist::Class_msglist() : Abstract_msglist::Abstract_msglist() {
      vx_core::refcount += 1;
    }

    Class_msglist::~Class_msglist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_msglist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_msg Class_msglist::vx_get_msg(vx_core::Type_int index) const {
      vx_core::Type_msg output = vx_core::e_msg;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_msg> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_msg> Class_msglist::vx_listmsg() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_msglist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_msg(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_msglist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_msglist output = vx_core::e_msglist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_msg> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_msg) {
          vx_core::Type_msg castval = vx_core::vx_any_from_any(vx_core::t_msg, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_msg)) {
          vx_core::Type_msg castval = vx_core::vx_any_from_any(vx_core::t_msg, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(msglist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_msglist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_msglist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_msglist, vals);
    }

    vx_core::Type_any Class_msglist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_msglist output = vx_core::e_msglist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_msglist val = vx_core::vx_any_from_any(vx_core::t_msglist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_msg> listval = val->vx_listmsg();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_msg, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_msg)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_msg, valsub));
        } else if (valsubtype == vx_core::t_msglist) {
          ischanged = true;
          vx_core::Type_msglist multi = vx_core::vx_any_from_any(vx_core::t_msglist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listmsg());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new msglist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_msglist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_msglist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_msglist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_msglist::vx_empty() const {return vx_core::e_msglist;}
    vx_core::Type_any Class_msglist::vx_type() const {return vx_core::t_msglist;}

    vx_core::Type_typedef Class_msglist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msglist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_msg}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msglist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type msgblock)
  // class Class_msgblock {
    Abstract_msgblock::~Abstract_msgblock() {}

    Class_msgblock::Class_msgblock() : Abstract_msgblock::Abstract_msgblock() {
      vx_core::refcount += 1;
    }

    Class_msgblock::~Class_msgblock() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_msgs,
        this->vx_p_msgblocks
      });
    }

    // msgs()
    vx_core::Type_msglist Class_msgblock::msgs() const {
      vx_core::Type_msglist output = this->vx_p_msgs;
      if (!output) {
        output = vx_core::e_msglist;
      }
      return output;
    }

    // msgblocks()
    vx_core::Type_msgblocklist Class_msgblock::msgblocks() const {
      vx_core::Type_msgblocklist output = this->vx_p_msgblocks;
      if (!output) {
        output = vx_core::e_msgblocklist;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_msgblock::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":msgs") {
        output = this->msgs();
      } else if (skey == ":msgblocks") {
        output = this->msgblocks();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_msgblock::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":msgs"] = this->msgs();
      output[":msgblocks"] = this->msgblocks();
      return output;
    }

    vx_core::Type_any Class_msgblock::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_msgblock, vals);
    }

    vx_core::Type_any Class_msgblock::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_msgblock output = vx_core::e_msgblock;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_msgblock val = vx_core::e_msgblock;
      if (copyval) {
        val = vx_core::vx_any_from_any(vx_core::t_msgblock, copyval);
      }
      vx_core::Type_msglist vx_p_msgs = val->msgs();
      vx_core::Type_msgblocklist vx_p_msgblocks = val->msgblocks();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          vx_p_msgblocks = vx_core::vx_copy(vx_p_msgblocks, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          vx_p_msgs = vx_core::vx_copy(vx_p_msgs, {valsub});
        } else if (valsubtype == vx_core::t_msgblocklist) {
          vx_p_msgblocks = vx_core::vx_copy(vx_p_msgblocks, {valsub});
        } else if (valsubtype == vx_core::t_msglist) {
          vx_p_msgs = vx_core::vx_copy(vx_p_msgs, {valsub});
        } else if (key == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            key = valstr->vx_string();
          }
        } else {
          if (false) {
          } else if (key == ":msgs") {
            if (valsubtype == vx_core::t_msglist) {
              ischanged = true;
              vx_p_msgs = vx_core::vx_any_from_any(vx_core::t_msglist, valsub);
            }
          } else if (key == ":msgblocks") {
            if (valsubtype == vx_core::t_msgblocklist) {
              ischanged = true;
              vx_p_msgblocks = vx_core::vx_any_from_any(vx_core::t_msgblocklist, valsub);
            }
          }
          key = "";
        }
      }
      output = new vx_core::Class_msgblock();
      if (vx_p_msgs != vx_core::e_msglist) {
        output->vx_p_msgs = vx_p_msgs;
        vx_core::vx_reserve(vx_p_msgs);
      }
      if (vx_p_msgblocks != vx_core::e_msgblocklist) {
        output->vx_p_msgblocks = vx_p_msgblocks;
        vx_core::vx_reserve(vx_p_msgblocks);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock vx_core::Class_msgblock::vx_msgblock() const {return vx_core::e_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_msgblock::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_msgblock::vx_empty() const {return vx_core::e_msgblock;}
    vx_core::Type_any Class_msgblock::vx_type() const {return vx_core::t_msgblock;}

    vx_core::Type_typedef Class_msgblock::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msgblock", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "msgs", // name
            vx_core::t_msglist // type
          ),
          vx_core::vx_new_arg(
            "msgblocks", // name
            vx_core::t_msgblocklist // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msgblock::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type msgblocklist)
  // class Class_msgblocklist {
    Abstract_msgblocklist::~Abstract_msgblocklist() {}

    Class_msgblocklist::Class_msgblocklist() : Abstract_msgblocklist::Abstract_msgblocklist() {
      vx_core::refcount += 1;
    }

    Class_msgblocklist::~Class_msgblocklist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_msgblocklist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_msgblock Class_msgblocklist::vx_get_msgblock(vx_core::Type_int index) const {
      vx_core::Type_msgblock output = vx_core::e_msgblock;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_msgblock> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_msgblock> Class_msgblocklist::vx_listmsgblock() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_msgblocklist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_msgblock(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_msgblocklist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_msgblocklist output = vx_core::e_msgblocklist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_msgblock> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_msgblock) {
          vx_core::Type_msgblock castval = vx_core::vx_any_from_any(vx_core::t_msgblock, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_msgblock)) {
          vx_core::Type_msgblock castval = vx_core::vx_any_from_any(vx_core::t_msgblock, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(msgblocklist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_msgblocklist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_msgblocklist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_msgblocklist, vals);
    }

    vx_core::Type_any Class_msgblocklist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_msgblocklist output = vx_core::e_msgblocklist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_msgblocklist val = vx_core::vx_any_from_any(vx_core::t_msgblocklist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_msgblock> listval = val->vx_listmsgblock();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msgblock) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_msgblock, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_msgblock)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_msgblock, valsub));
        } else if (valsubtype == vx_core::t_msgblocklist) {
          ischanged = true;
          vx_core::Type_msgblocklist multi = vx_core::vx_any_from_any(vx_core::t_msgblocklist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listmsgblock());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new msgblocklist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_msgblocklist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_msgblocklist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_msgblocklist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_msgblocklist::vx_empty() const {return vx_core::e_msgblocklist;}
    vx_core::Type_any Class_msgblocklist::vx_type() const {return vx_core::t_msgblocklist;}

    vx_core::Type_typedef Class_msgblocklist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msgblocklist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_msgblock}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msgblocklist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type boolean)
  // class Class_boolean {
    Abstract_boolean::~Abstract_boolean() {}

    Class_boolean::Class_boolean() : Abstract_boolean::Abstract_boolean() {
      vx_core::refcount += 1;
    }

    Class_boolean::~Class_boolean() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_boolean::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_boolean, vals);
    }

    vx_core::Type_any Class_boolean::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_boolean output = vx_core::e_boolean;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_boolean val = vx_core::vx_any_from_any(vx_core::t_boolean, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      bool booleanval = val->vx_boolean();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_boolean) {
          vx_core::Type_boolean valboolean = vx_core::vx_any_from_any(vx_core::t_boolean, valsub);
          booleanval = booleanval || valboolean->vx_boolean();
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output = new vx_core::Class_boolean();
        output->vx_p_boolean = booleanval;
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      } else if (booleanval) {
        output = vx_core::c_true;
      } else {
        output = vx_core::c_false;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_boolean::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_boolean::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_boolean::vx_empty() const {return vx_core::e_boolean;}
    vx_core::Type_any Class_boolean::vx_type() const {return vx_core::t_boolean;}

    vx_core::Type_typedef Class_boolean::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "boolean", // name
        "", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_boolean::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type number)
  // class Class_number {
    Abstract_number::~Abstract_number() {}

    Class_number::Class_number() : Abstract_number::Abstract_number() {
      vx_core::refcount += 1;
    }

    Class_number::~Class_number() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_number::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_number, vals);
    }

    vx_core::Type_any Class_number::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_number output = vx_core::e_number;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_number::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_number::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_number::vx_empty() const {return vx_core::e_number;}
    vx_core::Type_any Class_number::vx_type() const {return vx_core::t_number;}

    vx_core::Type_typedef Class_number::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "number", // name
        "", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_int, vx_core::t_float, vx_core::t_decimal}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_number::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type decimal)
  // class Class_decimal {
    Abstract_decimal::~Abstract_decimal() {}

    Class_decimal::Class_decimal() : Abstract_decimal::Abstract_decimal() {
      vx_core::refcount += 1;
    }

    Class_decimal::~Class_decimal() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_decimal::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_decimal, vals);
    }

    vx_core::Type_any Class_decimal::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_decimal output = vx_core::e_decimal;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_decimal val = vx_core::vx_any_from_any(vx_core::t_decimal, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::string sval = val->vx_string();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_string) {
          vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          sval = valstring->vx_string();
        }
      }
      if (ischanged || (sval != "") || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_decimal();
        output->vx_p_decimal = sval;
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_decimal::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_decimal::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_decimal::vx_empty() const {return vx_core::e_decimal;}
    vx_core::Type_any Class_decimal::vx_type() const {return vx_core::t_decimal;}

    vx_core::Type_typedef Class_decimal::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "decimal", // name
        "", // extends
        vx_core::vx_typelist_from_listany({vx_core::t_number}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_decimal::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type float)
  // class Class_float {
    Abstract_float::~Abstract_float() {}

    Class_float::Class_float() : Abstract_float::Abstract_float() {
      vx_core::refcount += 1;
    }

    Class_float::~Class_float() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_float::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_float, vals);
    }

    vx_core::Type_any Class_float::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_float output = vx_core::e_float;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_float val = vx_core::vx_any_from_any(vx_core::t_float, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      float floatval = val->vx_float();
      float origval = floatval;
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_decimal) {
          vx_core::Type_decimal valnum = vx_core::vx_any_from_any(vx_core::t_decimal, valsub);
          floatval += valnum->vx_float();
        } else if (valsubtype == vx_core::t_float) {
          vx_core::Type_float valnum = vx_core::vx_any_from_any(vx_core::t_float, valsub);
          floatval += valnum->vx_float();
        } else if (valsubtype == vx_core::t_int) {
          vx_core::Type_int valnum = vx_core::vx_any_from_any(vx_core::t_int, valsub);
          floatval += valnum->vx_int();
        } else if (valsubtype == vx_core::t_string) {
          vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          floatval += vx_core::vx_float_from_string(valstring->vx_string());
        }
      }
      if (floatval != origval) {
        ischanged = true;
      }
      if (ischanged || (floatval != 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_float();
        output->vx_p_float = floatval;
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_float::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_float::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_float::vx_empty() const {return vx_core::e_float;}
    vx_core::Type_any Class_float::vx_type() const {return vx_core::t_float;}

    vx_core::Type_typedef Class_float::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "float", // name
        "", // extends
        vx_core::vx_typelist_from_listany({vx_core::t_number}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_float::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type int)
  // class Class_int {
    Abstract_int::~Abstract_int() {}

    Class_int::Class_int() : Abstract_int::Abstract_int() {
      vx_core::refcount += 1;
    }

    Class_int::~Class_int() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_int::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_int, vals);
    }

    vx_core::Type_any Class_int::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_int output = vx_core::e_int;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_int val = vx_core::vx_any_from_any(vx_core::t_int, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      long intval = val->vx_int();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_int) {
          vx_core::Type_int valnum = vx_core::vx_any_from_any(vx_core::t_int, valsub);
          intval += valnum->vx_int();
        } else if (valsubtype == vx_core::t_string) {
          vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          intval += vx_core::vx_int_from_string(valstring->vx_string());
        }
      }
      if ((intval != 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_int();
        output->vx_p_int = intval;
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_int::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_int::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_int::vx_empty() const {return vx_core::e_int;}
    vx_core::Type_any Class_int::vx_type() const {return vx_core::t_int;}

    vx_core::Type_typedef Class_int::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "int", // name
        "", // extends
        vx_core::vx_typelist_from_listany({vx_core::t_number}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_int::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type string)
  // class Class_string {
    Abstract_string::~Abstract_string() {}

    Class_string::Class_string() : Abstract_string::Abstract_string() {
      vx_core::refcount += 1;
    }

    Class_string::~Class_string() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_string::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_string, vals);
    }

    vx_core::Type_any Class_string::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_string output = vx_core::e_string;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_string val = vx_core::vx_any_from_any(vx_core::t_string, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::string sb = val->vx_string();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_string) {
          vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          sb += valstring->vx_string();
        } else if (valsubtype == vx_core::t_int) {
          vx_core::Type_int valint = vx_core::vx_any_from_any(vx_core::t_int, valsub);
          sb += vx_core::vx_string_from_int(valint->vx_int());
        } else if (valsubtype == vx_core::t_float) {
          vx_core::Type_float valfloat = vx_core::vx_any_from_any(vx_core::t_float, valsub);
          sb += vx_core::vx_string_from_int(valfloat->vx_float());
        } else if (valsubtype == vx_core::t_decimal) {
          vx_core::Type_decimal valdecimal = vx_core::vx_any_from_any(vx_core::t_decimal, valsub);
          sb += valdecimal->vx_string();
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new string) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if ((sb != "") || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_string();
        output->vx_p_string = sb;
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_string::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_string::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_string::vx_empty() const {return vx_core::e_string;}
    vx_core::Type_any Class_string::vx_type() const {return vx_core::t_string;}

    vx_core::Type_typedef Class_string::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "string", // name
        ":string", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_string::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type func)
  // class Class_func {
    Abstract_func::~Abstract_func() {}

    Class_func::Class_func() : Abstract_func::Abstract_func() {
      vx_core::refcount += 1;
    }

    Class_func::~Class_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_funcdef Class_func::vx_funcdef() const {
      return vx_core::e_funcdef;
    }
    vx_core::Type_any Class_func::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_func, vals);
    }

    vx_core::Type_any Class_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_func output = vx_core::e_func;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_func::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_func::vx_empty() const {return vx_core::e_func;}
    vx_core::Type_any Class_func::vx_type() const {return vx_core::t_func;}

    vx_core::Type_typedef Class_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "func", // name
        ":func", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_func::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type typedef)
  // class Class_typedef {
    Abstract_typedef::~Abstract_typedef() {}

    Class_typedef::Class_typedef() : Abstract_typedef::Abstract_typedef() {
      vx_core::refcount += 1;
    }

    Class_typedef::~Class_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_pkgname,
        this->vx_p_name,
        this->vx_p_extend,
        this->vx_p_allowfuncs,
        this->vx_p_allowtypes,
        this->vx_p_allowvalues,
        this->vx_p_disallowfuncs,
        this->vx_p_disallowtypes,
        this->vx_p_disallowvalues,
        this->vx_p_properties,
        this->vx_p_proplast,
        this->vx_p_traits
      });
    }

    // pkgname()
    vx_core::Type_string Class_typedef::pkgname() const {
      vx_core::Type_string output = this->vx_p_pkgname;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // name()
    vx_core::Type_string Class_typedef::name() const {
      vx_core::Type_string output = this->vx_p_name;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // extend()
    vx_core::Type_string Class_typedef::extend() const {
      vx_core::Type_string output = this->vx_p_extend;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // allowfuncs()
    vx_core::Type_funclist Class_typedef::allowfuncs() const {
      vx_core::Type_funclist output = this->vx_p_allowfuncs;
      if (!output) {
        output = vx_core::e_funclist;
      }
      return output;
    }

    // allowtypes()
    vx_core::Type_typelist Class_typedef::allowtypes() const {
      vx_core::Type_typelist output = this->vx_p_allowtypes;
      if (!output) {
        output = vx_core::e_typelist;
      }
      return output;
    }

    // allowvalues()
    vx_core::Type_anylist Class_typedef::allowvalues() const {
      vx_core::Type_anylist output = this->vx_p_allowvalues;
      if (!output) {
        output = vx_core::e_anylist;
      }
      return output;
    }

    // disallowfuncs()
    vx_core::Type_funclist Class_typedef::disallowfuncs() const {
      vx_core::Type_funclist output = this->vx_p_disallowfuncs;
      if (!output) {
        output = vx_core::e_funclist;
      }
      return output;
    }

    // disallowtypes()
    vx_core::Type_typelist Class_typedef::disallowtypes() const {
      vx_core::Type_typelist output = this->vx_p_disallowtypes;
      if (!output) {
        output = vx_core::e_typelist;
      }
      return output;
    }

    // disallowvalues()
    vx_core::Type_anylist Class_typedef::disallowvalues() const {
      vx_core::Type_anylist output = this->vx_p_disallowvalues;
      if (!output) {
        output = vx_core::e_anylist;
      }
      return output;
    }

    // properties()
    vx_core::Type_argmap Class_typedef::properties() const {
      vx_core::Type_argmap output = this->vx_p_properties;
      if (!output) {
        output = vx_core::e_argmap;
      }
      return output;
    }

    // proplast()
    vx_core::Type_arg Class_typedef::proplast() const {
      vx_core::Type_arg output = this->vx_p_proplast;
      if (!output) {
        output = vx_core::e_arg;
      }
      return output;
    }

    // traits()
    vx_core::Type_typelist Class_typedef::traits() const {
      vx_core::Type_typelist output = this->vx_p_traits;
      if (!output) {
        output = vx_core::e_typelist;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_typedef::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":pkgname") {
        output = this->pkgname();
      } else if (skey == ":name") {
        output = this->name();
      } else if (skey == ":extends") {
        output = this->extend();
      } else if (skey == ":allowfuncs") {
        output = this->allowfuncs();
      } else if (skey == ":allowtypes") {
        output = this->allowtypes();
      } else if (skey == ":allowvalues") {
        output = this->allowvalues();
      } else if (skey == ":disallowfuncs") {
        output = this->disallowfuncs();
      } else if (skey == ":disallowtypes") {
        output = this->disallowtypes();
      } else if (skey == ":disallowvalues") {
        output = this->disallowvalues();
      } else if (skey == ":properties") {
        output = this->properties();
      } else if (skey == ":proplast") {
        output = this->proplast();
      } else if (skey == ":traits") {
        output = this->traits();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_typedef::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":pkgname"] = this->pkgname();
      output[":name"] = this->name();
      output[":extends"] = this->extend();
      output[":allowfuncs"] = this->allowfuncs();
      output[":allowtypes"] = this->allowtypes();
      output[":allowvalues"] = this->allowvalues();
      output[":disallowfuncs"] = this->disallowfuncs();
      output[":disallowtypes"] = this->disallowtypes();
      output[":disallowvalues"] = this->disallowvalues();
      output[":properties"] = this->properties();
      output[":proplast"] = this->proplast();
      output[":traits"] = this->traits();
      return output;
    }

    vx_core::Type_any Class_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_typedef, vals);
    }

    vx_core::Type_any Class_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_typedef output = vx_core::e_typedef;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_typedef val = vx_core::vx_any_from_any(vx_core::t_typedef, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_pkgname = val->pkgname();
      vx_core::Type_string vx_p_name = val->name();
      vx_core::Type_string vx_p_extend = val->extend();
      vx_core::Type_funclist vx_p_allowfuncs = val->allowfuncs();
      vx_core::Type_typelist vx_p_allowtypes = val->allowtypes();
      vx_core::Type_anylist vx_p_allowvalues = val->allowvalues();
      vx_core::Type_funclist vx_p_disallowfuncs = val->disallowfuncs();
      vx_core::Type_typelist vx_p_disallowtypes = val->disallowtypes();
      vx_core::Type_anylist vx_p_disallowvalues = val->disallowvalues();
      vx_core::Type_argmap vx_p_properties = val->properties();
      vx_core::Type_arg vx_p_proplast = val->proplast();
      vx_core::Type_typelist vx_p_traits = val->traits();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":pkgname") {
            key = testkey;
          } else if (testkey == ":name") {
            key = testkey;
          } else if (testkey == ":extends") {
            key = testkey;
          } else if (testkey == ":allowfuncs") {
            key = testkey;
          } else if (testkey == ":allowtypes") {
            key = testkey;
          } else if (testkey == ":allowvalues") {
            key = testkey;
          } else if (testkey == ":disallowfuncs") {
            key = testkey;
          } else if (testkey == ":disallowtypes") {
            key = testkey;
          } else if (testkey == ":disallowvalues") {
            key = testkey;
          } else if (testkey == ":properties") {
            key = testkey;
          } else if (testkey == ":proplast") {
            key = testkey;
          } else if (testkey == ":traits") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":pkgname") {
            if (vx_p_pkgname == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_pkgname = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :pkgname " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":name") {
            if (vx_p_name == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_name = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :name " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":extends") {
            if (vx_p_extend == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_extend = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :extends " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":allowfuncs") {
            if (vx_p_allowfuncs == valsub) {
            } else if (valsubtype == vx_core::t_funclist) {
              ischanged = true;
              vx_p_allowfuncs = vx_core::vx_any_from_any(vx_core::t_funclist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :allowfuncs " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":allowtypes") {
            if (vx_p_allowtypes == valsub) {
            } else if (valsubtype == vx_core::t_typelist) {
              ischanged = true;
              vx_p_allowtypes = vx_core::vx_any_from_any(vx_core::t_typelist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :allowtypes " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":allowvalues") {
            if (vx_p_allowvalues == valsub) {
            } else if (valsubtype == vx_core::t_anylist) {
              ischanged = true;
              vx_p_allowvalues = vx_core::vx_any_from_any(vx_core::t_anylist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :allowvalues " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":disallowfuncs") {
            if (vx_p_disallowfuncs == valsub) {
            } else if (valsubtype == vx_core::t_funclist) {
              ischanged = true;
              vx_p_disallowfuncs = vx_core::vx_any_from_any(vx_core::t_funclist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :disallowfuncs " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":disallowtypes") {
            if (vx_p_disallowtypes == valsub) {
            } else if (valsubtype == vx_core::t_typelist) {
              ischanged = true;
              vx_p_disallowtypes = vx_core::vx_any_from_any(vx_core::t_typelist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :disallowtypes " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":disallowvalues") {
            if (vx_p_disallowvalues == valsub) {
            } else if (valsubtype == vx_core::t_anylist) {
              ischanged = true;
              vx_p_disallowvalues = vx_core::vx_any_from_any(vx_core::t_anylist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :disallowvalues " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":properties") {
            if (vx_p_properties == valsub) {
            } else if (valsubtype == vx_core::t_argmap) {
              ischanged = true;
              vx_p_properties = vx_core::vx_any_from_any(vx_core::t_argmap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :properties " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":proplast") {
            if (vx_p_proplast == valsub) {
            } else if (valsubtype == vx_core::t_arg) {
              ischanged = true;
              vx_p_proplast = vx_core::vx_any_from_any(vx_core::t_arg, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :proplast " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":traits") {
            if (vx_p_traits == valsub) {
            } else if (valsubtype == vx_core::t_typelist) {
              ischanged = true;
              vx_p_traits = vx_core::vx_any_from_any(vx_core::t_typelist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef :traits " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new typedef) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_typedef();
        if (output->vx_p_pkgname != vx_p_pkgname) {
          if (output->vx_p_pkgname) {
            vx_core::vx_release_one(output->vx_p_pkgname);
          }
          output->vx_p_pkgname = vx_p_pkgname;
          vx_core::vx_reserve(vx_p_pkgname);
        }
        if (output->vx_p_name != vx_p_name) {
          if (output->vx_p_name) {
            vx_core::vx_release_one(output->vx_p_name);
          }
          output->vx_p_name = vx_p_name;
          vx_core::vx_reserve(vx_p_name);
        }
        if (output->vx_p_extend != vx_p_extend) {
          if (output->vx_p_extend) {
            vx_core::vx_release_one(output->vx_p_extend);
          }
          output->vx_p_extend = vx_p_extend;
          vx_core::vx_reserve(vx_p_extend);
        }
        if (output->vx_p_allowfuncs != vx_p_allowfuncs) {
          if (output->vx_p_allowfuncs) {
            vx_core::vx_release_one(output->vx_p_allowfuncs);
          }
          output->vx_p_allowfuncs = vx_p_allowfuncs;
          vx_core::vx_reserve(vx_p_allowfuncs);
        }
        if (output->vx_p_allowtypes != vx_p_allowtypes) {
          if (output->vx_p_allowtypes) {
            vx_core::vx_release_one(output->vx_p_allowtypes);
          }
          output->vx_p_allowtypes = vx_p_allowtypes;
          vx_core::vx_reserve(vx_p_allowtypes);
        }
        if (output->vx_p_allowvalues != vx_p_allowvalues) {
          if (output->vx_p_allowvalues) {
            vx_core::vx_release_one(output->vx_p_allowvalues);
          }
          output->vx_p_allowvalues = vx_p_allowvalues;
          vx_core::vx_reserve(vx_p_allowvalues);
        }
        if (output->vx_p_disallowfuncs != vx_p_disallowfuncs) {
          if (output->vx_p_disallowfuncs) {
            vx_core::vx_release_one(output->vx_p_disallowfuncs);
          }
          output->vx_p_disallowfuncs = vx_p_disallowfuncs;
          vx_core::vx_reserve(vx_p_disallowfuncs);
        }
        if (output->vx_p_disallowtypes != vx_p_disallowtypes) {
          if (output->vx_p_disallowtypes) {
            vx_core::vx_release_one(output->vx_p_disallowtypes);
          }
          output->vx_p_disallowtypes = vx_p_disallowtypes;
          vx_core::vx_reserve(vx_p_disallowtypes);
        }
        if (output->vx_p_disallowvalues != vx_p_disallowvalues) {
          if (output->vx_p_disallowvalues) {
            vx_core::vx_release_one(output->vx_p_disallowvalues);
          }
          output->vx_p_disallowvalues = vx_p_disallowvalues;
          vx_core::vx_reserve(vx_p_disallowvalues);
        }
        if (output->vx_p_properties != vx_p_properties) {
          if (output->vx_p_properties) {
            vx_core::vx_release_one(output->vx_p_properties);
          }
          output->vx_p_properties = vx_p_properties;
          vx_core::vx_reserve(vx_p_properties);
        }
        if (output->vx_p_proplast != vx_p_proplast) {
          if (output->vx_p_proplast) {
            vx_core::vx_release_one(output->vx_p_proplast);
          }
          output->vx_p_proplast = vx_p_proplast;
          vx_core::vx_reserve(vx_p_proplast);
        }
        if (output->vx_p_traits != vx_p_traits) {
          if (output->vx_p_traits) {
            vx_core::vx_release_one(output->vx_p_traits);
          }
          output->vx_p_traits = vx_p_traits;
          vx_core::vx_reserve(vx_p_traits);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_typedef::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_typedef::vx_empty() const {return vx_core::e_typedef;}
    vx_core::Type_any Class_typedef::vx_type() const {return vx_core::t_typedef;}

    vx_core::Type_typedef Class_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "typedef", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "pkgname", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "name", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "extends", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "allowfuncs", // name
            vx_core::t_funclist // type
          ),
          vx_core::vx_new_arg(
            "allowtypes", // name
            vx_core::t_typelist // type
          ),
          vx_core::vx_new_arg(
            "allowvalues", // name
            vx_core::t_anylist // type
          ),
          vx_core::vx_new_arg(
            "disallowfuncs", // name
            vx_core::t_funclist // type
          ),
          vx_core::vx_new_arg(
            "disallowtypes", // name
            vx_core::t_typelist // type
          ),
          vx_core::vx_new_arg(
            "disallowvalues", // name
            vx_core::t_anylist // type
          ),
          vx_core::vx_new_arg(
            "properties", // name
            vx_core::t_argmap // type
          ),
          vx_core::vx_new_arg(
            "proplast", // name
            vx_core::t_arg // type
          ),
          vx_core::vx_new_arg(
            "traits", // name
            vx_core::t_typelist // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_typedef::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type funcdef)
  // class Class_funcdef {
    Abstract_funcdef::~Abstract_funcdef() {}

    Class_funcdef::Class_funcdef() : Abstract_funcdef::Abstract_funcdef() {
      vx_core::refcount += 1;
    }

    Class_funcdef::~Class_funcdef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_pkgname,
        this->vx_p_name,
        this->vx_p_idx,
        this->vx_p_type,
        this->vx_p_async
      });
    }

    // pkgname()
    vx_core::Type_string Class_funcdef::pkgname() const {
      vx_core::Type_string output = this->vx_p_pkgname;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // name()
    vx_core::Type_string Class_funcdef::name() const {
      vx_core::Type_string output = this->vx_p_name;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // idx()
    vx_core::Type_int Class_funcdef::idx() const {
      vx_core::Type_int output = this->vx_p_idx;
      if (!output) {
        output = vx_core::e_int;
      }
      return output;
    }

    // type()
    vx_core::Type_any Class_funcdef::type() const {
      vx_core::Type_any output = this->vx_p_type;
      if (!output) {
        output = vx_core::e_any;
      }
      return output;
    }

    // async()
    vx_core::Type_boolean Class_funcdef::async() const {
      vx_core::Type_boolean output = this->vx_p_async;
      if (!output) {
        output = vx_core::e_boolean;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_funcdef::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":pkgname") {
        output = this->pkgname();
      } else if (skey == ":name") {
        output = this->name();
      } else if (skey == ":idx") {
        output = this->idx();
      } else if (skey == ":type") {
        output = this->type();
      } else if (skey == ":async") {
        output = this->async();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_funcdef::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":pkgname"] = this->pkgname();
      output[":name"] = this->name();
      output[":idx"] = this->idx();
      output[":type"] = this->type();
      output[":async"] = this->async();
      return output;
    }

    vx_core::Type_any Class_funcdef::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_funcdef, vals);
    }

    vx_core::Type_any Class_funcdef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_funcdef output = vx_core::e_funcdef;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_funcdef val = vx_core::vx_any_from_any(vx_core::t_funcdef, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_pkgname = val->pkgname();
      vx_core::Type_string vx_p_name = val->name();
      vx_core::Type_int vx_p_idx = val->idx();
      vx_core::Type_any vx_p_type = val->type();
      vx_core::Type_boolean vx_p_async = val->async();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":pkgname") {
            key = testkey;
          } else if (testkey == ":name") {
            key = testkey;
          } else if (testkey == ":idx") {
            key = testkey;
          } else if (testkey == ":type") {
            key = testkey;
          } else if (testkey == ":async") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new funcdef) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":pkgname") {
            if (vx_p_pkgname == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_pkgname = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new funcdef :pkgname " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":name") {
            if (vx_p_name == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_name = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new funcdef :name " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":idx") {
            if (vx_p_idx == valsub) {
            } else if (valsubtype == vx_core::t_int) {
              ischanged = true;
              vx_p_idx = vx_core::vx_any_from_any(vx_core::t_int, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new funcdef :idx " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":type") {
            if (vx_p_type != valsub) {
              ischanged = true;
              vx_p_type = valsub;
            }
          } else if (key == ":async") {
            if (vx_p_async == valsub) {
            } else if (valsubtype == vx_core::t_boolean) {
              ischanged = true;
              vx_p_async = vx_core::vx_any_from_any(vx_core::t_boolean, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new funcdef :async " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new funcdef) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_funcdef();
        if (output->vx_p_pkgname != vx_p_pkgname) {
          if (output->vx_p_pkgname) {
            vx_core::vx_release_one(output->vx_p_pkgname);
          }
          output->vx_p_pkgname = vx_p_pkgname;
          vx_core::vx_reserve(vx_p_pkgname);
        }
        if (output->vx_p_name != vx_p_name) {
          if (output->vx_p_name) {
            vx_core::vx_release_one(output->vx_p_name);
          }
          output->vx_p_name = vx_p_name;
          vx_core::vx_reserve(vx_p_name);
        }
        if (output->vx_p_idx != vx_p_idx) {
          if (output->vx_p_idx) {
            vx_core::vx_release_one(output->vx_p_idx);
          }
          output->vx_p_idx = vx_p_idx;
          vx_core::vx_reserve(vx_p_idx);
        }
        if (output->vx_p_type != vx_p_type) {
          if (output->vx_p_type) {
            vx_core::vx_release_one(output->vx_p_type);
          }
          output->vx_p_type = vx_p_type;
          vx_core::vx_reserve(vx_p_type);
        }
        if (output->vx_p_async != vx_p_async) {
          if (output->vx_p_async) {
            vx_core::vx_release_one(output->vx_p_async);
          }
          output->vx_p_async = vx_p_async;
          vx_core::vx_reserve(vx_p_async);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_funcdef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_funcdef::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_funcdef::vx_empty() const {return vx_core::e_funcdef;}
    vx_core::Type_any Class_funcdef::vx_type() const {return vx_core::t_funcdef;}

    vx_core::Type_typedef Class_funcdef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "funcdef", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "pkgname", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "name", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "idx", // name
            vx_core::t_int // type
          ),
          vx_core::vx_new_arg(
            "type", // name
            vx_core::t_any // type
          ),
          vx_core::vx_new_arg(
            "async", // name
            vx_core::t_boolean // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_funcdef::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type any-async<-func)
  // class Class_any_async_from_func {
    Abstract_any_async_from_func::~Abstract_any_async_from_func() {}

    Class_any_async_from_func::Class_any_async_from_func() : Abstract_any_async_from_func::Abstract_any_async_from_func() {
      vx_core::refcount += 1;
    }

    Class_any_async_from_func::~Class_any_async_from_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_any_async_from_func::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_any_async_from_func, vals);
    }

    vx_core::Type_any Class_any_async_from_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_any_async_from_func output = vx_core::e_any_async_from_func;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_any_async_from_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_any_async_from_func::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_any_async_from_func::vx_empty() const {return vx_core::e_any_async_from_func;}
    vx_core::Type_any Class_any_async_from_func::vx_type() const {return vx_core::t_any_async_from_func;}

    vx_core::Type_typedef Class_any_async_from_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any-async<-func", // name
        ":func", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::vx_funclist_from_listfunc({vx_core::t_any_from_func, vx_core::t_any_from_func_async}), // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_async_from_func::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type any<-anylist)
  // class Class_any_from_anylist {
    Abstract_any_from_anylist::~Abstract_any_from_anylist() {}

    Class_any_from_anylist::Class_any_from_anylist() : Abstract_any_from_anylist::Abstract_any_from_anylist() {
      vx_core::refcount += 1;
    }

    Class_any_from_anylist::~Class_any_from_anylist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_any_from_anylist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Func_any_from_any Class_any_from_anylist::vx_get_any_from_any(vx_core::Type_int index) const {
      vx_core::Func_any_from_any output = vx_core::e_any_from_any;
      long iindex = index->vx_int();
      std::vector<vx_core::Func_any_from_any> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Func_any_from_any> Class_any_from_anylist::vx_listany_from_any() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_any_from_anylist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_any_from_any(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_any_from_anylist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_any_from_anylist output = vx_core::e_any_from_anylist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Func_any_from_any> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_any_from_any) {
          vx_core::Func_any_from_any castval = vx_core::vx_any_from_any(vx_core::t_any_from_any, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_any_from_any)) {
          vx_core::Func_any_from_any castval = vx_core::vx_any_from_any(vx_core::t_any_from_any, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(any_from_anylist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_any_from_anylist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_any_from_anylist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_any_from_anylist, vals);
    }

    vx_core::Type_any Class_any_from_anylist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_any_from_anylist output = vx_core::e_any_from_anylist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_any_from_anylist val = vx_core::vx_any_from_any(vx_core::t_any_from_anylist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Func_any_from_any> listval = val->vx_listany_from_any();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_any_from_anylist) {
          ischanged = true;
          vx_core::Type_any_from_anylist multi = vx_core::vx_any_from_any(vx_core::t_any_from_anylist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listany_from_any());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new any<-anylist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_any_from_anylist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_any_from_anylist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_any_from_anylist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_any_from_anylist::vx_empty() const {return vx_core::e_any_from_anylist;}
    vx_core::Type_any Class_any_from_anylist::vx_type() const {return vx_core::t_any_from_anylist;}

    vx_core::Type_typedef Class_any_from_anylist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-anylist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::vx_funclist_from_listfunc({vx_core::t_any_from_any}), // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_anylist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type anylist)
  // class Class_anylist {
    Abstract_anylist::~Abstract_anylist() {}

    Class_anylist::Class_anylist() : Abstract_anylist::Abstract_anylist() {
      vx_core::refcount += 1;
    }

    Class_anylist::~Class_anylist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_anylist::vx_list() const {
      return this->vx_p_list;
    }

    // vx_get_any(index)
    vx_core::Type_any Class_anylist::vx_get_any(vx_core::Type_int index) const {
      vx_core::Type_any output = vx_core::e_any;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_any> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_anylist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_anylist output = vx_core::e_anylist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_any> list;
      for (auto const& valsub : listval) {
        list.push_back(valsub);
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_anylist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_anylist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_anylist, vals);
    }

    vx_core::Type_any Class_anylist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_anylist output = vx_core::e_anylist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_anylist val = vx_core::vx_any_from_any(vx_core::t_anylist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_any> listval = val->vx_list();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_anylist) {
          ischanged = true;
          vx_core::Type_anylist multi = vx_core::vx_any_from_any(vx_core::t_anylist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_list());
        } else {
          listval.push_back(valsub);
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_anylist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_anylist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_anylist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_anylist::vx_empty() const {return vx_core::e_anylist;}
    vx_core::Type_any Class_anylist::vx_type() const {return vx_core::t_anylist;}

    vx_core::Type_typedef Class_anylist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "anylist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_any}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_anylist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type anymap)
  // class Class_anymap {
    Abstract_anymap::~Abstract_anymap() {}

    Class_anymap::Class_anymap() : Abstract_anymap::Abstract_anymap() {
      vx_core::refcount += 1;
    }

    Class_anymap::~Class_anymap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_anymap::vx_map() const {
      vx_core::vx_Type_mapany output = this->vx_p_map;
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_anymap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_any) {
        vx_core::Type_any newval = vx_core::vx_any_from_any(vx_core::t_any, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_any oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_any) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_any(key)
    vx_core::Type_any Class_anymap::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      const vx_core::Class_anymap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_any> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_any);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_anymap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_anymap output = vx_core::e_anymap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_any> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        map[key] = val;
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_anymap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_anymap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_anymap, vals);
    }

    vx_core::Type_any Class_anymap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_anymap output = vx_core::e_anymap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_anymap valmap = vx_core::vx_any_from_any(vx_core::t_anymap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_any> mapval = valmap->vx_map();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_any valany = valsub;
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_anymap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_anymap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_anymap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_anymap::vx_empty() const {return vx_core::e_anymap;}
    vx_core::Type_any Class_anymap::vx_type() const {return vx_core::t_anymap;}

    vx_core::Type_typedef Class_anymap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "anymap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_any}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_anymap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type anytype)
  // class Class_anytype {
    Abstract_anytype::~Abstract_anytype() {}

    Class_anytype::Class_anytype() : Abstract_anytype::Abstract_anytype() {
      vx_core::refcount += 1;
    }

    Class_anytype::~Class_anytype() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_anytype::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_anytype, vals);
    }

    vx_core::Type_any Class_anytype::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_anytype output = vx_core::e_anytype;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_anytype::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_anytype::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_anytype::vx_empty() const {return vx_core::e_anytype;}
    vx_core::Type_any Class_anytype::vx_type() const {return vx_core::t_anytype;}

    vx_core::Type_typedef Class_anytype::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "anytype", // name
        ":type", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_anytype::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type arg)
  // class Class_arg {
    Abstract_arg::~Abstract_arg() {}

    Class_arg::Class_arg() : Abstract_arg::Abstract_arg() {
      vx_core::refcount += 1;
    }

    Class_arg::~Class_arg() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_name,
        this->vx_p_argtype,
        this->vx_p_fn_any,
        this->vx_p_doc
      });
    }

    // name()
    vx_core::Type_string Class_arg::name() const {
      vx_core::Type_string output = this->vx_p_name;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // argtype()
    vx_core::Type_any Class_arg::argtype() const {
      vx_core::Type_any output = this->vx_p_argtype;
      if (!output) {
        output = vx_core::e_any;
      }
      return output;
    }

    // fn_any()
    vx_core::Func_any_from_func Class_arg::fn_any() const {
      vx_core::Func_any_from_func output = this->vx_p_fn_any;
      if (!output) {
        output = vx_core::e_any_from_func;
      }
      return output;
    }

    // doc()
    vx_core::Type_string Class_arg::doc() const {
      vx_core::Type_string output = this->vx_p_doc;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_arg::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":name") {
        output = this->name();
      } else if (skey == ":argtype") {
        output = this->argtype();
      } else if (skey == ":fn-any") {
        output = this->fn_any();
      } else if (skey == ":doc") {
        output = this->doc();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_arg::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":name"] = this->name();
      output[":argtype"] = this->argtype();
      output[":fn-any"] = this->fn_any();
      output[":doc"] = this->doc();
      return output;
    }

    vx_core::Type_any Class_arg::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_arg, vals);
    }

    vx_core::Type_any Class_arg::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_arg output = vx_core::e_arg;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_arg val = vx_core::vx_any_from_any(vx_core::t_arg, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_name = val->name();
      vx_core::Type_any vx_p_argtype = val->argtype();
      vx_core::Func_any_from_func vx_p_fn_any = val->fn_any();
      vx_core::Type_string vx_p_doc = val->doc();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":name") {
            key = testkey;
          } else if (testkey == ":argtype") {
            key = testkey;
          } else if (testkey == ":fn-any") {
            key = testkey;
          } else if (testkey == ":doc") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new arg) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":name") {
            if (vx_p_name == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_name = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new arg :name " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":argtype") {
            if (vx_p_argtype != valsub) {
              ischanged = true;
              vx_p_argtype = valsub;
            }
          } else if (key == ":fn-any") {
            if (vx_p_fn_any == valsub) {
            } else if (valsubtype == vx_core::t_any_from_func) {
              ischanged = true;
              vx_p_fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new arg :fn-any " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":doc") {
            if (vx_p_doc == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_doc = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new arg :doc " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new arg) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_arg();
        if (output->vx_p_name != vx_p_name) {
          if (output->vx_p_name) {
            vx_core::vx_release_one(output->vx_p_name);
          }
          output->vx_p_name = vx_p_name;
          vx_core::vx_reserve(vx_p_name);
        }
        if (output->vx_p_argtype != vx_p_argtype) {
          if (output->vx_p_argtype) {
            vx_core::vx_release_one(output->vx_p_argtype);
          }
          output->vx_p_argtype = vx_p_argtype;
          vx_core::vx_reserve(vx_p_argtype);
        }
        if (output->vx_p_fn_any != vx_p_fn_any) {
          if (output->vx_p_fn_any) {
            vx_core::vx_release_one(output->vx_p_fn_any);
          }
          output->vx_p_fn_any = vx_p_fn_any;
          vx_core::vx_reserve(vx_p_fn_any);
        }
        if (output->vx_p_doc != vx_p_doc) {
          if (output->vx_p_doc) {
            vx_core::vx_release_one(output->vx_p_doc);
          }
          output->vx_p_doc = vx_p_doc;
          vx_core::vx_reserve(vx_p_doc);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_arg::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_arg::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_arg::vx_empty() const {return vx_core::e_arg;}
    vx_core::Type_any Class_arg::vx_type() const {return vx_core::t_arg;}

    vx_core::Type_typedef Class_arg::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "arg", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "name", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "argtype", // name
            vx_core::t_any // type
          ),
          vx_core::vx_new_arg(
            "fn-any", // name
            vx_core::t_any_from_func // type
          ),
          vx_core::vx_new_arg(
            "doc", // name
            vx_core::t_string // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_arg::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type arglist)
  // class Class_arglist {
    Abstract_arglist::~Abstract_arglist() {}

    Class_arglist::Class_arglist() : Abstract_arglist::Abstract_arglist() {
      vx_core::refcount += 1;
    }

    Class_arglist::~Class_arglist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_arglist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_arg Class_arglist::vx_get_arg(vx_core::Type_int index) const {
      vx_core::Type_arg output = vx_core::e_arg;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_arg> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_arg> Class_arglist::vx_listarg() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_arglist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_arg(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_arglist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_arglist output = vx_core::e_arglist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_arg> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_arg) {
          vx_core::Type_arg castval = vx_core::vx_any_from_any(vx_core::t_arg, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_arg)) {
          vx_core::Type_arg castval = vx_core::vx_any_from_any(vx_core::t_arg, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(arglist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_arglist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_arglist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_arglist, vals);
    }

    vx_core::Type_any Class_arglist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_arglist output = vx_core::e_arglist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_arglist val = vx_core::vx_any_from_any(vx_core::t_arglist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_arg> listval = val->vx_listarg();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_arg) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_arg, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_arg)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_arg, valsub));
        } else if (valsubtype == vx_core::t_arglist) {
          ischanged = true;
          vx_core::Type_arglist multi = vx_core::vx_any_from_any(vx_core::t_arglist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listarg());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new arglist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_arglist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_arglist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_arglist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_arglist::vx_empty() const {return vx_core::e_arglist;}
    vx_core::Type_any Class_arglist::vx_type() const {return vx_core::t_arglist;}

    vx_core::Type_typedef Class_arglist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "arglist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_arg}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_arglist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type argmap)
  // class Class_argmap {
    Abstract_argmap::~Abstract_argmap() {}

    Class_argmap::Class_argmap() : Abstract_argmap::Abstract_argmap() {
      vx_core::refcount += 1;
    }

    Class_argmap::~Class_argmap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_argmap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_argmap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_arg) {
        vx_core::Type_arg newval = vx_core::vx_any_from_any(vx_core::t_arg, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_arg oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_arg) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_arg(key)
    vx_core::Type_arg Class_argmap::vx_get_arg(vx_core::Type_string key) const {
      vx_core::Type_arg output = vx_core::e_arg;
      const vx_core::Class_argmap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_arg> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_arg);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_argmap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_arg(key);
    }

    // vx_maparg()
    std::map<std::string, vx_core::Type_arg> Class_argmap::vx_maparg() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_argmap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_argmap output = vx_core::e_argmap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_arg> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_arg) {
          vx_core::Type_arg castval = vx_core::vx_any_from_any(vx_core::t_arg, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(argmap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_argmap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_argmap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_argmap, vals);
    }

    vx_core::Type_any Class_argmap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_argmap output = vx_core::e_argmap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_argmap valmap = vx_core::vx_any_from_any(vx_core::t_argmap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_arg> mapval = valmap->vx_maparg();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_arg valany = NULL;
          if (valsubtype == vx_core::t_arg) {
            valany = vx_core::vx_any_from_any(vx_core::t_arg, valsub);
          } else if (valsubtype == vx_core::t_arg) {
            valany = vx_core::vx_any_from_any(vx_core::t_arg, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_argmap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_argmap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_argmap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_argmap::vx_empty() const {return vx_core::e_argmap;}
    vx_core::Type_any Class_argmap::vx_type() const {return vx_core::t_argmap;}

    vx_core::Type_typedef Class_argmap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "argmap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_arg}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_argmap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type booleanlist)
  // class Class_booleanlist {
    Abstract_booleanlist::~Abstract_booleanlist() {}

    Class_booleanlist::Class_booleanlist() : Abstract_booleanlist::Abstract_booleanlist() {
      vx_core::refcount += 1;
    }

    Class_booleanlist::~Class_booleanlist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_booleanlist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_boolean Class_booleanlist::vx_get_boolean(vx_core::Type_int index) const {
      vx_core::Type_boolean output = vx_core::e_boolean;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_boolean> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_boolean> Class_booleanlist::vx_listboolean() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_booleanlist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_boolean(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_booleanlist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_booleanlist output = vx_core::e_booleanlist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_boolean> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_boolean) {
          vx_core::Type_boolean castval = vx_core::vx_any_from_any(vx_core::t_boolean, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_boolean)) {
          vx_core::Type_boolean castval = vx_core::vx_any_from_any(vx_core::t_boolean, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(booleanlist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_booleanlist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_booleanlist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_booleanlist, vals);
    }

    vx_core::Type_any Class_booleanlist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_booleanlist output = vx_core::e_booleanlist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_booleanlist val = vx_core::vx_any_from_any(vx_core::t_booleanlist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_boolean> listval = val->vx_listboolean();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_boolean) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_boolean, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_boolean)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_boolean, valsub));
        } else if (valsubtype == vx_core::t_booleanlist) {
          ischanged = true;
          vx_core::Type_booleanlist multi = vx_core::vx_any_from_any(vx_core::t_booleanlist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listboolean());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new booleanlist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_booleanlist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_booleanlist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_booleanlist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_booleanlist::vx_empty() const {return vx_core::e_booleanlist;}
    vx_core::Type_any Class_booleanlist::vx_type() const {return vx_core::t_booleanlist;}

    vx_core::Type_typedef Class_booleanlist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "booleanlist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_boolean}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_booleanlist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type collection)
  // class Class_collection {
    Abstract_collection::~Abstract_collection() {}

    Class_collection::Class_collection() : Abstract_collection::Abstract_collection() {
      vx_core::refcount += 1;
    }

    Class_collection::~Class_collection() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_collection::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_collection, vals);
    }

    vx_core::Type_any Class_collection::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_collection output = vx_core::e_collection;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_collection::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_collection::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_collection::vx_empty() const {return vx_core::e_collection;}
    vx_core::Type_any Class_collection::vx_type() const {return vx_core::t_collection;}

    vx_core::Type_typedef Class_collection::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "collection", // name
        "", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_list, vx_core::t_map}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_collection::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type compilelanguages)
  // class Class_compilelanguages {
    Abstract_compilelanguages::~Abstract_compilelanguages() {}

    Class_compilelanguages::Class_compilelanguages() : Abstract_compilelanguages::Abstract_compilelanguages() {
      vx_core::refcount += 1;
    }

    Class_compilelanguages::~Class_compilelanguages() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_compilelanguages::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_compilelanguages, vals);
    }

    vx_core::Type_any Class_compilelanguages::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_compilelanguages output = vx_core::e_compilelanguages;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_compilelanguages::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_compilelanguages::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_compilelanguages::vx_empty() const {return vx_core::e_compilelanguages;}
    vx_core::Type_any Class_compilelanguages::vx_type() const {return vx_core::t_compilelanguages;}

    vx_core::Type_typedef Class_compilelanguages::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "compilelanguages", // name
        "", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_compilelanguages::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type connect)
  // class Class_connect {
    Abstract_connect::~Abstract_connect() {}

    Class_connect::Class_connect() : Abstract_connect::Abstract_connect() {
      vx_core::refcount += 1;
    }

    Class_connect::~Class_connect() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_connect::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_connect, vals);
    }

    vx_core::Type_any Class_connect::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_connect output = vx_core::e_connect;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_connect::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_connect::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_connect::vx_empty() const {return vx_core::e_connect;}
    vx_core::Type_any Class_connect::vx_type() const {return vx_core::t_connect;}

    vx_core::Type_typedef Class_connect::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "connect", // name
        "", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_connect::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type connectlist)
  // class Class_connectlist {
    Abstract_connectlist::~Abstract_connectlist() {}

    Class_connectlist::Class_connectlist() : Abstract_connectlist::Abstract_connectlist() {
      vx_core::refcount += 1;
    }

    Class_connectlist::~Class_connectlist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_connectlist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_connect Class_connectlist::vx_get_connect(vx_core::Type_int index) const {
      vx_core::Type_connect output = vx_core::e_connect;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_connect> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_connect> Class_connectlist::vx_listconnect() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_connectlist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_connect(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_connectlist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_connectlist output = vx_core::e_connectlist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_connect> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_connect) {
          vx_core::Type_connect castval = vx_core::vx_any_from_any(vx_core::t_connect, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_connect)) {
          vx_core::Type_connect castval = vx_core::vx_any_from_any(vx_core::t_connect, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(connectlist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_connectlist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_connectlist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_connectlist, vals);
    }

    vx_core::Type_any Class_connectlist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_connectlist output = vx_core::e_connectlist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_connectlist val = vx_core::vx_any_from_any(vx_core::t_connectlist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_connect> listval = val->vx_listconnect();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_connect) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_connect, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_connect)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_connect, valsub));
        } else if (valsubtype == vx_core::t_connectlist) {
          ischanged = true;
          vx_core::Type_connectlist multi = vx_core::vx_any_from_any(vx_core::t_connectlist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listconnect());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new connectlist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_connectlist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_connectlist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_connectlist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_connectlist::vx_empty() const {return vx_core::e_connectlist;}
    vx_core::Type_any Class_connectlist::vx_type() const {return vx_core::t_connectlist;}

    vx_core::Type_typedef Class_connectlist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "connectlist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_connect}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_connectlist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type connectmap)
  // class Class_connectmap {
    Abstract_connectmap::~Abstract_connectmap() {}

    Class_connectmap::Class_connectmap() : Abstract_connectmap::Abstract_connectmap() {
      vx_core::refcount += 1;
    }

    Class_connectmap::~Class_connectmap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_connectmap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_connectmap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_connect) {
        vx_core::Type_connect newval = vx_core::vx_any_from_any(vx_core::t_connect, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_connect oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_connect) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_connect(key)
    vx_core::Type_connect Class_connectmap::vx_get_connect(vx_core::Type_string key) const {
      vx_core::Type_connect output = vx_core::e_connect;
      const vx_core::Class_connectmap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_connect> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_connect);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_connectmap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_connect(key);
    }

    // vx_mapconnect()
    std::map<std::string, vx_core::Type_connect> Class_connectmap::vx_mapconnect() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_connectmap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_connectmap output = vx_core::e_connectmap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_connect> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_connect) {
          vx_core::Type_connect castval = vx_core::vx_any_from_any(vx_core::t_connect, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(connectmap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_connectmap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_connectmap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_connectmap, vals);
    }

    vx_core::Type_any Class_connectmap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_connectmap output = vx_core::e_connectmap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_connectmap valmap = vx_core::vx_any_from_any(vx_core::t_connectmap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_connect> mapval = valmap->vx_mapconnect();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_connect valany = NULL;
          if (valsubtype == vx_core::t_connect) {
            valany = vx_core::vx_any_from_any(vx_core::t_connect, valsub);
          } else if (valsubtype == vx_core::t_connect) {
            valany = vx_core::vx_any_from_any(vx_core::t_connect, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_connectmap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_connectmap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_connectmap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_connectmap::vx_empty() const {return vx_core::e_connectmap;}
    vx_core::Type_any Class_connectmap::vx_type() const {return vx_core::t_connectmap;}

    vx_core::Type_typedef Class_connectmap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "connectmap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_connect}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_connectmap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type const)
  // class Class_const {
    Abstract_const::~Abstract_const() {}

    Class_const::Class_const() : Abstract_const::Abstract_const() {
      vx_core::refcount += 1;
    }

    Class_const::~Class_const() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_const::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_const, vals);
    }

    vx_core::Type_any Class_const::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_const output = vx_core::e_const;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_const::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_const::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_const::vx_empty() const {return vx_core::e_const;}
    vx_core::Type_any Class_const::vx_type() const {return vx_core::t_const;}

    vx_core::Type_typedef Class_const::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "const", // name
        ":const", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_const::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type constdef)
  // class Class_constdef {
    Abstract_constdef::~Abstract_constdef() {}

    Class_constdef::Class_constdef() : Abstract_constdef::Abstract_constdef() {
      vx_core::refcount += 1;
    }

    Class_constdef::~Class_constdef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_pkgname,
        this->vx_p_name,
        this->vx_p_type
      });
    }

    // pkgname()
    vx_core::Type_string Class_constdef::pkgname() const {
      vx_core::Type_string output = this->vx_p_pkgname;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // name()
    vx_core::Type_string Class_constdef::name() const {
      vx_core::Type_string output = this->vx_p_name;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // type()
    vx_core::Type_any Class_constdef::type() const {
      vx_core::Type_any output = this->vx_p_type;
      if (!output) {
        output = vx_core::e_any;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_constdef::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":pkgname") {
        output = this->pkgname();
      } else if (skey == ":name") {
        output = this->name();
      } else if (skey == ":type") {
        output = this->type();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_constdef::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":pkgname"] = this->pkgname();
      output[":name"] = this->name();
      output[":type"] = this->type();
      return output;
    }

    vx_core::Type_any Class_constdef::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_constdef, vals);
    }

    vx_core::Type_any Class_constdef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_constdef output = vx_core::e_constdef;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_constdef val = vx_core::vx_any_from_any(vx_core::t_constdef, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_pkgname = val->pkgname();
      vx_core::Type_string vx_p_name = val->name();
      vx_core::Type_any vx_p_type = val->type();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":pkgname") {
            key = testkey;
          } else if (testkey == ":name") {
            key = testkey;
          } else if (testkey == ":type") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new constdef) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":pkgname") {
            if (vx_p_pkgname == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_pkgname = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new constdef :pkgname " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":name") {
            if (vx_p_name == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_name = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new constdef :name " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":type") {
            if (vx_p_type != valsub) {
              ischanged = true;
              vx_p_type = valsub;
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new constdef) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_constdef();
        if (output->vx_p_pkgname != vx_p_pkgname) {
          if (output->vx_p_pkgname) {
            vx_core::vx_release_one(output->vx_p_pkgname);
          }
          output->vx_p_pkgname = vx_p_pkgname;
          vx_core::vx_reserve(vx_p_pkgname);
        }
        if (output->vx_p_name != vx_p_name) {
          if (output->vx_p_name) {
            vx_core::vx_release_one(output->vx_p_name);
          }
          output->vx_p_name = vx_p_name;
          vx_core::vx_reserve(vx_p_name);
        }
        if (output->vx_p_type != vx_p_type) {
          if (output->vx_p_type) {
            vx_core::vx_release_one(output->vx_p_type);
          }
          output->vx_p_type = vx_p_type;
          vx_core::vx_reserve(vx_p_type);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_constdef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_constdef::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_constdef::vx_empty() const {return vx_core::e_constdef;}
    vx_core::Type_any Class_constdef::vx_type() const {return vx_core::t_constdef;}

    vx_core::Type_typedef Class_constdef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "constdef", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "pkgname", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "name", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "type", // name
            vx_core::t_any // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_constdef::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type constlist)
  // class Class_constlist {
    Abstract_constlist::~Abstract_constlist() {}

    Class_constlist::Class_constlist() : Abstract_constlist::Abstract_constlist() {
      vx_core::refcount += 1;
    }

    Class_constlist::~Class_constlist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_constlist::vx_list() const {
      return this->vx_p_list;
    }

    // vx_get_any(index)
    vx_core::Type_any Class_constlist::vx_get_any(vx_core::Type_int index) const {
      vx_core::Type_any output = vx_core::e_any;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_any> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_constlist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_constlist output = vx_core::e_constlist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_any> list;
      for (auto const& valsub : listval) {
        list.push_back(valsub);
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_constlist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_constlist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_constlist, vals);
    }

    vx_core::Type_any Class_constlist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_constlist output = vx_core::e_constlist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_constlist val = vx_core::vx_any_from_any(vx_core::t_constlist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_any> listval = val->vx_list();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_constlist) {
          ischanged = true;
          vx_core::Type_constlist multi = vx_core::vx_any_from_any(vx_core::t_constlist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_list());
        } else {
          listval.push_back(valsub);
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_constlist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_constlist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_constlist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_constlist::vx_empty() const {return vx_core::e_constlist;}
    vx_core::Type_any Class_constlist::vx_type() const {return vx_core::t_constlist;}

    vx_core::Type_typedef Class_constlist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "constlist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_any}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_constlist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type constmap)
  // class Class_constmap {
    Abstract_constmap::~Abstract_constmap() {}

    Class_constmap::Class_constmap() : Abstract_constmap::Abstract_constmap() {
      vx_core::refcount += 1;
    }

    Class_constmap::~Class_constmap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_constmap::vx_map() const {
      vx_core::vx_Type_mapany output = this->vx_p_map;
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_constmap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_any) {
        vx_core::Type_any newval = vx_core::vx_any_from_any(vx_core::t_any, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_any oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_any) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_any(key)
    vx_core::Type_any Class_constmap::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      const vx_core::Class_constmap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_any> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_any);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_constmap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_constmap output = vx_core::e_constmap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_any> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        map[key] = val;
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_constmap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_constmap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_constmap, vals);
    }

    vx_core::Type_any Class_constmap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_constmap output = vx_core::e_constmap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_constmap valmap = vx_core::vx_any_from_any(vx_core::t_constmap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_any> mapval = valmap->vx_map();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_any valany = valsub;
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_constmap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_constmap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_constmap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_constmap::vx_empty() const {return vx_core::e_constmap;}
    vx_core::Type_any Class_constmap::vx_type() const {return vx_core::t_constmap;}

    vx_core::Type_typedef Class_constmap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "constmap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_any}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_constmap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type context)
  // class Class_context {
    Abstract_context::~Abstract_context() {}

    Class_context::Class_context() : Abstract_context::Abstract_context() {
      vx_core::refcount += 1;
    }

    Class_context::~Class_context() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_code,
        this->vx_p_session,
        this->vx_p_setting,
        this->vx_p_state
      });
    }

    // code()
    vx_core::Type_string Class_context::code() const {
      vx_core::Type_string output = this->vx_p_code;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // session()
    vx_core::Type_session Class_context::session() const {
      vx_core::Type_session output = this->vx_p_session;
      if (!output) {
        output = vx_core::e_session;
      }
      return output;
    }

    // setting()
    vx_core::Type_setting Class_context::setting() const {
      vx_core::Type_setting output = this->vx_p_setting;
      if (!output) {
        output = vx_core::e_setting;
      }
      return output;
    }

    // state()
    vx_core::Type_state Class_context::state() const {
      vx_core::Type_state output = this->vx_p_state;
      if (!output) {
        output = vx_core::e_state;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_context::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":code") {
        output = this->code();
      } else if (skey == ":session") {
        output = this->session();
      } else if (skey == ":setting") {
        output = this->setting();
      } else if (skey == ":state") {
        output = this->state();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_context::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":code"] = this->code();
      output[":session"] = this->session();
      output[":setting"] = this->setting();
      output[":state"] = this->state();
      return output;
    }

    vx_core::Type_any Class_context::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_context, vals);
    }

    vx_core::Type_any Class_context::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_context output = vx_core::e_context;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_context val = vx_core::vx_any_from_any(vx_core::t_context, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_code = val->code();
      vx_core::Type_session vx_p_session = val->session();
      vx_core::Type_setting vx_p_setting = val->setting();
      vx_core::Type_state vx_p_state = val->state();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":code") {
            key = testkey;
          } else if (testkey == ":session") {
            key = testkey;
          } else if (testkey == ":setting") {
            key = testkey;
          } else if (testkey == ":state") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new context) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":code") {
            if (vx_p_code == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_code = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new context :code " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":session") {
            if (vx_p_session == valsub) {
            } else if (valsubtype == vx_core::t_session) {
              ischanged = true;
              vx_p_session = vx_core::vx_any_from_any(vx_core::t_session, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new context :session " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":setting") {
            if (vx_p_setting == valsub) {
            } else if (valsubtype == vx_core::t_setting) {
              ischanged = true;
              vx_p_setting = vx_core::vx_any_from_any(vx_core::t_setting, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new context :setting " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":state") {
            if (vx_p_state == valsub) {
            } else if (valsubtype == vx_core::t_state) {
              ischanged = true;
              vx_p_state = vx_core::vx_any_from_any(vx_core::t_state, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new context :state " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new context) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_context();
        if (output->vx_p_code != vx_p_code) {
          if (output->vx_p_code) {
            vx_core::vx_release_one(output->vx_p_code);
          }
          output->vx_p_code = vx_p_code;
          vx_core::vx_reserve(vx_p_code);
        }
        if (output->vx_p_session != vx_p_session) {
          if (output->vx_p_session) {
            vx_core::vx_release_one(output->vx_p_session);
          }
          output->vx_p_session = vx_p_session;
          vx_core::vx_reserve(vx_p_session);
        }
        if (output->vx_p_setting != vx_p_setting) {
          if (output->vx_p_setting) {
            vx_core::vx_release_one(output->vx_p_setting);
          }
          output->vx_p_setting = vx_p_setting;
          vx_core::vx_reserve(vx_p_setting);
        }
        if (output->vx_p_state != vx_p_state) {
          if (output->vx_p_state) {
            vx_core::vx_release_one(output->vx_p_state);
          }
          output->vx_p_state = vx_p_state;
          vx_core::vx_reserve(vx_p_state);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_context::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_context::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_context::vx_empty() const {return vx_core::e_context;}
    vx_core::Type_any Class_context::vx_type() const {return vx_core::t_context;}

    vx_core::Type_typedef Class_context::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "context", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "code", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "session", // name
            vx_core::t_session // type
          ),
          vx_core::vx_new_arg(
            "setting", // name
            vx_core::t_setting // type
          ),
          vx_core::vx_new_arg(
            "state", // name
            vx_core::t_state // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_context::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type date)
  // class Class_date {
    Abstract_date::~Abstract_date() {}

    Class_date::Class_date() : Abstract_date::Abstract_date() {
      vx_core::refcount += 1;
    }

    Class_date::~Class_date() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_date::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_date, vals);
    }

    vx_core::Type_any Class_date::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_date output = vx_core::e_date;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_date::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_date::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_date::vx_empty() const {return vx_core::e_date;}
    vx_core::Type_any Class_date::vx_type() const {return vx_core::t_date;}

    vx_core::Type_typedef Class_date::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "date", // name
        ":string", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_date::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type error)
  // class Class_error {
    Abstract_error::~Abstract_error() {}

    Class_error::Class_error() : Abstract_error::Abstract_error() {
      vx_core::refcount += 1;
    }

    Class_error::~Class_error() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_error::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_error, vals);
    }

    vx_core::Type_any Class_error::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_error output = vx_core::e_error;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_error::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_error::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_error::vx_empty() const {return vx_core::e_error;}
    vx_core::Type_any Class_error::vx_type() const {return vx_core::t_error;}

    vx_core::Type_typedef Class_error::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "error", // name
        "", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_error::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type funclist)
  // class Class_funclist {
    Abstract_funclist::~Abstract_funclist() {}

    Class_funclist::Class_funclist() : Abstract_funclist::Abstract_funclist() {
      vx_core::refcount += 1;
    }

    Class_funclist::~Class_funclist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_funclist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_func Class_funclist::vx_get_func(vx_core::Type_int index) const {
      vx_core::Type_func output = vx_core::e_func;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_func> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_func> Class_funclist::vx_listfunc() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_funclist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_func(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_funclist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_funclist output = vx_core::e_funclist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_func> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_func) {
          vx_core::Type_func castval = vx_core::vx_any_from_any(vx_core::t_func, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_func)) {
          vx_core::Type_func castval = vx_core::vx_any_from_any(vx_core::t_func, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(funclist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_funclist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_funclist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_funclist, vals);
    }

    vx_core::Type_any Class_funclist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_funclist output = vx_core::e_funclist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_funclist val = vx_core::vx_any_from_any(vx_core::t_funclist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_func> listval = val->vx_listfunc();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_func) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_func, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_func)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_func, valsub));
        } else if (valsubtype == vx_core::t_funclist) {
          ischanged = true;
          vx_core::Type_funclist multi = vx_core::vx_any_from_any(vx_core::t_funclist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listfunc());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new funclist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_funclist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_funclist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_funclist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_funclist::vx_empty() const {return vx_core::e_funclist;}
    vx_core::Type_any Class_funclist::vx_type() const {return vx_core::t_funclist;}

    vx_core::Type_typedef Class_funclist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "funclist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_func}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_funclist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type funcmap)
  // class Class_funcmap {
    Abstract_funcmap::~Abstract_funcmap() {}

    Class_funcmap::Class_funcmap() : Abstract_funcmap::Abstract_funcmap() {
      vx_core::refcount += 1;
    }

    Class_funcmap::~Class_funcmap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_funcmap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_funcmap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_func) {
        vx_core::Type_func newval = vx_core::vx_any_from_any(vx_core::t_func, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_func oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_func) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_func(key)
    vx_core::Type_func Class_funcmap::vx_get_func(vx_core::Type_string key) const {
      vx_core::Type_func output = vx_core::e_func;
      const vx_core::Class_funcmap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_func> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_func);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_funcmap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_func(key);
    }

    // vx_mapfunc()
    std::map<std::string, vx_core::Type_func> Class_funcmap::vx_mapfunc() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_funcmap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_funcmap output = vx_core::e_funcmap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_func> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_func) {
          vx_core::Type_func castval = vx_core::vx_any_from_any(vx_core::t_func, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(funcmap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_funcmap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_funcmap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_funcmap, vals);
    }

    vx_core::Type_any Class_funcmap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_funcmap output = vx_core::e_funcmap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_funcmap valmap = vx_core::vx_any_from_any(vx_core::t_funcmap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_func> mapval = valmap->vx_mapfunc();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_func valany = NULL;
          if (valsubtype == vx_core::t_func) {
            valany = vx_core::vx_any_from_any(vx_core::t_func, valsub);
          } else if (valsubtype == vx_core::t_func) {
            valany = vx_core::vx_any_from_any(vx_core::t_func, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_funcmap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_funcmap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_funcmap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_funcmap::vx_empty() const {return vx_core::e_funcmap;}
    vx_core::Type_any Class_funcmap::vx_type() const {return vx_core::t_funcmap;}

    vx_core::Type_typedef Class_funcmap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "funcmap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_func}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_funcmap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type intlist)
  // class Class_intlist {
    Abstract_intlist::~Abstract_intlist() {}

    Class_intlist::Class_intlist() : Abstract_intlist::Abstract_intlist() {
      vx_core::refcount += 1;
    }

    Class_intlist::~Class_intlist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_intlist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_int Class_intlist::vx_get_int(vx_core::Type_int index) const {
      vx_core::Type_int output = vx_core::e_int;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_int> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_int> Class_intlist::vx_listint() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_intlist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_int(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_intlist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_intlist output = vx_core::e_intlist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_int> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_int) {
          vx_core::Type_int castval = vx_core::vx_any_from_any(vx_core::t_int, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_int)) {
          vx_core::Type_int castval = vx_core::vx_any_from_any(vx_core::t_int, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(intlist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_intlist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_intlist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_intlist, vals);
    }

    vx_core::Type_any Class_intlist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_intlist output = vx_core::e_intlist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_intlist val = vx_core::vx_any_from_any(vx_core::t_intlist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_int> listval = val->vx_listint();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_int) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_int, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_int)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_int, valsub));
        } else if (valsubtype == vx_core::t_intlist) {
          ischanged = true;
          vx_core::Type_intlist multi = vx_core::vx_any_from_any(vx_core::t_intlist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listint());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new intlist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_intlist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_intlist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_intlist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_intlist::vx_empty() const {return vx_core::e_intlist;}
    vx_core::Type_any Class_intlist::vx_type() const {return vx_core::t_intlist;}

    vx_core::Type_typedef Class_intlist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "intlist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_int}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_intlist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type intmap)
  // class Class_intmap {
    Abstract_intmap::~Abstract_intmap() {}

    Class_intmap::Class_intmap() : Abstract_intmap::Abstract_intmap() {
      vx_core::refcount += 1;
    }

    Class_intmap::~Class_intmap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_intmap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_intmap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_int) {
        vx_core::Type_int newval = vx_core::vx_any_from_any(vx_core::t_int, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_int oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_int) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_int(key)
    vx_core::Type_int Class_intmap::vx_get_int(vx_core::Type_string key) const {
      vx_core::Type_int output = vx_core::e_int;
      const vx_core::Class_intmap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_int> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_int);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_intmap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_int(key);
    }

    // vx_mapint()
    std::map<std::string, vx_core::Type_int> Class_intmap::vx_mapint() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_intmap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_intmap output = vx_core::e_intmap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_int> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_int) {
          vx_core::Type_int castval = vx_core::vx_any_from_any(vx_core::t_int, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(intmap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_intmap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_intmap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_intmap, vals);
    }

    vx_core::Type_any Class_intmap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_intmap output = vx_core::e_intmap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_intmap valmap = vx_core::vx_any_from_any(vx_core::t_intmap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_int> mapval = valmap->vx_mapint();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_int valany = NULL;
          if (valsubtype == vx_core::t_int) {
            valany = vx_core::vx_any_from_any(vx_core::t_int, valsub);
          } else if (valsubtype == vx_core::t_int) {
            valany = vx_core::vx_any_from_any(vx_core::t_int, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_intmap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_intmap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_intmap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_intmap::vx_empty() const {return vx_core::e_intmap;}
    vx_core::Type_any Class_intmap::vx_type() const {return vx_core::t_intmap;}

    vx_core::Type_typedef Class_intmap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "intmap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_int}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_intmap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type listtype)
  // class Class_listtype {
    Abstract_listtype::~Abstract_listtype() {}

    Class_listtype::Class_listtype() : Abstract_listtype::Abstract_listtype() {
      vx_core::refcount += 1;
    }

    Class_listtype::~Class_listtype() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_listtype::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_listtype, vals);
    }

    vx_core::Type_any Class_listtype::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_listtype output = vx_core::e_listtype;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_listtype::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_listtype::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_listtype::vx_empty() const {return vx_core::e_listtype;}
    vx_core::Type_any Class_listtype::vx_type() const {return vx_core::t_listtype;}

    vx_core::Type_typedef Class_listtype::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "listtype", // name
        ":type", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_listtype::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type locale)
  // class Class_locale {
    Abstract_locale::~Abstract_locale() {}

    Class_locale::Class_locale() : Abstract_locale::Abstract_locale() {
      vx_core::refcount += 1;
    }

    Class_locale::~Class_locale() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        
      });
    }

    // vx_get_any(key)
    vx_core::Type_any Class_locale::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_locale::vx_map() const {
      vx_core::vx_Type_mapany output;
      return output;
    }

    vx_core::Type_any Class_locale::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_locale, vals);
    }

    vx_core::Type_any Class_locale::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_locale output = vx_core::e_locale;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_locale val = vx_core::vx_any_from_any(vx_core::t_locale, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_locale::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_locale::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_locale::vx_empty() const {return vx_core::e_locale;}
    vx_core::Type_any Class_locale::vx_type() const {return vx_core::t_locale;}

    vx_core::Type_typedef Class_locale::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "locale", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_locale::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type maptype)
  // class Class_maptype {
    Abstract_maptype::~Abstract_maptype() {}

    Class_maptype::Class_maptype() : Abstract_maptype::Abstract_maptype() {
      vx_core::refcount += 1;
    }

    Class_maptype::~Class_maptype() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_maptype::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_maptype, vals);
    }

    vx_core::Type_any Class_maptype::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_maptype output = vx_core::e_maptype;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_maptype::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_maptype::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_maptype::vx_empty() const {return vx_core::e_maptype;}
    vx_core::Type_any Class_maptype::vx_type() const {return vx_core::t_maptype;}

    vx_core::Type_typedef Class_maptype::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "maptype", // name
        ":type", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_maptype::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type mempool)
  // class Class_mempool {
    Abstract_mempool::~Abstract_mempool() {}

    Class_mempool::Class_mempool() : Abstract_mempool::Abstract_mempool() {
      vx_core::refcount += 1;
    }

    Class_mempool::~Class_mempool() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_valuepool
      });
    }

    // valuepool()
    vx_core::Type_value Class_mempool::valuepool() const {
      vx_core::Type_value output = this->vx_p_valuepool;
      if (!output) {
        output = vx_core::e_value;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_mempool::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":valuepool") {
        output = this->valuepool();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_mempool::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":valuepool"] = this->valuepool();
      return output;
    }

    vx_core::Type_any Class_mempool::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_mempool, vals);
    }

    vx_core::Type_any Class_mempool::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_mempool output = vx_core::e_mempool;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_mempool val = vx_core::vx_any_from_any(vx_core::t_mempool, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_value vx_p_valuepool = val->valuepool();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":valuepool") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new mempool) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":valuepool") {
            if (vx_p_valuepool == valsub) {
            } else if (valsubtype == vx_core::t_value) {
              ischanged = true;
              vx_p_valuepool = vx_core::vx_any_from_any(vx_core::t_value, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new mempool :valuepool " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new mempool) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_mempool();
        if (output->vx_p_valuepool != vx_p_valuepool) {
          if (output->vx_p_valuepool) {
            vx_core::vx_release_one(output->vx_p_valuepool);
          }
          output->vx_p_valuepool = vx_p_valuepool;
          vx_core::vx_reserve(vx_p_valuepool);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_mempool::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_mempool::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_mempool::vx_empty() const {return vx_core::e_mempool;}
    vx_core::Type_any Class_mempool::vx_type() const {return vx_core::t_mempool;}

    vx_core::Type_typedef Class_mempool::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "mempool", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "valuepool", // name
            vx_core::t_value // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_mempool::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type none)
  // class Class_none {
    Abstract_none::~Abstract_none() {}

    Class_none::Class_none() : Abstract_none::Abstract_none() {
      vx_core::refcount += 1;
    }

    Class_none::~Class_none() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_none::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_none, vals);
    }

    vx_core::Type_any Class_none::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_none output = vx_core::e_none;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_none::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_none::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_none::vx_empty() const {return vx_core::e_none;}
    vx_core::Type_any Class_none::vx_type() const {return vx_core::t_none;}

    vx_core::Type_typedef Class_none::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "none", // name
        "", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_none::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type notype)
  // class Class_notype {
    Abstract_notype::~Abstract_notype() {}

    Class_notype::Class_notype() : Abstract_notype::Abstract_notype() {
      vx_core::refcount += 1;
    }

    Class_notype::~Class_notype() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_notype::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_notype, vals);
    }

    vx_core::Type_any Class_notype::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_notype output = vx_core::e_notype;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_notype::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_notype::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_notype::vx_empty() const {return vx_core::e_notype;}
    vx_core::Type_any Class_notype::vx_type() const {return vx_core::t_notype;}

    vx_core::Type_typedef Class_notype::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "notype", // name
        "", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_notype::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type numberlist)
  // class Class_numberlist {
    Abstract_numberlist::~Abstract_numberlist() {}

    Class_numberlist::Class_numberlist() : Abstract_numberlist::Abstract_numberlist() {
      vx_core::refcount += 1;
    }

    Class_numberlist::~Class_numberlist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_numberlist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_number Class_numberlist::vx_get_number(vx_core::Type_int index) const {
      vx_core::Type_number output = vx_core::e_number;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_number> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_number> Class_numberlist::vx_listnumber() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_numberlist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_number(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_numberlist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_numberlist output = vx_core::e_numberlist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_number> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_number) {
          vx_core::Type_number castval = vx_core::vx_any_from_any(vx_core::t_number, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_number)) {
          vx_core::Type_number castval = vx_core::vx_any_from_any(vx_core::t_number, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(numberlist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_numberlist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_numberlist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_numberlist, vals);
    }

    vx_core::Type_any Class_numberlist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_numberlist output = vx_core::e_numberlist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_numberlist val = vx_core::vx_any_from_any(vx_core::t_numberlist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_number> listval = val->vx_listnumber();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_number) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_number, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_number)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_number, valsub));
        } else if (valsubtype == vx_core::t_numberlist) {
          ischanged = true;
          vx_core::Type_numberlist multi = vx_core::vx_any_from_any(vx_core::t_numberlist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listnumber());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new numberlist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_numberlist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_numberlist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_numberlist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_numberlist::vx_empty() const {return vx_core::e_numberlist;}
    vx_core::Type_any Class_numberlist::vx_type() const {return vx_core::t_numberlist;}

    vx_core::Type_typedef Class_numberlist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "numberlist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_number}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_numberlist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type numbermap)
  // class Class_numbermap {
    Abstract_numbermap::~Abstract_numbermap() {}

    Class_numbermap::Class_numbermap() : Abstract_numbermap::Abstract_numbermap() {
      vx_core::refcount += 1;
    }

    Class_numbermap::~Class_numbermap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_numbermap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_numbermap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_number) {
        vx_core::Type_number newval = vx_core::vx_any_from_any(vx_core::t_number, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_number oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_number) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_number(key)
    vx_core::Type_number Class_numbermap::vx_get_number(vx_core::Type_string key) const {
      vx_core::Type_number output = vx_core::e_number;
      const vx_core::Class_numbermap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_number> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_number);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_numbermap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_number(key);
    }

    // vx_mapnumber()
    std::map<std::string, vx_core::Type_number> Class_numbermap::vx_mapnumber() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_numbermap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_numbermap output = vx_core::e_numbermap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_number> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_number) {
          vx_core::Type_number castval = vx_core::vx_any_from_any(vx_core::t_number, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(numbermap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_numbermap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_numbermap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_numbermap, vals);
    }

    vx_core::Type_any Class_numbermap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_numbermap output = vx_core::e_numbermap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_numbermap valmap = vx_core::vx_any_from_any(vx_core::t_numbermap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_number> mapval = valmap->vx_mapnumber();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_number valany = NULL;
          if (valsubtype == vx_core::t_number) {
            valany = vx_core::vx_any_from_any(vx_core::t_number, valsub);
          } else if (valsubtype == vx_core::t_number) {
            valany = vx_core::vx_any_from_any(vx_core::t_number, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_numbermap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_numbermap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_numbermap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_numbermap::vx_empty() const {return vx_core::e_numbermap;}
    vx_core::Type_any Class_numbermap::vx_type() const {return vx_core::t_numbermap;}

    vx_core::Type_typedef Class_numbermap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "numbermap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_number}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_numbermap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type package)
  // class Class_package {
    Abstract_package::~Abstract_package() {}

    Class_package::Class_package() : Abstract_package::Abstract_package() {
      vx_core::refcount += 1;
    }

    Class_package::~Class_package() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_pkgname,
        this->vx_p_constmap,
        this->vx_p_funcmap,
        this->vx_p_typemap,
        this->vx_p_emptymap
      });
    }

    // pkgname()
    vx_core::Type_string Class_package::pkgname() const {
      vx_core::Type_string output = this->vx_p_pkgname;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // constmap()
    vx_core::Type_constmap Class_package::constmap() const {
      vx_core::Type_constmap output = this->vx_p_constmap;
      if (!output) {
        output = vx_core::e_constmap;
      }
      return output;
    }

    // funcmap()
    vx_core::Type_funcmap Class_package::funcmap() const {
      vx_core::Type_funcmap output = this->vx_p_funcmap;
      if (!output) {
        output = vx_core::e_funcmap;
      }
      return output;
    }

    // typemap()
    vx_core::Type_typemap Class_package::typemap() const {
      vx_core::Type_typemap output = this->vx_p_typemap;
      if (!output) {
        output = vx_core::e_typemap;
      }
      return output;
    }

    // emptymap()
    vx_core::Type_map Class_package::emptymap() const {
      vx_core::Type_map output = this->vx_p_emptymap;
      if (!output) {
        output = vx_core::e_map;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_package::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":pkgname") {
        output = this->pkgname();
      } else if (skey == ":constmap") {
        output = this->constmap();
      } else if (skey == ":funcmap") {
        output = this->funcmap();
      } else if (skey == ":typemap") {
        output = this->typemap();
      } else if (skey == ":emptymap") {
        output = this->emptymap();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_package::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":pkgname"] = this->pkgname();
      output[":constmap"] = this->constmap();
      output[":funcmap"] = this->funcmap();
      output[":typemap"] = this->typemap();
      output[":emptymap"] = this->emptymap();
      return output;
    }

    vx_core::Type_any Class_package::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_package, vals);
    }

    vx_core::Type_any Class_package::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_package output = vx_core::e_package;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_package val = vx_core::vx_any_from_any(vx_core::t_package, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_pkgname = val->pkgname();
      vx_core::Type_constmap vx_p_constmap = val->constmap();
      vx_core::Type_funcmap vx_p_funcmap = val->funcmap();
      vx_core::Type_typemap vx_p_typemap = val->typemap();
      vx_core::Type_map vx_p_emptymap = val->emptymap();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":pkgname") {
            key = testkey;
          } else if (testkey == ":constmap") {
            key = testkey;
          } else if (testkey == ":funcmap") {
            key = testkey;
          } else if (testkey == ":typemap") {
            key = testkey;
          } else if (testkey == ":emptymap") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new package) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":pkgname") {
            if (vx_p_pkgname == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_pkgname = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new package :pkgname " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":constmap") {
            if (vx_p_constmap == valsub) {
            } else if (valsubtype == vx_core::t_constmap) {
              ischanged = true;
              vx_p_constmap = vx_core::vx_any_from_any(vx_core::t_constmap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new package :constmap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":funcmap") {
            if (vx_p_funcmap == valsub) {
            } else if (valsubtype == vx_core::t_funcmap) {
              ischanged = true;
              vx_p_funcmap = vx_core::vx_any_from_any(vx_core::t_funcmap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new package :funcmap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":typemap") {
            if (vx_p_typemap == valsub) {
            } else if (valsubtype == vx_core::t_typemap) {
              ischanged = true;
              vx_p_typemap = vx_core::vx_any_from_any(vx_core::t_typemap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new package :typemap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":emptymap") {
            if (vx_p_emptymap == valsub) {
            } else if (valsubtype == vx_core::t_map) {
              ischanged = true;
              vx_p_emptymap = vx_core::vx_any_from_any(vx_core::t_map, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new package :emptymap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new package) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_package();
        if (output->vx_p_pkgname != vx_p_pkgname) {
          if (output->vx_p_pkgname) {
            vx_core::vx_release_one(output->vx_p_pkgname);
          }
          output->vx_p_pkgname = vx_p_pkgname;
          vx_core::vx_reserve(vx_p_pkgname);
        }
        if (output->vx_p_constmap != vx_p_constmap) {
          if (output->vx_p_constmap) {
            vx_core::vx_release_one(output->vx_p_constmap);
          }
          output->vx_p_constmap = vx_p_constmap;
          vx_core::vx_reserve(vx_p_constmap);
        }
        if (output->vx_p_funcmap != vx_p_funcmap) {
          if (output->vx_p_funcmap) {
            vx_core::vx_release_one(output->vx_p_funcmap);
          }
          output->vx_p_funcmap = vx_p_funcmap;
          vx_core::vx_reserve(vx_p_funcmap);
        }
        if (output->vx_p_typemap != vx_p_typemap) {
          if (output->vx_p_typemap) {
            vx_core::vx_release_one(output->vx_p_typemap);
          }
          output->vx_p_typemap = vx_p_typemap;
          vx_core::vx_reserve(vx_p_typemap);
        }
        if (output->vx_p_emptymap != vx_p_emptymap) {
          if (output->vx_p_emptymap) {
            vx_core::vx_release_one(output->vx_p_emptymap);
          }
          output->vx_p_emptymap = vx_p_emptymap;
          vx_core::vx_reserve(vx_p_emptymap);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_package::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_package::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_package::vx_empty() const {return vx_core::e_package;}
    vx_core::Type_any Class_package::vx_type() const {return vx_core::t_package;}

    vx_core::Type_typedef Class_package::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "package", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "pkgname", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "constmap", // name
            vx_core::t_constmap // type
          ),
          vx_core::vx_new_arg(
            "funcmap", // name
            vx_core::t_funcmap // type
          ),
          vx_core::vx_new_arg(
            "typemap", // name
            vx_core::t_typemap // type
          ),
          vx_core::vx_new_arg(
            "emptymap", // name
            vx_core::t_map // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_package::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type packagemap)
  // class Class_packagemap {
    Abstract_packagemap::~Abstract_packagemap() {}

    Class_packagemap::Class_packagemap() : Abstract_packagemap::Abstract_packagemap() {
      vx_core::refcount += 1;
    }

    Class_packagemap::~Class_packagemap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_packagemap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_packagemap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_package) {
        vx_core::Type_package newval = vx_core::vx_any_from_any(vx_core::t_package, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_package oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_package) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_package(key)
    vx_core::Type_package Class_packagemap::vx_get_package(vx_core::Type_string key) const {
      vx_core::Type_package output = vx_core::e_package;
      const vx_core::Class_packagemap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_package> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_package);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_packagemap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_package(key);
    }

    // vx_mappackage()
    std::map<std::string, vx_core::Type_package> Class_packagemap::vx_mappackage() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_packagemap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_packagemap output = vx_core::e_packagemap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_package> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_package) {
          vx_core::Type_package castval = vx_core::vx_any_from_any(vx_core::t_package, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(packagemap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_packagemap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_packagemap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_packagemap, vals);
    }

    vx_core::Type_any Class_packagemap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_packagemap output = vx_core::e_packagemap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_packagemap valmap = vx_core::vx_any_from_any(vx_core::t_packagemap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_package> mapval = valmap->vx_mappackage();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_package valany = NULL;
          if (valsubtype == vx_core::t_package) {
            valany = vx_core::vx_any_from_any(vx_core::t_package, valsub);
          } else if (valsubtype == vx_core::t_package) {
            valany = vx_core::vx_any_from_any(vx_core::t_package, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_packagemap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_packagemap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_packagemap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_packagemap::vx_empty() const {return vx_core::e_packagemap;}
    vx_core::Type_any Class_packagemap::vx_type() const {return vx_core::t_packagemap;}

    vx_core::Type_typedef Class_packagemap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "packagemap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_package}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_packagemap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type permission)
  // class Class_permission {
    Abstract_permission::~Abstract_permission() {}

    Class_permission::Class_permission() : Abstract_permission::Abstract_permission() {
      vx_core::refcount += 1;
    }

    Class_permission::~Class_permission() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_id
      });
    }

    // id()
    vx_core::Type_string Class_permission::id() const {
      vx_core::Type_string output = this->vx_p_id;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_permission::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":id") {
        output = this->id();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_permission::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":id"] = this->id();
      return output;
    }

    vx_core::Type_any Class_permission::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_permission, vals);
    }

    vx_core::Type_any Class_permission::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_permission output = vx_core::e_permission;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_permission val = vx_core::vx_any_from_any(vx_core::t_permission, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_id = val->id();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":id") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new permission) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":id") {
            if (vx_p_id == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_id = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new permission :id " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new permission) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_permission();
        if (output->vx_p_id != vx_p_id) {
          if (output->vx_p_id) {
            vx_core::vx_release_one(output->vx_p_id);
          }
          output->vx_p_id = vx_p_id;
          vx_core::vx_reserve(vx_p_id);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_permission::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_permission::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_permission::vx_empty() const {return vx_core::e_permission;}
    vx_core::Type_any Class_permission::vx_type() const {return vx_core::t_permission;}

    vx_core::Type_typedef Class_permission::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "permission", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "id", // name
            vx_core::t_string // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_permission::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type permissionlist)
  // class Class_permissionlist {
    Abstract_permissionlist::~Abstract_permissionlist() {}

    Class_permissionlist::Class_permissionlist() : Abstract_permissionlist::Abstract_permissionlist() {
      vx_core::refcount += 1;
    }

    Class_permissionlist::~Class_permissionlist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_permissionlist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_permission Class_permissionlist::vx_get_permission(vx_core::Type_int index) const {
      vx_core::Type_permission output = vx_core::e_permission;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_permission> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_permission> Class_permissionlist::vx_listpermission() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_permissionlist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_permission(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_permissionlist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_permissionlist output = vx_core::e_permissionlist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_permission> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_permission) {
          vx_core::Type_permission castval = vx_core::vx_any_from_any(vx_core::t_permission, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_permission)) {
          vx_core::Type_permission castval = vx_core::vx_any_from_any(vx_core::t_permission, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(permissionlist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_permissionlist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_permissionlist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_permissionlist, vals);
    }

    vx_core::Type_any Class_permissionlist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_permissionlist output = vx_core::e_permissionlist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_permissionlist val = vx_core::vx_any_from_any(vx_core::t_permissionlist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_permission> listval = val->vx_listpermission();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_permission) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_permission, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_permission)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_permission, valsub));
        } else if (valsubtype == vx_core::t_permissionlist) {
          ischanged = true;
          vx_core::Type_permissionlist multi = vx_core::vx_any_from_any(vx_core::t_permissionlist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listpermission());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new permissionlist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_permissionlist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_permissionlist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_permissionlist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_permissionlist::vx_empty() const {return vx_core::e_permissionlist;}
    vx_core::Type_any Class_permissionlist::vx_type() const {return vx_core::t_permissionlist;}

    vx_core::Type_typedef Class_permissionlist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "permissionlist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_permission}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_permissionlist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type permissionmap)
  // class Class_permissionmap {
    Abstract_permissionmap::~Abstract_permissionmap() {}

    Class_permissionmap::Class_permissionmap() : Abstract_permissionmap::Abstract_permissionmap() {
      vx_core::refcount += 1;
    }

    Class_permissionmap::~Class_permissionmap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_permissionmap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_permissionmap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_permission) {
        vx_core::Type_permission newval = vx_core::vx_any_from_any(vx_core::t_permission, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_permission oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_permission) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_permission(key)
    vx_core::Type_permission Class_permissionmap::vx_get_permission(vx_core::Type_string key) const {
      vx_core::Type_permission output = vx_core::e_permission;
      const vx_core::Class_permissionmap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_permission> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_permission);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_permissionmap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_permission(key);
    }

    // vx_mappermission()
    std::map<std::string, vx_core::Type_permission> Class_permissionmap::vx_mappermission() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_permissionmap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_permissionmap output = vx_core::e_permissionmap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_permission> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_permission) {
          vx_core::Type_permission castval = vx_core::vx_any_from_any(vx_core::t_permission, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(permissionmap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_permissionmap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_permissionmap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_permissionmap, vals);
    }

    vx_core::Type_any Class_permissionmap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_permissionmap output = vx_core::e_permissionmap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_permissionmap valmap = vx_core::vx_any_from_any(vx_core::t_permissionmap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_permission> mapval = valmap->vx_mappermission();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_permission valany = NULL;
          if (valsubtype == vx_core::t_permission) {
            valany = vx_core::vx_any_from_any(vx_core::t_permission, valsub);
          } else if (valsubtype == vx_core::t_permission) {
            valany = vx_core::vx_any_from_any(vx_core::t_permission, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_permissionmap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_permissionmap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_permissionmap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_permissionmap::vx_empty() const {return vx_core::e_permissionmap;}
    vx_core::Type_any Class_permissionmap::vx_type() const {return vx_core::t_permissionmap;}

    vx_core::Type_typedef Class_permissionmap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "permissionmap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_permission}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_permissionmap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type project)
  // class Class_project {
    Abstract_project::~Abstract_project() {}

    Class_project::Class_project() : Abstract_project::Abstract_project() {
      vx_core::refcount += 1;
    }

    Class_project::~Class_project() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_packagemap
      });
    }

    // packagemap()
    vx_core::Type_packagemap Class_project::packagemap() const {
      vx_core::Type_packagemap output = this->vx_p_packagemap;
      if (!output) {
        output = vx_core::e_packagemap;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_project::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":packagemap") {
        output = this->packagemap();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_project::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":packagemap"] = this->packagemap();
      return output;
    }

    vx_core::Type_any Class_project::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_project, vals);
    }

    vx_core::Type_any Class_project::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_project output = vx_core::e_project;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_project val = vx_core::vx_any_from_any(vx_core::t_project, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_packagemap vx_p_packagemap = val->packagemap();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":packagemap") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new project) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":packagemap") {
            if (vx_p_packagemap == valsub) {
            } else if (valsubtype == vx_core::t_packagemap) {
              ischanged = true;
              vx_p_packagemap = vx_core::vx_any_from_any(vx_core::t_packagemap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new project :packagemap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new project) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_project();
        if (output->vx_p_packagemap != vx_p_packagemap) {
          if (output->vx_p_packagemap) {
            vx_core::vx_release_one(output->vx_p_packagemap);
          }
          output->vx_p_packagemap = vx_p_packagemap;
          vx_core::vx_reserve(vx_p_packagemap);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_project::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_project::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_project::vx_empty() const {return vx_core::e_project;}
    vx_core::Type_any Class_project::vx_type() const {return vx_core::t_project;}

    vx_core::Type_typedef Class_project::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "project", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "packagemap", // name
            vx_core::t_packagemap // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_project::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type security)
  // class Class_security {
    Abstract_security::~Abstract_security() {}

    Class_security::Class_security() : Abstract_security::Abstract_security() {
      vx_core::refcount += 1;
    }

    Class_security::~Class_security() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_allowfuncs,
        this->vx_p_permissions,
        this->vx_p_permissionmap
      });
    }

    // allowfuncs()
    vx_core::Type_funclist Class_security::allowfuncs() const {
      vx_core::Type_funclist output = this->vx_p_allowfuncs;
      if (!output) {
        output = vx_core::e_funclist;
      }
      return output;
    }

    // permissions()
    vx_core::Type_permissionlist Class_security::permissions() const {
      vx_core::Type_permissionlist output = this->vx_p_permissions;
      if (!output) {
        output = vx_core::e_permissionlist;
      }
      return output;
    }

    // permissionmap()
    vx_core::Type_permissionmap Class_security::permissionmap() const {
      vx_core::Type_permissionmap output = this->vx_p_permissionmap;
      if (!output) {
        output = vx_core::e_permissionmap;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_security::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":allowfuncs") {
        output = this->allowfuncs();
      } else if (skey == ":permissions") {
        output = this->permissions();
      } else if (skey == ":permissionmap") {
        output = this->permissionmap();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_security::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":allowfuncs"] = this->allowfuncs();
      output[":permissions"] = this->permissions();
      output[":permissionmap"] = this->permissionmap();
      return output;
    }

    vx_core::Type_any Class_security::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_security, vals);
    }

    vx_core::Type_any Class_security::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_security output = vx_core::e_security;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_security val = vx_core::vx_any_from_any(vx_core::t_security, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_funclist vx_p_allowfuncs = val->allowfuncs();
      vx_core::Type_permissionlist vx_p_permissions = val->permissions();
      vx_core::Type_permissionmap vx_p_permissionmap = val->permissionmap();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":allowfuncs") {
            key = testkey;
          } else if (testkey == ":permissions") {
            key = testkey;
          } else if (testkey == ":permissionmap") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new security) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":allowfuncs") {
            if (vx_p_allowfuncs == valsub) {
            } else if (valsubtype == vx_core::t_funclist) {
              ischanged = true;
              vx_p_allowfuncs = vx_core::vx_any_from_any(vx_core::t_funclist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new security :allowfuncs " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":permissions") {
            if (vx_p_permissions == valsub) {
            } else if (valsubtype == vx_core::t_permissionlist) {
              ischanged = true;
              vx_p_permissions = vx_core::vx_any_from_any(vx_core::t_permissionlist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new security :permissions " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":permissionmap") {
            if (vx_p_permissionmap == valsub) {
            } else if (valsubtype == vx_core::t_permissionmap) {
              ischanged = true;
              vx_p_permissionmap = vx_core::vx_any_from_any(vx_core::t_permissionmap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new security :permissionmap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new security) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_security();
        if (output->vx_p_allowfuncs != vx_p_allowfuncs) {
          if (output->vx_p_allowfuncs) {
            vx_core::vx_release_one(output->vx_p_allowfuncs);
          }
          output->vx_p_allowfuncs = vx_p_allowfuncs;
          vx_core::vx_reserve(vx_p_allowfuncs);
        }
        if (output->vx_p_permissions != vx_p_permissions) {
          if (output->vx_p_permissions) {
            vx_core::vx_release_one(output->vx_p_permissions);
          }
          output->vx_p_permissions = vx_p_permissions;
          vx_core::vx_reserve(vx_p_permissions);
        }
        if (output->vx_p_permissionmap != vx_p_permissionmap) {
          if (output->vx_p_permissionmap) {
            vx_core::vx_release_one(output->vx_p_permissionmap);
          }
          output->vx_p_permissionmap = vx_p_permissionmap;
          vx_core::vx_reserve(vx_p_permissionmap);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_security::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_security::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_security::vx_empty() const {return vx_core::e_security;}
    vx_core::Type_any Class_security::vx_type() const {return vx_core::t_security;}

    vx_core::Type_typedef Class_security::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "security", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "allowfuncs", // name
            vx_core::t_funclist // type
          ),
          vx_core::vx_new_arg(
            "permissions", // name
            vx_core::t_permissionlist // type
          ),
          vx_core::vx_new_arg(
            "permissionmap", // name
            vx_core::t_permissionmap // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_security::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type session)
  // class Class_session {
    Abstract_session::~Abstract_session() {}

    Class_session::Class_session() : Abstract_session::Abstract_session() {
      vx_core::refcount += 1;
    }

    Class_session::~Class_session() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_user,
        this->vx_p_connectlist,
        this->vx_p_connectmap,
        this->vx_p_locale,
        this->vx_p_translation,
        this->vx_p_translationmap
      });
    }

    // user()
    vx_core::Type_user Class_session::user() const {
      vx_core::Type_user output = this->vx_p_user;
      if (!output) {
        output = vx_core::e_user;
      }
      return output;
    }

    // connectlist()
    vx_core::Type_connectlist Class_session::connectlist() const {
      vx_core::Type_connectlist output = this->vx_p_connectlist;
      if (!output) {
        output = vx_core::e_connectlist;
      }
      return output;
    }

    // connectmap()
    vx_core::Type_connectmap Class_session::connectmap() const {
      vx_core::Type_connectmap output = this->vx_p_connectmap;
      if (!output) {
        output = vx_core::e_connectmap;
      }
      return output;
    }

    // locale()
    vx_core::Type_locale Class_session::locale() const {
      vx_core::Type_locale output = this->vx_p_locale;
      if (!output) {
        output = vx_core::e_locale;
      }
      return output;
    }

    // translation()
    vx_core::Type_translation Class_session::translation() const {
      vx_core::Type_translation output = this->vx_p_translation;
      if (!output) {
        output = vx_core::e_translation;
      }
      return output;
    }

    // translationmap()
    vx_core::Type_translationmap Class_session::translationmap() const {
      vx_core::Type_translationmap output = this->vx_p_translationmap;
      if (!output) {
        output = vx_core::e_translationmap;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_session::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":user") {
        output = this->user();
      } else if (skey == ":connectlist") {
        output = this->connectlist();
      } else if (skey == ":connectmap") {
        output = this->connectmap();
      } else if (skey == ":locale") {
        output = this->locale();
      } else if (skey == ":translation") {
        output = this->translation();
      } else if (skey == ":translationmap") {
        output = this->translationmap();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_session::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":user"] = this->user();
      output[":connectlist"] = this->connectlist();
      output[":connectmap"] = this->connectmap();
      output[":locale"] = this->locale();
      output[":translation"] = this->translation();
      output[":translationmap"] = this->translationmap();
      return output;
    }

    vx_core::Type_any Class_session::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_session, vals);
    }

    vx_core::Type_any Class_session::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_session output = vx_core::e_session;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_session val = vx_core::vx_any_from_any(vx_core::t_session, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_user vx_p_user = val->user();
      vx_core::Type_connectlist vx_p_connectlist = val->connectlist();
      vx_core::Type_connectmap vx_p_connectmap = val->connectmap();
      vx_core::Type_locale vx_p_locale = val->locale();
      vx_core::Type_translation vx_p_translation = val->translation();
      vx_core::Type_translationmap vx_p_translationmap = val->translationmap();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":user") {
            key = testkey;
          } else if (testkey == ":connectlist") {
            key = testkey;
          } else if (testkey == ":connectmap") {
            key = testkey;
          } else if (testkey == ":locale") {
            key = testkey;
          } else if (testkey == ":translation") {
            key = testkey;
          } else if (testkey == ":translationmap") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new session) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":user") {
            if (vx_p_user == valsub) {
            } else if (valsubtype == vx_core::t_user) {
              ischanged = true;
              vx_p_user = vx_core::vx_any_from_any(vx_core::t_user, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new session :user " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":connectlist") {
            if (vx_p_connectlist == valsub) {
            } else if (valsubtype == vx_core::t_connectlist) {
              ischanged = true;
              vx_p_connectlist = vx_core::vx_any_from_any(vx_core::t_connectlist, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new session :connectlist " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":connectmap") {
            if (vx_p_connectmap == valsub) {
            } else if (valsubtype == vx_core::t_connectmap) {
              ischanged = true;
              vx_p_connectmap = vx_core::vx_any_from_any(vx_core::t_connectmap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new session :connectmap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":locale") {
            if (vx_p_locale == valsub) {
            } else if (valsubtype == vx_core::t_locale) {
              ischanged = true;
              vx_p_locale = vx_core::vx_any_from_any(vx_core::t_locale, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new session :locale " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":translation") {
            if (vx_p_translation == valsub) {
            } else if (valsubtype == vx_core::t_translation) {
              ischanged = true;
              vx_p_translation = vx_core::vx_any_from_any(vx_core::t_translation, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new session :translation " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":translationmap") {
            if (vx_p_translationmap == valsub) {
            } else if (valsubtype == vx_core::t_translationmap) {
              ischanged = true;
              vx_p_translationmap = vx_core::vx_any_from_any(vx_core::t_translationmap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new session :translationmap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new session) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_session();
        if (output->vx_p_user != vx_p_user) {
          if (output->vx_p_user) {
            vx_core::vx_release_one(output->vx_p_user);
          }
          output->vx_p_user = vx_p_user;
          vx_core::vx_reserve(vx_p_user);
        }
        if (output->vx_p_connectlist != vx_p_connectlist) {
          if (output->vx_p_connectlist) {
            vx_core::vx_release_one(output->vx_p_connectlist);
          }
          output->vx_p_connectlist = vx_p_connectlist;
          vx_core::vx_reserve(vx_p_connectlist);
        }
        if (output->vx_p_connectmap != vx_p_connectmap) {
          if (output->vx_p_connectmap) {
            vx_core::vx_release_one(output->vx_p_connectmap);
          }
          output->vx_p_connectmap = vx_p_connectmap;
          vx_core::vx_reserve(vx_p_connectmap);
        }
        if (output->vx_p_locale != vx_p_locale) {
          if (output->vx_p_locale) {
            vx_core::vx_release_one(output->vx_p_locale);
          }
          output->vx_p_locale = vx_p_locale;
          vx_core::vx_reserve(vx_p_locale);
        }
        if (output->vx_p_translation != vx_p_translation) {
          if (output->vx_p_translation) {
            vx_core::vx_release_one(output->vx_p_translation);
          }
          output->vx_p_translation = vx_p_translation;
          vx_core::vx_reserve(vx_p_translation);
        }
        if (output->vx_p_translationmap != vx_p_translationmap) {
          if (output->vx_p_translationmap) {
            vx_core::vx_release_one(output->vx_p_translationmap);
          }
          output->vx_p_translationmap = vx_p_translationmap;
          vx_core::vx_reserve(vx_p_translationmap);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_session::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_session::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_session::vx_empty() const {return vx_core::e_session;}
    vx_core::Type_any Class_session::vx_type() const {return vx_core::t_session;}

    vx_core::Type_typedef Class_session::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "session", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "user", // name
            vx_core::t_user // type
          ),
          vx_core::vx_new_arg(
            "connectlist", // name
            vx_core::t_connectlist // type
          ),
          vx_core::vx_new_arg(
            "connectmap", // name
            vx_core::t_connectmap // type
          ),
          vx_core::vx_new_arg(
            "locale", // name
            vx_core::t_locale // type
          ),
          vx_core::vx_new_arg(
            "translation", // name
            vx_core::t_translation // type
          ),
          vx_core::vx_new_arg(
            "translationmap", // name
            vx_core::t_translationmap // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_session::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type setting)
  // class Class_setting {
    Abstract_setting::~Abstract_setting() {}

    Class_setting::Class_setting() : Abstract_setting::Abstract_setting() {
      vx_core::refcount += 1;
    }

    Class_setting::~Class_setting() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_pathmap
      });
    }

    // pathmap()
    vx_core::Type_stringmap Class_setting::pathmap() const {
      vx_core::Type_stringmap output = this->vx_p_pathmap;
      if (!output) {
        output = vx_core::e_stringmap;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_setting::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":pathmap") {
        output = this->pathmap();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_setting::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":pathmap"] = this->pathmap();
      return output;
    }

    vx_core::Type_any Class_setting::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_setting, vals);
    }

    vx_core::Type_any Class_setting::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_setting output = vx_core::e_setting;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_setting val = vx_core::vx_any_from_any(vx_core::t_setting, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_stringmap vx_p_pathmap = val->pathmap();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":pathmap") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new setting) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":pathmap") {
            if (vx_p_pathmap == valsub) {
            } else if (valsubtype == vx_core::t_stringmap) {
              ischanged = true;
              vx_p_pathmap = vx_core::vx_any_from_any(vx_core::t_stringmap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new setting :pathmap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new setting) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_setting();
        if (output->vx_p_pathmap != vx_p_pathmap) {
          if (output->vx_p_pathmap) {
            vx_core::vx_release_one(output->vx_p_pathmap);
          }
          output->vx_p_pathmap = vx_p_pathmap;
          vx_core::vx_reserve(vx_p_pathmap);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_setting::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_setting::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_setting::vx_empty() const {return vx_core::e_setting;}
    vx_core::Type_any Class_setting::vx_type() const {return vx_core::t_setting;}

    vx_core::Type_typedef Class_setting::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "setting", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "pathmap", // name
            vx_core::t_stringmap // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_setting::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type state)
  // class Class_state {
    Abstract_state::~Abstract_state() {}

    Class_state::Class_state() : Abstract_state::Abstract_state() {
      vx_core::refcount += 1;
    }

    Class_state::~Class_state() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_statelistenermap
      });
    }

    // statelistenermap()
    vx_core::Type_statelistenermap Class_state::statelistenermap() const {
      vx_core::Type_statelistenermap output = this->vx_p_statelistenermap;
      if (!output) {
        output = vx_core::e_statelistenermap;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_state::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":statelistenermap") {
        output = this->statelistenermap();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_state::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":statelistenermap"] = this->statelistenermap();
      return output;
    }

    vx_core::Type_any Class_state::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_state, vals);
    }

    vx_core::Type_any Class_state::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_state output = vx_core::e_state;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_state val = vx_core::vx_any_from_any(vx_core::t_state, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_statelistenermap vx_p_statelistenermap = val->statelistenermap();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":statelistenermap") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new state) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":statelistenermap") {
            if (vx_p_statelistenermap == valsub) {
            } else if (valsubtype == vx_core::t_statelistenermap) {
              ischanged = true;
              vx_p_statelistenermap = vx_core::vx_any_from_any(vx_core::t_statelistenermap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new state :statelistenermap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new state) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_state();
        if (output->vx_p_statelistenermap != vx_p_statelistenermap) {
          if (output->vx_p_statelistenermap) {
            vx_core::vx_release_one(output->vx_p_statelistenermap);
          }
          output->vx_p_statelistenermap = vx_p_statelistenermap;
          vx_core::vx_reserve(vx_p_statelistenermap);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_state::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_state::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_state::vx_empty() const {return vx_core::e_state;}
    vx_core::Type_any Class_state::vx_type() const {return vx_core::t_state;}

    vx_core::Type_typedef Class_state::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "state", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "statelistenermap", // name
            vx_core::t_statelistenermap // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_state::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type statelistener)
  // class Class_statelistener {
    Abstract_statelistener::~Abstract_statelistener() {}

    Class_statelistener::Class_statelistener() : Abstract_statelistener::Abstract_statelistener() {
      vx_core::refcount += 1;
    }

    Class_statelistener::~Class_statelistener() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_name,
        this->vx_p_value,
        this->vx_p_fn_boolean
      });
    }

    // name()
    vx_core::Type_string Class_statelistener::name() const {
      vx_core::Type_string output = this->vx_p_name;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // value()
    vx_core::Type_any Class_statelistener::value() const {
      vx_core::Type_any output = this->vx_p_value;
      if (!output) {
        output = vx_core::e_any;
      }
      return output;
    }

    // fn_boolean()
    vx_core::Func_boolean_from_none Class_statelistener::fn_boolean() const {
      vx_core::Func_boolean_from_none output = this->vx_p_fn_boolean;
      if (!output) {
        output = vx_core::e_boolean_from_none;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_statelistener::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":name") {
        output = this->name();
      } else if (skey == ":value") {
        output = this->value();
      } else if (skey == ":fn-boolean") {
        output = this->fn_boolean();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_statelistener::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":name"] = this->name();
      output[":value"] = this->value();
      output[":fn-boolean"] = this->fn_boolean();
      return output;
    }

    vx_core::Type_any Class_statelistener::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_statelistener, vals);
    }

    vx_core::Type_any Class_statelistener::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_statelistener output = vx_core::e_statelistener;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_statelistener val = vx_core::vx_any_from_any(vx_core::t_statelistener, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_name = val->name();
      vx_core::Type_any vx_p_value = val->value();
      vx_core::Func_boolean_from_none vx_p_fn_boolean = val->fn_boolean();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":name") {
            key = testkey;
          } else if (testkey == ":value") {
            key = testkey;
          } else if (testkey == ":fn-boolean") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new statelistener) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":name") {
            if (vx_p_name == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_name = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new statelistener :name " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":value") {
            if (vx_p_value != valsub) {
              ischanged = true;
              vx_p_value = valsub;
            }
          } else if (key == ":fn-boolean") {
            if (vx_p_fn_boolean == valsub) {
            } else if (valsubtype == vx_core::t_boolean_from_none) {
              ischanged = true;
              vx_p_fn_boolean = vx_core::vx_any_from_any(vx_core::t_boolean_from_none, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new statelistener :fn-boolean " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new statelistener) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_statelistener();
        if (output->vx_p_name != vx_p_name) {
          if (output->vx_p_name) {
            vx_core::vx_release_one(output->vx_p_name);
          }
          output->vx_p_name = vx_p_name;
          vx_core::vx_reserve(vx_p_name);
        }
        if (output->vx_p_value != vx_p_value) {
          if (output->vx_p_value) {
            vx_core::vx_release_one(output->vx_p_value);
          }
          output->vx_p_value = vx_p_value;
          vx_core::vx_reserve(vx_p_value);
        }
        if (output->vx_p_fn_boolean != vx_p_fn_boolean) {
          if (output->vx_p_fn_boolean) {
            vx_core::vx_release_one(output->vx_p_fn_boolean);
          }
          output->vx_p_fn_boolean = vx_p_fn_boolean;
          vx_core::vx_reserve(vx_p_fn_boolean);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_statelistener::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_statelistener::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_statelistener::vx_empty() const {return vx_core::e_statelistener;}
    vx_core::Type_any Class_statelistener::vx_type() const {return vx_core::t_statelistener;}

    vx_core::Type_typedef Class_statelistener::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "statelistener", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "name", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "value", // name
            vx_core::t_any // type
          ),
          vx_core::vx_new_arg(
            "fn-boolean", // name
            vx_core::t_boolean_from_none // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_statelistener::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type statelistenermap)
  // class Class_statelistenermap {
    Abstract_statelistenermap::~Abstract_statelistenermap() {}

    Class_statelistenermap::Class_statelistenermap() : Abstract_statelistenermap::Abstract_statelistenermap() {
      vx_core::refcount += 1;
    }

    Class_statelistenermap::~Class_statelistenermap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_statelistenermap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_statelistenermap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_statelistener) {
        vx_core::Type_statelistener newval = vx_core::vx_any_from_any(vx_core::t_statelistener, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_statelistener oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_statelistener) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_statelistener(key)
    vx_core::Type_statelistener Class_statelistenermap::vx_get_statelistener(vx_core::Type_string key) const {
      vx_core::Type_statelistener output = vx_core::e_statelistener;
      const vx_core::Class_statelistenermap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_statelistener> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_statelistener);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_statelistenermap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_statelistener(key);
    }

    // vx_mapstatelistener()
    std::map<std::string, vx_core::Type_statelistener> Class_statelistenermap::vx_mapstatelistener() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_statelistenermap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_statelistenermap output = vx_core::e_statelistenermap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_statelistener> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_statelistener) {
          vx_core::Type_statelistener castval = vx_core::vx_any_from_any(vx_core::t_statelistener, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(statelistenermap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_statelistenermap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_statelistenermap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_statelistenermap, vals);
    }

    vx_core::Type_any Class_statelistenermap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_statelistenermap output = vx_core::e_statelistenermap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_statelistenermap valmap = vx_core::vx_any_from_any(vx_core::t_statelistenermap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_statelistener> mapval = valmap->vx_mapstatelistener();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_statelistener valany = NULL;
          if (valsubtype == vx_core::t_statelistener) {
            valany = vx_core::vx_any_from_any(vx_core::t_statelistener, valsub);
          } else if (valsubtype == vx_core::t_statelistener) {
            valany = vx_core::vx_any_from_any(vx_core::t_statelistener, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_statelistenermap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_statelistenermap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_statelistenermap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_statelistenermap::vx_empty() const {return vx_core::e_statelistenermap;}
    vx_core::Type_any Class_statelistenermap::vx_type() const {return vx_core::t_statelistenermap;}

    vx_core::Type_typedef Class_statelistenermap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "statelistenermap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_statelistener}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_statelistenermap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type stringlist)
  // class Class_stringlist {
    Abstract_stringlist::~Abstract_stringlist() {}

    Class_stringlist::Class_stringlist() : Abstract_stringlist::Abstract_stringlist() {
      vx_core::refcount += 1;
    }

    Class_stringlist::~Class_stringlist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_stringlist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_string Class_stringlist::vx_get_string(vx_core::Type_int index) const {
      vx_core::Type_string output = vx_core::e_string;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_string> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_string> Class_stringlist::vx_liststring() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_stringlist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_string(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_stringlist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_stringlist output = vx_core::e_stringlist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_string> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_string) {
          vx_core::Type_string castval = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_string)) {
          vx_core::Type_string castval = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(stringlist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_stringlist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_stringlist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_stringlist, vals);
    }

    vx_core::Type_any Class_stringlist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_stringlist output = vx_core::e_stringlist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_stringlist val = vx_core::vx_any_from_any(vx_core::t_stringlist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_string> listval = val->vx_liststring();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_string) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_string, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_string)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_string, valsub));
        } else if (valsubtype == vx_core::t_stringlist) {
          ischanged = true;
          vx_core::Type_stringlist multi = vx_core::vx_any_from_any(vx_core::t_stringlist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_liststring());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new stringlist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_stringlist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_stringlist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_stringlist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_stringlist::vx_empty() const {return vx_core::e_stringlist;}
    vx_core::Type_any Class_stringlist::vx_type() const {return vx_core::t_stringlist;}

    vx_core::Type_typedef Class_stringlist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "stringlist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_string}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_stringlist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type stringlistlist)
  // class Class_stringlistlist {
    Abstract_stringlistlist::~Abstract_stringlistlist() {}

    Class_stringlistlist::Class_stringlistlist() : Abstract_stringlistlist::Abstract_stringlistlist() {
      vx_core::refcount += 1;
    }

    Class_stringlistlist::~Class_stringlistlist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_stringlistlist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_stringlist Class_stringlistlist::vx_get_stringlist(vx_core::Type_int index) const {
      vx_core::Type_stringlist output = vx_core::e_stringlist;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_stringlist> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_stringlist> Class_stringlistlist::vx_liststringlist() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_stringlistlist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_stringlist(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_stringlistlist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_stringlistlist output = vx_core::e_stringlistlist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_stringlist> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_stringlist) {
          vx_core::Type_stringlist castval = vx_core::vx_any_from_any(vx_core::t_stringlist, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_stringlist)) {
          vx_core::Type_stringlist castval = vx_core::vx_any_from_any(vx_core::t_stringlist, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(stringlistlist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_stringlistlist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_stringlistlist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_stringlistlist, vals);
    }

    vx_core::Type_any Class_stringlistlist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_stringlistlist output = vx_core::e_stringlistlist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_stringlistlist val = vx_core::vx_any_from_any(vx_core::t_stringlistlist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_stringlist> listval = val->vx_liststringlist();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_stringlist) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_stringlist, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_stringlist)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_stringlist, valsub));
        } else if (valsubtype == vx_core::t_stringlistlist) {
          ischanged = true;
          vx_core::Type_stringlistlist multi = vx_core::vx_any_from_any(vx_core::t_stringlistlist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_liststringlist());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new stringlistlist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_stringlistlist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_stringlistlist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_stringlistlist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_stringlistlist::vx_empty() const {return vx_core::e_stringlistlist;}
    vx_core::Type_any Class_stringlistlist::vx_type() const {return vx_core::t_stringlistlist;}

    vx_core::Type_typedef Class_stringlistlist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "stringlistlist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_stringlist}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_stringlistlist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type stringmap)
  // class Class_stringmap {
    Abstract_stringmap::~Abstract_stringmap() {}

    Class_stringmap::Class_stringmap() : Abstract_stringmap::Abstract_stringmap() {
      vx_core::refcount += 1;
    }

    Class_stringmap::~Class_stringmap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_stringmap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_stringmap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_string) {
        vx_core::Type_string newval = vx_core::vx_any_from_any(vx_core::t_string, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_string oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_string) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_string(key)
    vx_core::Type_string Class_stringmap::vx_get_string(vx_core::Type_string key) const {
      vx_core::Type_string output = vx_core::e_string;
      const vx_core::Class_stringmap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_string> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_string);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_stringmap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_string(key);
    }

    // vx_mapstring()
    std::map<std::string, vx_core::Type_string> Class_stringmap::vx_mapstring() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_stringmap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_stringmap output = vx_core::e_stringmap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_string> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_string) {
          vx_core::Type_string castval = vx_core::vx_any_from_any(vx_core::t_string, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(stringmap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_stringmap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_stringmap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_stringmap, vals);
    }

    vx_core::Type_any Class_stringmap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_stringmap output = vx_core::e_stringmap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_stringmap valmap = vx_core::vx_any_from_any(vx_core::t_stringmap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_string> mapval = valmap->vx_mapstring();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_string valany = NULL;
          if (valsubtype == vx_core::t_string) {
            valany = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          } else if (valsubtype == vx_core::t_string) {
            valany = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_stringmap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_stringmap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_stringmap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_stringmap::vx_empty() const {return vx_core::e_stringmap;}
    vx_core::Type_any Class_stringmap::vx_type() const {return vx_core::t_stringmap;}

    vx_core::Type_typedef Class_stringmap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "stringmap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_string}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_stringmap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type stringmutablemap)
  // class Class_stringmutablemap {
    Abstract_stringmutablemap::~Abstract_stringmutablemap() {}

    Class_stringmutablemap::Class_stringmutablemap() : Abstract_stringmutablemap::Abstract_stringmutablemap() {
      vx_core::refcount += 1;
    }

    Class_stringmutablemap::~Class_stringmutablemap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_stringmutablemap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_stringmutablemap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_string) {
        vx_core::Type_string newval = vx_core::vx_any_from_any(vx_core::t_string, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_string oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_string) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_string(key)
    vx_core::Type_string Class_stringmutablemap::vx_get_string(vx_core::Type_string key) const {
      vx_core::Type_string output = vx_core::e_string;
      const vx_core::Class_stringmutablemap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_string> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_string);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_stringmutablemap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_string(key);
    }

    // vx_mapstring()
    std::map<std::string, vx_core::Type_string> Class_stringmutablemap::vx_mapstring() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_stringmutablemap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_stringmutablemap output = vx_core::e_stringmutablemap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_string> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_string) {
          vx_core::Type_string castval = vx_core::vx_any_from_any(vx_core::t_string, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(stringmutablemap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_stringmutablemap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_stringmutablemap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_stringmutablemap, vals);
    }

    vx_core::Type_any Class_stringmutablemap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_stringmutablemap output = vx_core::e_stringmutablemap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_stringmutablemap valmap = vx_core::vx_any_from_any(vx_core::t_stringmutablemap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_string> mapval = valmap->vx_mapstring();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_string valany = NULL;
          if (valsubtype == vx_core::t_string) {
            valany = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          } else if (valsubtype == vx_core::t_string) {
            valany = vx_core::vx_any_from_any(vx_core::t_string, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_stringmutablemap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_stringmutablemap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_stringmutablemap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_stringmutablemap::vx_empty() const {return vx_core::e_stringmutablemap;}
    vx_core::Type_any Class_stringmutablemap::vx_type() const {return vx_core::t_stringmutablemap;}

    vx_core::Type_typedef Class_stringmutablemap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "stringmutablemap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_string}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_stringmutablemap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type thenelse)
  // class Class_thenelse {
    Abstract_thenelse::~Abstract_thenelse() {}

    Class_thenelse::Class_thenelse() : Abstract_thenelse::Abstract_thenelse() {
      vx_core::refcount += 1;
    }

    Class_thenelse::~Class_thenelse() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_code,
        this->vx_p_value,
        this->vx_p_values,
        this->vx_p_fn_cond,
        this->vx_p_fn_any
      });
    }

    // code()
    vx_core::Type_string Class_thenelse::code() const {
      vx_core::Type_string output = this->vx_p_code;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // value()
    vx_core::Type_any Class_thenelse::value() const {
      vx_core::Type_any output = this->vx_p_value;
      if (!output) {
        output = vx_core::e_any;
      }
      return output;
    }

    // values()
    vx_core::Type_list Class_thenelse::values() const {
      vx_core::Type_list output = this->vx_p_values;
      if (!output) {
        output = vx_core::e_list;
      }
      return output;
    }

    // fn_cond()
    vx_core::Func_boolean_from_func Class_thenelse::fn_cond() const {
      vx_core::Func_boolean_from_func output = this->vx_p_fn_cond;
      if (!output) {
        output = vx_core::e_boolean_from_func;
      }
      return output;
    }

    // fn_any()
    vx_core::Func_any_from_func Class_thenelse::fn_any() const {
      vx_core::Func_any_from_func output = this->vx_p_fn_any;
      if (!output) {
        output = vx_core::e_any_from_func;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_thenelse::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":code") {
        output = this->code();
      } else if (skey == ":value") {
        output = this->value();
      } else if (skey == ":values") {
        output = this->values();
      } else if (skey == ":fn-cond") {
        output = this->fn_cond();
      } else if (skey == ":fn-any") {
        output = this->fn_any();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_thenelse::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":code"] = this->code();
      output[":value"] = this->value();
      output[":values"] = this->values();
      output[":fn-cond"] = this->fn_cond();
      output[":fn-any"] = this->fn_any();
      return output;
    }

    vx_core::Type_any Class_thenelse::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_thenelse, vals);
    }

    vx_core::Type_any Class_thenelse::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_thenelse output = vx_core::e_thenelse;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_thenelse val = vx_core::vx_any_from_any(vx_core::t_thenelse, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_code = val->code();
      vx_core::Type_any vx_p_value = val->value();
      vx_core::Type_list vx_p_values = val->values();
      vx_core::Func_boolean_from_func vx_p_fn_cond = val->fn_cond();
      vx_core::Func_any_from_func vx_p_fn_any = val->fn_any();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":code") {
            key = testkey;
          } else if (testkey == ":value") {
            key = testkey;
          } else if (testkey == ":values") {
            key = testkey;
          } else if (testkey == ":fn-cond") {
            key = testkey;
          } else if (testkey == ":fn-any") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new thenelse) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":code") {
            if (vx_p_code == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_code = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new thenelse :code " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":value") {
            if (vx_p_value != valsub) {
              ischanged = true;
              vx_p_value = valsub;
            }
          } else if (key == ":values") {
            if (vx_p_values == valsub) {
            } else if (valsubtype == vx_core::t_list) {
              ischanged = true;
              vx_p_values = vx_core::vx_any_from_any(vx_core::t_list, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new thenelse :values " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":fn-cond") {
            if (vx_p_fn_cond == valsub) {
            } else if (valsubtype == vx_core::t_boolean_from_func) {
              ischanged = true;
              vx_p_fn_cond = vx_core::vx_any_from_any(vx_core::t_boolean_from_func, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new thenelse :fn-cond " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":fn-any") {
            if (vx_p_fn_any == valsub) {
            } else if (valsubtype == vx_core::t_any_from_func) {
              ischanged = true;
              vx_p_fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new thenelse :fn-any " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new thenelse) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_thenelse();
        if (output->vx_p_code != vx_p_code) {
          if (output->vx_p_code) {
            vx_core::vx_release_one(output->vx_p_code);
          }
          output->vx_p_code = vx_p_code;
          vx_core::vx_reserve(vx_p_code);
        }
        if (output->vx_p_value != vx_p_value) {
          if (output->vx_p_value) {
            vx_core::vx_release_one(output->vx_p_value);
          }
          output->vx_p_value = vx_p_value;
          vx_core::vx_reserve(vx_p_value);
        }
        if (output->vx_p_values != vx_p_values) {
          if (output->vx_p_values) {
            vx_core::vx_release_one(output->vx_p_values);
          }
          output->vx_p_values = vx_p_values;
          vx_core::vx_reserve(vx_p_values);
        }
        if (output->vx_p_fn_cond != vx_p_fn_cond) {
          if (output->vx_p_fn_cond) {
            vx_core::vx_release_one(output->vx_p_fn_cond);
          }
          output->vx_p_fn_cond = vx_p_fn_cond;
          vx_core::vx_reserve(vx_p_fn_cond);
        }
        if (output->vx_p_fn_any != vx_p_fn_any) {
          if (output->vx_p_fn_any) {
            vx_core::vx_release_one(output->vx_p_fn_any);
          }
          output->vx_p_fn_any = vx_p_fn_any;
          vx_core::vx_reserve(vx_p_fn_any);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_thenelse::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_thenelse::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_thenelse::vx_empty() const {return vx_core::e_thenelse;}
    vx_core::Type_any Class_thenelse::vx_type() const {return vx_core::t_thenelse;}

    vx_core::Type_typedef Class_thenelse::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "thenelse", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "code", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "value", // name
            vx_core::t_any // type
          ),
          vx_core::vx_new_arg(
            "values", // name
            vx_core::t_list // type
          ),
          vx_core::vx_new_arg(
            "fn-cond", // name
            vx_core::t_boolean_from_func // type
          ),
          vx_core::vx_new_arg(
            "fn-any", // name
            vx_core::t_any_from_func // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_thenelse::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type thenelselist)
  // class Class_thenelselist {
    Abstract_thenelselist::~Abstract_thenelselist() {}

    Class_thenelselist::Class_thenelselist() : Abstract_thenelselist::Abstract_thenelselist() {
      vx_core::refcount += 1;
    }

    Class_thenelselist::~Class_thenelselist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_thenelselist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_thenelse Class_thenelselist::vx_get_thenelse(vx_core::Type_int index) const {
      vx_core::Type_thenelse output = vx_core::e_thenelse;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_thenelse> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_thenelse> Class_thenelselist::vx_listthenelse() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_thenelselist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_thenelse(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_thenelselist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_thenelselist output = vx_core::e_thenelselist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_thenelse> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_thenelse) {
          vx_core::Type_thenelse castval = vx_core::vx_any_from_any(vx_core::t_thenelse, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_thenelse)) {
          vx_core::Type_thenelse castval = vx_core::vx_any_from_any(vx_core::t_thenelse, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(thenelselist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_thenelselist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_thenelselist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_thenelselist, vals);
    }

    vx_core::Type_any Class_thenelselist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_thenelselist output = vx_core::e_thenelselist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_thenelselist val = vx_core::vx_any_from_any(vx_core::t_thenelselist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_thenelse> listval = val->vx_listthenelse();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_thenelse) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_thenelse, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_thenelse)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_thenelse, valsub));
        } else if (valsubtype == vx_core::t_thenelselist) {
          ischanged = true;
          vx_core::Type_thenelselist multi = vx_core::vx_any_from_any(vx_core::t_thenelselist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listthenelse());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new thenelselist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_thenelselist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_thenelselist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_thenelselist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_thenelselist::vx_empty() const {return vx_core::e_thenelselist;}
    vx_core::Type_any Class_thenelselist::vx_type() const {return vx_core::t_thenelselist;}

    vx_core::Type_typedef Class_thenelselist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "thenelselist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_thenelse}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_thenelselist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type translation)
  // class Class_translation {
    Abstract_translation::~Abstract_translation() {}

    Class_translation::Class_translation() : Abstract_translation::Abstract_translation() {
      vx_core::refcount += 1;
    }

    Class_translation::~Class_translation() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_name,
        this->vx_p_wordmap
      });
    }

    // name()
    vx_core::Type_string Class_translation::name() const {
      vx_core::Type_string output = this->vx_p_name;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // wordmap()
    vx_core::Type_stringmap Class_translation::wordmap() const {
      vx_core::Type_stringmap output = this->vx_p_wordmap;
      if (!output) {
        output = vx_core::e_stringmap;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_translation::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":name") {
        output = this->name();
      } else if (skey == ":wordmap") {
        output = this->wordmap();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_translation::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":name"] = this->name();
      output[":wordmap"] = this->wordmap();
      return output;
    }

    vx_core::Type_any Class_translation::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_translation, vals);
    }

    vx_core::Type_any Class_translation::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_translation output = vx_core::e_translation;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_translation val = vx_core::vx_any_from_any(vx_core::t_translation, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_string vx_p_name = val->name();
      vx_core::Type_stringmap vx_p_wordmap = val->wordmap();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":name") {
            key = testkey;
          } else if (testkey == ":wordmap") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new translation) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":name") {
            if (vx_p_name == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_name = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new translation :name " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":wordmap") {
            if (vx_p_wordmap == valsub) {
            } else if (valsubtype == vx_core::t_stringmap) {
              ischanged = true;
              vx_p_wordmap = vx_core::vx_any_from_any(vx_core::t_stringmap, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new translation :wordmap " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new translation) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_translation();
        if (output->vx_p_name != vx_p_name) {
          if (output->vx_p_name) {
            vx_core::vx_release_one(output->vx_p_name);
          }
          output->vx_p_name = vx_p_name;
          vx_core::vx_reserve(vx_p_name);
        }
        if (output->vx_p_wordmap != vx_p_wordmap) {
          if (output->vx_p_wordmap) {
            vx_core::vx_release_one(output->vx_p_wordmap);
          }
          output->vx_p_wordmap = vx_p_wordmap;
          vx_core::vx_reserve(vx_p_wordmap);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_translation::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_translation::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_translation::vx_empty() const {return vx_core::e_translation;}
    vx_core::Type_any Class_translation::vx_type() const {return vx_core::t_translation;}

    vx_core::Type_typedef Class_translation::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "translation", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "name", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "wordmap", // name
            vx_core::t_stringmap // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_translation::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type translationlist)
  // class Class_translationlist {
    Abstract_translationlist::~Abstract_translationlist() {}

    Class_translationlist::Class_translationlist() : Abstract_translationlist::Abstract_translationlist() {
      vx_core::refcount += 1;
    }

    Class_translationlist::~Class_translationlist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_translationlist::vx_list() const {
      return vx_core::vx_list_from_list(vx_core::t_any, this->vx_p_list);
    }

    vx_core::Type_translation Class_translationlist::vx_get_translation(vx_core::Type_int index) const {
      vx_core::Type_translation output = vx_core::e_translation;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_translation> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    std::vector<vx_core::Type_translation> Class_translationlist::vx_listtranslation() const {return vx_p_list;}

    vx_core::Type_any vx_core::Class_translationlist::vx_get_any(vx_core::Type_int index) const {
      return this->vx_get_translation(index);
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_translationlist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_translationlist output = vx_core::e_translationlist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_translation> list;
      for (auto const& valsub : listval) {
        vx_core::Type_any valtype = valsub->vx_type();
        if (valtype == vx_core::t_translation) {
          vx_core::Type_translation castval = vx_core::vx_any_from_any(vx_core::t_translation, valsub);
          list.push_back(castval);
        } else if (vx_core::vx_boolean_from_type_trait(valtype, vx_core::t_translation)) {
          vx_core::Type_translation castval = vx_core::vx_any_from_any(vx_core::t_translation, valsub);
          list.push_back(castval);
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(translationlist) Invalid Value: " + vx_core::vx_string_from_any(valsub) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_translationlist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_translationlist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_translationlist, vals);
    }

    vx_core::Type_any Class_translationlist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_translationlist output = vx_core::e_translationlist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_translationlist val = vx_core::vx_any_from_any(vx_core::t_translationlist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_translation> listval = val->vx_listtranslation();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_translation) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_translation, valsub));
        } else if (vx_core::vx_boolean_from_type_trait(valsubtype, vx_core::t_translation)) {
          ischanged = true;
          listval.push_back(vx_core::vx_any_from_any(vx_core::t_translation, valsub));
        } else if (valsubtype == vx_core::t_translationlist) {
          ischanged = true;
          vx_core::Type_translationlist multi = vx_core::vx_any_from_any(vx_core::t_translationlist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_listtranslation());
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new translationlist) - Invalid Type: " + vx_core::vx_string_from_any(valsub));
          msgblock = vx_core::vx_copy(msgblock, {msg});
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_translationlist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_translationlist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_translationlist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_translationlist::vx_empty() const {return vx_core::e_translationlist;}
    vx_core::Type_any Class_translationlist::vx_type() const {return vx_core::t_translationlist;}

    vx_core::Type_typedef Class_translationlist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "translationlist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_translation}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_translationlist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type translationmap)
  // class Class_translationmap {
    Abstract_translationmap::~Abstract_translationmap() {}

    Class_translationmap::Class_translationmap() : Abstract_translationmap::Abstract_translationmap() {
      vx_core::refcount += 1;
    }

    Class_translationmap::~Class_translationmap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_translationmap::vx_map() const {
      vx_core::vx_Type_mapany output = vx_core::vx_map_from_map(vx_core::t_any, this->vx_p_map);
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_translationmap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_translation) {
        vx_core::Type_translation newval = vx_core::vx_any_from_any(vx_core::t_translation, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_translation oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_translation) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_translation(key)
    vx_core::Type_translation Class_translationmap::vx_get_translation(vx_core::Type_string key) const {
      vx_core::Type_translation output = vx_core::e_translation;
      const vx_core::Class_translationmap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_translation> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_translation);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_translationmap::vx_get_any(vx_core::Type_string key) const {
      return this->vx_get_translation(key);
    }

    // vx_maptranslation()
    std::map<std::string, vx_core::Type_translation> Class_translationmap::vx_maptranslation() const {return this->vx_p_map;}

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_translationmap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_translationmap output = vx_core::e_translationmap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_translation> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        vx_core::Type_any valtype = val->vx_type();
        if (valtype == vx_core::t_translation) {
          vx_core::Type_translation castval = vx_core::vx_any_from_any(vx_core::t_translation, val);
          map[key] = castval;
        } else {
          vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(translationmap) Invalid Value: " + vx_core::vx_string_from_any(val) + "");
          msgblock = vx_core::vx_copy(msgblock, {msgblock, msg});
        }
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_translationmap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_translationmap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_translationmap, vals);
    }

    vx_core::Type_any Class_translationmap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_translationmap output = vx_core::e_translationmap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_translationmap valmap = vx_core::vx_any_from_any(vx_core::t_translationmap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_translation> mapval = valmap->vx_maptranslation();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_translation valany = NULL;
          if (valsubtype == vx_core::t_translation) {
            valany = vx_core::vx_any_from_any(vx_core::t_translation, valsub);
          } else if (valsubtype == vx_core::t_translation) {
            valany = vx_core::vx_any_from_any(vx_core::t_translation, valsub);
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Invalid Key/Value: " + skey + " "  + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_translationmap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_translationmap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_translationmap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_translationmap::vx_empty() const {return vx_core::e_translationmap;}
    vx_core::Type_any Class_translationmap::vx_type() const {return vx_core::t_translationmap;}

    vx_core::Type_typedef Class_translationmap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "translationmap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_translation}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_translationmap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type type)
  // class Class_type {
    Abstract_type::~Abstract_type() {}

    Class_type::Class_type() : Abstract_type::Abstract_type() {
      vx_core::refcount += 1;
    }

    Class_type::~Class_type() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_type::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_type, vals);
    }

    vx_core::Type_any Class_type::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_type output = vx_core::e_type;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_type::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_type::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_type::vx_empty() const {return vx_core::e_type;}
    vx_core::Type_any Class_type::vx_type() const {return vx_core::t_type;}

    vx_core::Type_typedef Class_type::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "type", // name
        ":type", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_type::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type typelist)
  // class Class_typelist {
    Abstract_typelist::~Abstract_typelist() {}

    Class_typelist::Class_typelist() : Abstract_typelist::Abstract_typelist() {
      vx_core::refcount += 1;
    }

    Class_typelist::~Class_typelist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (vx_core::Type_any any : this->vx_p_list) {
        vx_core::vx_release_one(any);
      }
    }

    // vx_list()
    vx_core::vx_Type_listany Class_typelist::vx_list() const {
      return this->vx_p_list;
    }

    // vx_get_any(index)
    vx_core::Type_any Class_typelist::vx_get_any(vx_core::Type_int index) const {
      vx_core::Type_any output = vx_core::e_any;
      long iindex = index->vx_int();
      std::vector<vx_core::Type_any> listval = this->vx_p_list;
      if ((unsigned long long)iindex < listval.size()) {
        output = listval[iindex];
      }
      vx_core::vx_release_except(index, output);
      return output;
    }

    // vx_new_from_list(listval)
    vx_core::Type_any Class_typelist::vx_new_from_list(vx_core::vx_Type_listany listval) const {
      vx_core::Type_typelist output = vx_core::e_typelist;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::vector<vx_core::Type_any> list;
      for (auto const& valsub : listval) {
        list.push_back(valsub);
      }
      if ((list.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_typelist();
        output->vx_p_list = list;
        for (vx_core::Type_any valadd : list) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(listval, output);
      return output;
    }

    vx_core::Type_any Class_typelist::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_typelist, vals);
    }

    vx_core::Type_any Class_typelist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_typelist output = vx_core::e_typelist;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_typelist val = vx_core::vx_any_from_any(vx_core::t_typelist, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      std::vector<vx_core::Type_any> listval = val->vx_list();
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_typelist) {
          ischanged = true;
          vx_core::Type_typelist multi = vx_core::vx_any_from_any(vx_core::t_typelist, valsub);
          listval = vx_core::vx_listaddall(listval, multi->vx_list());
        } else {
          listval.push_back(valsub);
        }
      }
      if (ischanged || (listval.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_typelist();
        output->vx_p_list = listval;
        for (vx_core::Type_any valadd : listval) {
          vx_core::vx_reserve(valadd);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_typelist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_typelist::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_typelist::vx_empty() const {return vx_core::e_typelist;}
    vx_core::Type_any Class_typelist::vx_type() const {return vx_core::t_typelist;}

    vx_core::Type_typedef Class_typelist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "typelist", // name
        ":list", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_any}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_typelist::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type typemap)
  // class Class_typemap {
    Abstract_typemap::~Abstract_typemap() {}

    Class_typemap::Class_typemap() : Abstract_typemap::Abstract_typemap() {
      vx_core::refcount += 1;
    }

    Class_typemap::~Class_typemap() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      for (auto const& [key, val] : this->vx_p_map) {
        vx_core::vx_release_one(val);
      }
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_typemap::vx_map() const {
      vx_core::vx_Type_mapany output = this->vx_p_map;
      return output;
    }

    // vx_set(map, string, any)
    vx_core::Type_boolean Class_typemap::vx_set(vx_core::Type_string name, vx_core::Type_any value) {
      vx_core::Type_boolean output = vx_core::c_false;
      vx_core::Type_any valtype = value->vx_type();
      if (valtype == vx_core::t_any) {
        vx_core::Type_any newval = vx_core::vx_any_from_any(vx_core::t_any, value);
        std::string key = name->vx_string();
        if (vx_core::vx_boolean_from_string_starts(key, ":")) {
          key = key.substr(1, key.length());
        }
        vx_core::Type_any oldval = this->vx_p_map[key];
        if (oldval != newval) {
          if (oldval) {
            vx_core::vx_release_one(oldval);
          }
          if (newval == vx_core::e_any) {
            this->vx_p_map.erase(key);
          } else {
            vx_core::vx_reserve(newval);
            this->vx_p_map[key] = newval;
          }
        }
        output = vx_core::c_true;
      }
      return output;
    }
    // vx_get_any(key)
    vx_core::Type_any Class_typemap::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      const vx_core::Class_typemap* map = this;
      std::string skey = key->vx_string();
      if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
        skey = vx_core::vx_string_from_string_start(skey, 2);
      }
      std::map<std::string, vx_core::Type_any> mapval = map->vx_p_map;
      output = vx_core::vx_any_from_map(mapval, skey, vx_core::e_any);
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_new_from_map(mapval)
    vx_core::Type_any Class_typemap::vx_new_from_map(vx_core::vx_Type_mapany mapval) const {
      vx_core::Type_typemap output = vx_core::e_typemap;
      vx_core::Type_msgblock msgblock = vx_core::e_msgblock;
      std::map<std::string, vx_core::Type_any> map;
      for (auto const& iter : mapval) {
        std::string key = iter.first;
        vx_core::Type_any val = iter.second;
        map[key] = val;
      }
      if ((map.size() > 0) || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_typemap();
        output->vx_p_map = map;
        for (auto const& [key, val] : map) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      for (auto const& [key, val] : mapval) {
        vx_core::vx_release_except(val, output);
      }
      return output;
    }

    vx_core::Type_any Class_typemap::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_typemap, vals);
    }

    vx_core::Type_any Class_typemap::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_typemap output = vx_core::e_typemap;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_typemap valmap = vx_core::vx_any_from_any(vx_core::t_typemap, copyval);
      output = valmap;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(valmap->vx_msgblock(), vals);
      std::map<std::string, vx_core::Type_any> mapval = valmap->vx_map();
      std::vector<std::string> keys = valmap->vx_p_keys;
      std::string skey = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (skey == "") {
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstring = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            skey = valstring->vx_string();
            if (vx_core::vx_boolean_from_string_starts(skey, ":")) {
              skey = vx_core::vx_string_from_string_start(skey, 2);
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("Key Expected: " + vx_core::vx_string_from_any(valsub) + "");
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          vx_core::Type_any valany = valsub;
          if (valany) {
            ischanged = true;
            mapval[skey] = valany;
            if (!vx_core::vx_boolean_from_list_find(keys, skey)) {
          	 		keys.push_back(skey);
            }
            skey = "";
          }
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_typemap();
        output->vx_p_keys = keys;
        output->vx_p_map = mapval;
        for (auto const& [key, val] : mapval) {
          vx_core::vx_reserve(val);
        }
        if (msgblock != vx_core::e_msgblock) {
          output->vx_p_msgblock = msgblock;
          vx_core::vx_reserve(msgblock);
        }
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_typemap::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_typemap::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_typemap::vx_empty() const {return vx_core::e_typemap;}
    vx_core::Type_any Class_typemap::vx_type() const {return vx_core::t_typemap;}

    vx_core::Type_typedef Class_typemap::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "typemap", // name
        ":map", // extends
        vx_core::e_typelist, // traits
        vx_core::vx_typelist_from_listany({vx_core::t_any}), // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_typemap::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type user)
  // class Class_user {
    Abstract_user::~Abstract_user() {}

    Class_user::Class_user() : Abstract_user::Abstract_user() {
      vx_core::refcount += 1;
    }

    Class_user::~Class_user() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_security,
        this->vx_p_username,
        this->vx_p_token
      });
    }

    // security()
    vx_core::Type_security Class_user::security() const {
      vx_core::Type_security output = this->vx_p_security;
      if (!output) {
        output = vx_core::e_security;
      }
      return output;
    }

    // username()
    vx_core::Type_string Class_user::username() const {
      vx_core::Type_string output = this->vx_p_username;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // token()
    vx_core::Type_string Class_user::token() const {
      vx_core::Type_string output = this->vx_p_token;
      if (!output) {
        output = vx_core::e_string;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_user::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":security") {
        output = this->security();
      } else if (skey == ":username") {
        output = this->username();
      } else if (skey == ":token") {
        output = this->token();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_user::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":security"] = this->security();
      output[":username"] = this->username();
      output[":token"] = this->token();
      return output;
    }

    vx_core::Type_any Class_user::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_user, vals);
    }

    vx_core::Type_any Class_user::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_user output = vx_core::e_user;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_user val = vx_core::vx_any_from_any(vx_core::t_user, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_security vx_p_security = val->security();
      vx_core::Type_string vx_p_username = val->username();
      vx_core::Type_string vx_p_token = val->token();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":security") {
            key = testkey;
          } else if (testkey == ":username") {
            key = testkey;
          } else if (testkey == ":token") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new user) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":security") {
            if (vx_p_security == valsub) {
            } else if (valsubtype == vx_core::t_security) {
              ischanged = true;
              vx_p_security = vx_core::vx_any_from_any(vx_core::t_security, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new user :security " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":username") {
            if (vx_p_username == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_username = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new user :username " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else if (key == ":token") {
            if (vx_p_token == valsub) {
            } else if (valsubtype == vx_core::t_string) {
              ischanged = true;
              vx_p_token = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new user :token " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new user) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_user();
        if (output->vx_p_security != vx_p_security) {
          if (output->vx_p_security) {
            vx_core::vx_release_one(output->vx_p_security);
          }
          output->vx_p_security = vx_p_security;
          vx_core::vx_reserve(vx_p_security);
        }
        if (output->vx_p_username != vx_p_username) {
          if (output->vx_p_username) {
            vx_core::vx_release_one(output->vx_p_username);
          }
          output->vx_p_username = vx_p_username;
          vx_core::vx_reserve(vx_p_username);
        }
        if (output->vx_p_token != vx_p_token) {
          if (output->vx_p_token) {
            vx_core::vx_release_one(output->vx_p_token);
          }
          output->vx_p_token = vx_p_token;
          vx_core::vx_reserve(vx_p_token);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_user::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_user::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_user::vx_empty() const {return vx_core::e_user;}
    vx_core::Type_any Class_user::vx_type() const {return vx_core::t_user;}

    vx_core::Type_typedef Class_user::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "user", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "security", // name
            vx_core::t_security // type
          ),
          vx_core::vx_new_arg(
            "username", // name
            vx_core::t_string // type
          ),
          vx_core::vx_new_arg(
            "token", // name
            vx_core::t_string // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_user::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (type value)
  // class Class_value {
    Abstract_value::~Abstract_value() {}

    Class_value::Class_value() : Abstract_value::Abstract_value() {
      vx_core::refcount += 1;
    }

    Class_value::~Class_value() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one({
        this->vx_p_next,
        this->vx_p_refs
      });
    }

    // next()
    vx_core::Type_any Class_value::next() const {
      vx_core::Type_any output = this->vx_p_next;
      if (!output) {
        output = vx_core::e_any;
      }
      return output;
    }

    // refs()
    vx_core::Type_int Class_value::refs() const {
      vx_core::Type_int output = this->vx_p_refs;
      if (!output) {
        output = vx_core::e_int;
      }
      return output;
    }

    // vx_get_any(key)
    vx_core::Type_any Class_value::vx_get_any(vx_core::Type_string key) const {
      vx_core::Type_any output = vx_core::e_any;
      std::string skey = key->vx_string();
      if (false) {
      } else if (skey == ":next") {
        output = this->next();
      } else if (skey == ":refs") {
        output = this->refs();
      }
      vx_core::vx_release_except(key, output);
      return output;
    }

    // vx_map()
    vx_core::vx_Type_mapany Class_value::vx_map() const {
      vx_core::vx_Type_mapany output;
      output[":next"] = this->next();
      output[":refs"] = this->refs();
      return output;
    }

    vx_core::Type_any Class_value::vx_new(vx_core::vx_Type_listany vals) const {
      return this->vx_copy(vx_core::e_value, vals);
    }

    vx_core::Type_any Class_value::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Type_value output = vx_core::e_value;
      bool ischanged = false;
      if (copyval->vx_p_constdef != NULL) {
        ischanged = true;
      }
      vx_core::Type_value val = vx_core::vx_any_from_any(vx_core::t_value, copyval);
      output = val;
      vx_core::Type_msgblock msgblock = vx_core::vx_msgblock_from_copy_listval(val->vx_msgblock(), vals);
      vx_core::Type_any vx_p_next = val->next();
      vx_core::Type_int vx_p_refs = val->refs();
      std::string key = "";
      for (vx_core::Type_any valsub : vals) {
        vx_core::Type_any valsubtype = valsub->vx_type();
        if (valsubtype == vx_core::t_msgblock) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (valsubtype == vx_core::t_msg) {
          msgblock = vx_core::vx_copy(msgblock, {valsub});
        } else if (key == "") {
          std::string testkey = "";
          if (valsubtype == vx_core::t_string) {
            vx_core::Type_string valstr = vx_core::vx_any_from_any(vx_core::t_string, valsub);
            testkey = valstr->vx_string();
          }
          if (false) {
          } else if (testkey == ":next") {
            key = testkey;
          } else if (testkey == ":refs") {
            key = testkey;
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new value) - Invalid Key Type: " + vx_core::vx_string_from_any(valsub));
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
        } else {
          if (false) {
          } else if (key == ":next") {
            if (vx_p_next != valsub) {
              ischanged = true;
              vx_p_next = valsub;
            }
          } else if (key == ":refs") {
            if (vx_p_refs == valsub) {
            } else if (valsubtype == vx_core::t_int) {
              ischanged = true;
              vx_p_refs = vx_core::vx_any_from_any(vx_core::t_int, valsub);
            } else {
              vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new value :refs " + vx_core::vx_string_from_any(valsub) + ") - Invalid Value");
              msgblock = vx_core::vx_copy(msgblock, {msg});
            }
          } else {
            vx_core::Type_msg msg = vx_core::vx_msg_from_errortext("(new value) - Invalid Key: " + key);
            msgblock = vx_core::vx_copy(msgblock, {msg});
          }
          key = "";
        }
      }
      if (ischanged || (msgblock != vx_core::e_msgblock)) {
        output = new vx_core::Class_value();
        if (output->vx_p_next != vx_p_next) {
          if (output->vx_p_next) {
            vx_core::vx_release_one(output->vx_p_next);
          }
          output->vx_p_next = vx_p_next;
          vx_core::vx_reserve(vx_p_next);
        }
        if (output->vx_p_refs != vx_p_refs) {
          if (output->vx_p_refs) {
            vx_core::vx_release_one(output->vx_p_refs);
          }
          output->vx_p_refs = vx_p_refs;
          vx_core::vx_reserve(vx_p_refs);
        }
      }
      if (msgblock != vx_core::e_msgblock) {
        output->vx_p_msgblock = msgblock;
        vx_core::vx_reserve(msgblock);
      }
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_msgblock Class_value::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany vx_core::Class_value::vx_dispose() {return vx_core::emptylistany;}
    vx_core::Type_any Class_value::vx_empty() const {return vx_core::e_value;}
    vx_core::Type_any Class_value::vx_type() const {return vx_core::t_value;}

    vx_core::Type_typedef Class_value::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "value", // name
        ":struct", // extends
        vx_core::e_typelist, // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::vx_argmap_from_listarg({
          vx_core::vx_new_arg(
            "next", // name
            vx_core::t_any // type
          ),
          vx_core::vx_new_arg(
            "refs", // name
            vx_core::t_int // type
          )
        }) // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_value::vx_constdef() const {return this->vx_p_constdef;}


  //}

  // (const false)
  // class Class_false {
    // vx_const_new()
    void vx_core::Class_false::vx_const_new(vx_core::Const_false output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "false");
      output->vx_p_boolean = false;
      vx_core::vx_reserve_type(output);
    }

    bool vx_core::Class_false::vx_boolean() const {
      return this->vx_p_boolean;
    }

  //}

  // (const global)
  // class Class_global {
    // vx_const_new()
    void vx_core::Class_global::vx_const_new(vx_core::Const_global output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "global");
      vx_core::vx_reserve_type(output);
    }


  //}

  // (const infinity)
  // class Class_infinity {
    // vx_const_new()
    void vx_core::Class_infinity::vx_const_new(vx_core::Const_infinity output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "infinity");
      output->vx_p_int = 0;
      vx_core::vx_reserve_type(output);
    }

    long vx_core::Class_infinity::vx_int() const {
      return this->vx_p_int;
    }

  //}

  // (const mempool-active)
  // class Class_mempool_active {
    // vx_const_new()
    void vx_core::Class_mempool_active::vx_const_new(vx_core::Const_mempool_active output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "mempool-active");
      vx_core::vx_reserve_type(output);
    }


  //}

  // (const msg-error)
  // class Class_msg_error {
    // vx_const_new()
    void vx_core::Class_msg_error::vx_const_new(vx_core::Const_msg_error output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "msg-error");
      output->vx_p_int = 2;
      vx_core::vx_reserve_type(output);
    }

    long vx_core::Class_msg_error::vx_int() const {
      return this->vx_p_int;
    }

  //}

  // (const msg-info)
  // class Class_msg_info {
    // vx_const_new()
    void vx_core::Class_msg_info::vx_const_new(vx_core::Const_msg_info output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "msg-info");
      output->vx_p_int = 0;
      vx_core::vx_reserve_type(output);
    }

    long vx_core::Class_msg_info::vx_int() const {
      return this->vx_p_int;
    }

  //}

  // (const msg-severe)
  // class Class_msg_severe {
    // vx_const_new()
    void vx_core::Class_msg_severe::vx_const_new(vx_core::Const_msg_severe output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "msg-severe");
      output->vx_p_int = 3;
      vx_core::vx_reserve_type(output);
    }

    long vx_core::Class_msg_severe::vx_int() const {
      return this->vx_p_int;
    }

  //}

  // (const msg-warning)
  // class Class_msg_warning {
    // vx_const_new()
    void vx_core::Class_msg_warning::vx_const_new(vx_core::Const_msg_warning output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "msg-warning");
      output->vx_p_int = 1;
      vx_core::vx_reserve_type(output);
    }

    long vx_core::Class_msg_warning::vx_int() const {
      return this->vx_p_int;
    }

  //}

  // (const neginfinity)
  // class Class_neginfinity {
    // vx_const_new()
    void vx_core::Class_neginfinity::vx_const_new(vx_core::Const_neginfinity output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "neginfinity");
      output->vx_p_int = 0;
      vx_core::vx_reserve_type(output);
    }

    long vx_core::Class_neginfinity::vx_int() const {
      return this->vx_p_int;
    }

  //}

  // (const newline)
  // class Class_newline {
    // vx_const_new()
    void vx_core::Class_newline::vx_const_new(vx_core::Const_newline output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "newline");
      output->vx_p_string = "\n";
      vx_core::vx_reserve_type(output);
    }

    std::string vx_core::Class_newline::vx_string() const {
      return this->vx_p_string;
    }

  //}

  // (const notanumber)
  // class Class_notanumber {
    // vx_const_new()
    void vx_core::Class_notanumber::vx_const_new(vx_core::Const_notanumber output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "notanumber");
      output->vx_p_int = 0;
      vx_core::vx_reserve_type(output);
    }

    long vx_core::Class_notanumber::vx_int() const {
      return this->vx_p_int;
    }

  //}

  // (const nothing)
  // class Class_nothing {
    // vx_const_new()
    void vx_core::Class_nothing::vx_const_new(vx_core::Const_nothing output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "nothing");
      output->vx_p_string = "nothing";
      vx_core::vx_reserve_type(output);
    }

    std::string vx_core::Class_nothing::vx_string() const {
      return this->vx_p_string;
    }

  //}

  // (const path-test-resources)
  // class Class_path_test_resources {
    // vx_const_new()
    void vx_core::Class_path_test_resources::vx_const_new(vx_core::Const_path_test_resources output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "path-test-resources");
      output->vx_p_string = "src/test/resources";
      vx_core::vx_reserve_type(output);
    }

    std::string vx_core::Class_path_test_resources::vx_string() const {
      return this->vx_p_string;
    }

  //}

  // (const quote)
  // class Class_quote {
    // vx_const_new()
    void vx_core::Class_quote::vx_const_new(vx_core::Const_quote output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "quote");
      output->vx_p_string = "\"";
      vx_core::vx_reserve_type(output);
    }

    std::string vx_core::Class_quote::vx_string() const {
      return this->vx_p_string;
    }

  //}

  // (const true)
  // class Class_true {
    // vx_const_new()
    void vx_core::Class_true::vx_const_new(vx_core::Const_true output) {
      output->vx_p_constdef = vx_core::vx_constdef_new("vx/core", "true");
      output->vx_p_boolean = true;
      vx_core::vx_reserve_type(output);
    }

    bool vx_core::Class_true::vx_boolean() const {
      return this->vx_p_boolean;
    }

  //}
  /**
   * @function any_from_any
   * Function Type taking any value any-2 and returning generic any-1
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any)
   */
  // (func any<-any)
  // class Class_any_from_any {
    Abstract_any_from_any::~Abstract_any_from_any() {}

    Class_any_from_any::Class_any_from_any() : Abstract_any_from_any::Abstract_any_from_any() {
      vx_core::refcount += 1;
    }

    Class_any_from_any::~Class_any_from_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_any Class_any_from_any::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      vx_core::Func_any_from_any output = new vx_core::Class_any_from_any();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_any::vx_any_from_any(vx_core::Type_any value) const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn(value);
      }
      return output;
    }

    vx_core::Type_any Class_any_from_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any output = vx_core::e_any_from_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any output = vx_core::e_any_from_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_any::vx_empty() const {return vx_core::e_any_from_any;}
    vx_core::Type_any Class_any_from_any::vx_type() const {return vx_core::t_any_from_any;}
    vx_core::Type_msgblock Class_any_from_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_any_from_any(generic_any_1, value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function any_from_any_async
   * Function Type taking any value any-2 and returning generic any-1
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-async)
   */
  // (func any<-any-async)
  // class Class_any_from_any_async {
    Abstract_any_from_any_async::~Abstract_any_from_any_async() {}

    Class_any_from_any_async::Class_any_from_any_async() : Abstract_any_from_any_async::Abstract_any_from_any_async() {
      vx_core::refcount += 1;
    }

    Class_any_from_any_async::~Class_any_from_any_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_any_async Class_any_from_any_async::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_async::IFn fn) const {
      vx_core::Func_any_from_any_async output = new vx_core::Class_any_from_any_async();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::vx_Type_async Class_any_from_any_async::vx_any_from_any_async(vx_core::Type_any generic_any_1, vx_core::Type_any value) const {
      vx_core::vx_Type_async output = NULL;
      if (fn) {
        output = fn(value);
        output->type = generic_any_1;
      } else {
        output = vx_core::vx_async_new_from_value(vx_core::vx_empty(generic_any_1));
      }
      return output;
    }

    vx_core::Type_any Class_any_from_any_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any_async output = vx_core::e_any_from_any_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_any_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any_async output = vx_core::e_any_from_any_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_any_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-any-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_any_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_any_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-any-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_any_async::vx_empty() const {return vx_core::e_any_from_any_async;}
    vx_core::Type_any Class_any_from_any_async::vx_type() const {return vx_core::t_any_from_any_async;}
    vx_core::Type_msgblock Class_any_from_any_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_any_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_any_from_any_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_any_from_any_async(generic_any_1, value);
      vx_core::vx_release(arglist);
      return output;
    }

  //}
  /**
   * @function any_from_any_context
   * Function Type taking any value any-2 and returning generic any-1 using context
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-context)
   */
  // (func any<-any-context)
  // class Class_any_from_any_context {
    Abstract_any_from_any_context::~Abstract_any_from_any_context() {}

    Class_any_from_any_context::Class_any_from_any_context() : Abstract_any_from_any_context::Abstract_any_from_any_context() {
      vx_core::refcount += 1;
    }

    Class_any_from_any_context::~Class_any_from_any_context() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_any_context Class_any_from_any_context::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_context::IFn fn) const {
      vx_core::Func_any_from_any_context output = new vx_core::Class_any_from_any_context();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_any_context::vx_any_from_any_context(vx_core::Type_context context, vx_core::Type_any value) const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn(context, value);
      }
      return output;
    }

    vx_core::Type_any Class_any_from_any_context::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any_context output = vx_core::e_any_from_any_context;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_any_context::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any_context output = vx_core::e_any_from_any_context;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_any_context::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-any-context", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_any_context::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_any_context::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-any-context", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_any_context::vx_empty() const {return vx_core::e_any_from_any_context;}
    vx_core::Type_any Class_any_from_any_context::vx_type() const {return vx_core::t_any_from_any_context;}
    vx_core::Type_msgblock Class_any_from_any_context::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_any_context::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_any_context::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_any_from_any_context(generic_any_1, context, value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function any_from_any_context_async
   * Generic Function taking any value any-2 and returning generic any-1
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-context-async)
   */
  // (func any<-any-context-async)
  // class Class_any_from_any_context_async {
    Abstract_any_from_any_context_async::~Abstract_any_from_any_context_async() {}

    Class_any_from_any_context_async::Class_any_from_any_context_async() : Abstract_any_from_any_context_async::Abstract_any_from_any_context_async() {
      vx_core::refcount += 1;
    }

    Class_any_from_any_context_async::~Class_any_from_any_context_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_any_context_async Class_any_from_any_context_async::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_context_async::IFn fn) const {
      vx_core::Func_any_from_any_context_async output = new vx_core::Class_any_from_any_context_async();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::vx_Type_async Class_any_from_any_context_async::vx_any_from_any_context_async(vx_core::Type_any generic_any_1, vx_core::Type_context context, vx_core::Type_any value) const {
      vx_core::vx_Type_async output = NULL;
      if (fn) {
        output = fn(context, value);
        output->type = generic_any_1;
      } else {
        output = vx_core::vx_async_new_from_value(vx_core::vx_empty(generic_any_1));
      }
      return output;
    }

    vx_core::Type_any Class_any_from_any_context_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any_context_async output = vx_core::e_any_from_any_context_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_any_context_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any_context_async output = vx_core::e_any_from_any_context_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_any_context_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-any-context-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_any_context_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_any_context_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-any-context-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_any_context_async::vx_empty() const {return vx_core::e_any_from_any_context_async;}
    vx_core::Type_any Class_any_from_any_context_async::vx_type() const {return vx_core::t_any_from_any_context_async;}
    vx_core::Type_msgblock Class_any_from_any_context_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_any_context_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_any_from_any_context_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_any_from_any_context_async(generic_any_1, context, value);
      vx_core::vx_release(arglist);
      return output;
    }

  //}
  /**
   * @function any_from_func
   * Generic Function returning Generic any-1 with any parameters
   * @return {any-1}
   * (func any<-func)
   */
  // (func any<-func)
  // class Class_any_from_func {
    Abstract_any_from_func::~Abstract_any_from_func() {}

    Class_any_from_func::Class_any_from_func() : Abstract_any_from_func::Abstract_any_from_func() {
      vx_core::refcount += 1;
    }

    Class_any_from_func::~Class_any_from_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_func Class_any_from_func::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_func::IFn fn) const {
      vx_core::Func_any_from_func output = new vx_core::Class_any_from_func();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_func::vx_any_from_func() const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn();
      }
      return output;
    }

    vx_core::Type_any Class_any_from_func::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_func output = vx_core::e_any_from_func;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_func output = vx_core::e_any_from_func;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-func", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_func::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_func::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-func", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_func::vx_empty() const {return vx_core::e_any_from_func;}
    vx_core::Type_any Class_any_from_func::vx_type() const {return vx_core::t_any_from_func;}
    vx_core::Type_msgblock Class_any_from_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_func::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_func::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_any_from_func(generic_any_1);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function any_from_func_async
   * Generic Function returning Generic any-1 with any parameters
   * @return {any-1}
   * (func any<-func-async)
   */
  // (func any<-func-async)
  // class Class_any_from_func_async {
    Abstract_any_from_func_async::~Abstract_any_from_func_async() {}

    Class_any_from_func_async::Class_any_from_func_async() : Abstract_any_from_func_async::Abstract_any_from_func_async() {
      vx_core::refcount += 1;
    }

    Class_any_from_func_async::~Class_any_from_func_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_func_async Class_any_from_func_async::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_func_async::IFn fn) const {
      vx_core::Func_any_from_func_async output = new vx_core::Class_any_from_func_async();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::vx_Type_async Class_any_from_func_async::vx_any_from_func_async(vx_core::Type_any generic_any_1) const {
      vx_core::vx_Type_async output = NULL;
      if (fn) {
        output = fn();
        output->type = generic_any_1;
      } else {
        output = vx_core::vx_async_new_from_value(vx_core::vx_empty(generic_any_1));
      }
      return output;
    }

    vx_core::Type_any Class_any_from_func_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_func_async output = vx_core::e_any_from_func_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_func_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_func_async output = vx_core::e_any_from_func_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_func_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-func-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_func_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_func_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-func-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_func_async::vx_empty() const {return vx_core::e_any_from_func_async;}
    vx_core::Type_any Class_any_from_func_async::vx_type() const {return vx_core::t_any_from_func_async;}
    vx_core::Type_msgblock Class_any_from_func_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_func_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_any_from_func_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_any_from_func_async(generic_any_1);
      vx_core::vx_release(arglist);
      return output;
    }

  //}
  /**
   * @function any_from_key_value
   * Generic Function returning Generic any-1 from a key and a value
   * @param  {string} key
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-key-value)
   */
  // (func any<-key-value)
  // class Class_any_from_key_value {
    Abstract_any_from_key_value::~Abstract_any_from_key_value() {}

    Class_any_from_key_value::Class_any_from_key_value() : Abstract_any_from_key_value::Abstract_any_from_key_value() {
      vx_core::refcount += 1;
    }

    Class_any_from_key_value::~Class_any_from_key_value() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_key_value Class_any_from_key_value::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_key_value::IFn fn) const {
      vx_core::Func_any_from_key_value output = new vx_core::Class_any_from_key_value();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_key_value::vx_any_from_key_value(vx_core::Type_string key, vx_core::Type_any value) const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn(key, value);
      }
      return output;
    }

    vx_core::Type_any Class_any_from_key_value::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_key_value output = vx_core::e_any_from_key_value;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_key_value::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_key_value output = vx_core::e_any_from_key_value;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_key_value::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-key-value", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_key_value::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_key_value::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-key-value", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_key_value::vx_empty() const {return vx_core::e_any_from_key_value;}
    vx_core::Type_any Class_any_from_key_value::vx_type() const {return vx_core::t_any_from_key_value;}
    vx_core::Type_msgblock Class_any_from_key_value::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_key_value::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_key_value::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string key = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_any_from_key_value(generic_any_1, key, value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function any_from_key_value_async
   * Generic Function returning Asynchronous Generic any-1 from a key and a value
   * @param  {string} key
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-key-value-async)
   */
  // (func any<-key-value-async)
  // class Class_any_from_key_value_async {
    Abstract_any_from_key_value_async::~Abstract_any_from_key_value_async() {}

    Class_any_from_key_value_async::Class_any_from_key_value_async() : Abstract_any_from_key_value_async::Abstract_any_from_key_value_async() {
      vx_core::refcount += 1;
    }

    Class_any_from_key_value_async::~Class_any_from_key_value_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_key_value_async Class_any_from_key_value_async::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_key_value_async::IFn fn) const {
      vx_core::Func_any_from_key_value_async output = new vx_core::Class_any_from_key_value_async();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::vx_Type_async Class_any_from_key_value_async::vx_any_from_key_value_async(vx_core::Type_any generic_any_1, vx_core::Type_string key, vx_core::Type_any value) const {
      vx_core::vx_Type_async output = NULL;
      if (fn) {
        output = fn(key, value);
        output->type = generic_any_1;
      } else {
        output = vx_core::vx_async_new_from_value(vx_core::vx_empty(generic_any_1));
      }
      return output;
    }

    vx_core::Type_any Class_any_from_key_value_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_key_value_async output = vx_core::e_any_from_key_value_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_key_value_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_key_value_async output = vx_core::e_any_from_key_value_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_key_value_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-key-value-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_key_value_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_key_value_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-key-value-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_key_value_async::vx_empty() const {return vx_core::e_any_from_key_value_async;}
    vx_core::Type_any Class_any_from_key_value_async::vx_type() const {return vx_core::t_any_from_key_value_async;}
    vx_core::Type_msgblock Class_any_from_key_value_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_key_value_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_any_from_key_value_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string key = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_any_from_key_value_async(generic_any_1, key, value);
      vx_core::vx_release(arglist);
      return output;
    }

  //}
  /**
   * @function any_from_list
   * Returns nth value from a list or none if out of bounds
   * @param  {list-1} values
   * @param  {int} index
   * @return {any-1}
   * (func any<-list)
   */
  // (func any<-list)
  // class Class_any_from_list {
    Abstract_any_from_list::~Abstract_any_from_list() {}

    Class_any_from_list::Class_any_from_list() : Abstract_any_from_list::Abstract_any_from_list() {
      vx_core::refcount += 1;
    }

    Class_any_from_list::~Class_any_from_list() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_any_from_list::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_list output = vx_core::e_any_from_list;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_list::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_list output = vx_core::e_any_from_list;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_list::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-list", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_list::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_list::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-list", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_list::vx_empty() const {return vx_core::e_any_from_list;}
    vx_core::Type_any Class_any_from_list::vx_type() const {return vx_core::t_any_from_list;}
    vx_core::Type_msgblock Class_any_from_list::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_list::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_list::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_int index = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_any_from_list(generic_any_1, values, index);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function any_from_list_start_reduce
   * Returns a val from a list reduce operation
   * @param  {list-2} list
   * @param  {any-1} valstart
   * @param  {any<-reduce} fn-reduce
   * @return {any-1}
   * (func any<-list-start-reduce)
   */
  // (func any<-list-start-reduce)
  // class Class_any_from_list_start_reduce {
    Abstract_any_from_list_start_reduce::~Abstract_any_from_list_start_reduce() {}

    Class_any_from_list_start_reduce::Class_any_from_list_start_reduce() : Abstract_any_from_list_start_reduce::Abstract_any_from_list_start_reduce() {
      vx_core::refcount += 1;
    }

    Class_any_from_list_start_reduce::~Class_any_from_list_start_reduce() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_any_from_list_start_reduce::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_list_start_reduce output = vx_core::e_any_from_list_start_reduce;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_list_start_reduce::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_list_start_reduce output = vx_core::e_any_from_list_start_reduce;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_list_start_reduce::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_list_start_reduce::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_list_start_reduce::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_list_start_reduce::vx_empty() const {return vx_core::e_any_from_list_start_reduce;}
    vx_core::Type_any Class_any_from_list_start_reduce::vx_type() const {return vx_core::t_any_from_list_start_reduce;}
    vx_core::Type_msgblock Class_any_from_list_start_reduce::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_list_start_reduce::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_list_start_reduce::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list list = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any valstart = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Func_any_from_reduce fn_reduce = vx_core::vx_any_from_any(vx_core::t_any_from_reduce, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function any_from_list_start_reduce_next
   * Returns a val from a list reduce operation
   * @param  {list-2} list
   * @param  {any-1} valstart
   * @param  {any<-reduce-next} fn-reduce-next
   * @return {any-1}
   * (func any<-list-start-reduce-next)
   */
  // (func any<-list-start-reduce-next)
  // class Class_any_from_list_start_reduce_next {
    Abstract_any_from_list_start_reduce_next::~Abstract_any_from_list_start_reduce_next() {}

    Class_any_from_list_start_reduce_next::Class_any_from_list_start_reduce_next() : Abstract_any_from_list_start_reduce_next::Abstract_any_from_list_start_reduce_next() {
      vx_core::refcount += 1;
    }

    Class_any_from_list_start_reduce_next::~Class_any_from_list_start_reduce_next() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_any_from_list_start_reduce_next::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_list_start_reduce_next output = vx_core::e_any_from_list_start_reduce_next;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_list_start_reduce_next::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_list_start_reduce_next output = vx_core::e_any_from_list_start_reduce_next;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_list_start_reduce_next::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce-next", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_list_start_reduce_next::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_list_start_reduce_next::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce-next", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_list_start_reduce_next::vx_empty() const {return vx_core::e_any_from_list_start_reduce_next;}
    vx_core::Type_any Class_any_from_list_start_reduce_next::vx_type() const {return vx_core::t_any_from_list_start_reduce_next;}
    vx_core::Type_msgblock Class_any_from_list_start_reduce_next::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_list_start_reduce_next::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_list_start_reduce_next::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list list = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any valstart = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Func_any_from_reduce_next fn_reduce_next = vx_core::vx_any_from_any(vx_core::t_any_from_reduce_next, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function any_from_map
   * Returns value from a map or empty if not found
   * @param  {map-1} valuemap
   * @param  {string} key
   * @return {any-1}
   * (func any<-map)
   */
  // (func any<-map)
  // class Class_any_from_map {
    Abstract_any_from_map::~Abstract_any_from_map() {}

    Class_any_from_map::Class_any_from_map() : Abstract_any_from_map::Abstract_any_from_map() {
      vx_core::refcount += 1;
    }

    Class_any_from_map::~Class_any_from_map() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_any_from_map::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_map output = vx_core::e_any_from_map;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_map::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_map output = vx_core::e_any_from_map;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_map::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-map", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_map::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_map::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-map", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_map::vx_empty() const {return vx_core::e_any_from_map;}
    vx_core::Type_any Class_any_from_map::vx_type() const {return vx_core::t_any_from_map;}
    vx_core::Type_msgblock Class_any_from_map::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_map::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_map::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_map valuemap = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string key = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_any_from_map(generic_any_1, valuemap, key);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function any_from_none
   * Function Type returning Generic any-1 with no parameters
   * @return {any-1}
   * (func any<-none)
   */
  // (func any<-none)
  // class Class_any_from_none {
    Abstract_any_from_none::~Abstract_any_from_none() {}

    Class_any_from_none::Class_any_from_none() : Abstract_any_from_none::Abstract_any_from_none() {
      vx_core::refcount += 1;
    }

    Class_any_from_none::~Class_any_from_none() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_none Class_any_from_none::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_none::IFn fn) const {
      vx_core::Func_any_from_none output = new vx_core::Class_any_from_none();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_none::vx_any_from_none() const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn();
      }
      return output;
    }

    vx_core::Type_any Class_any_from_none::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_none output = vx_core::e_any_from_none;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_none::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_none output = vx_core::e_any_from_none;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_none::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-none", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_none::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_none::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-none", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_none::vx_empty() const {return vx_core::e_any_from_none;}
    vx_core::Type_any Class_any_from_none::vx_type() const {return vx_core::t_any_from_none;}
    vx_core::Type_msgblock Class_any_from_none::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_none::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_none::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_any_from_none(generic_any_1);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function any_from_none_async
   * Function Type returning Generic any-1 with no parameters
   * @return {any-1}
   * (func any<-none-async)
   */
  // (func any<-none-async)
  // class Class_any_from_none_async {
    Abstract_any_from_none_async::~Abstract_any_from_none_async() {}

    Class_any_from_none_async::Class_any_from_none_async() : Abstract_any_from_none_async::Abstract_any_from_none_async() {
      vx_core::refcount += 1;
    }

    Class_any_from_none_async::~Class_any_from_none_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_none_async Class_any_from_none_async::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_none_async::IFn fn) const {
      vx_core::Func_any_from_none_async output = new vx_core::Class_any_from_none_async();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::vx_Type_async Class_any_from_none_async::vx_any_from_none_async(vx_core::Type_any generic_any_1) const {
      vx_core::vx_Type_async output = NULL;
      if (fn) {
        output = fn();
        output->type = generic_any_1;
      } else {
        output = vx_core::vx_async_new_from_value(vx_core::vx_empty(generic_any_1));
      }
      return output;
    }

    vx_core::Type_any Class_any_from_none_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_none_async output = vx_core::e_any_from_none_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_none_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_none_async output = vx_core::e_any_from_none_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_none_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-none-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_none_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_none_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-none-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_none_async::vx_empty() const {return vx_core::e_any_from_none_async;}
    vx_core::Type_any Class_any_from_none_async::vx_type() const {return vx_core::t_any_from_none_async;}
    vx_core::Type_msgblock Class_any_from_none_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_none_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_any_from_none_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_any_from_none_async(generic_any_1);
      vx_core::vx_release(arglist);
      return output;
    }

  //}
  /**
   * @function any_from_reduce
   * @param  {any-1} result
   * @param  {any-2} item
   * @return {any-1}
   * (func any<-reduce)
   */
  // (func any<-reduce)
  // class Class_any_from_reduce {
    Abstract_any_from_reduce::~Abstract_any_from_reduce() {}

    Class_any_from_reduce::Class_any_from_reduce() : Abstract_any_from_reduce::Abstract_any_from_reduce() {
      vx_core::refcount += 1;
    }

    Class_any_from_reduce::~Class_any_from_reduce() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_reduce Class_any_from_reduce::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_reduce::IFn fn) const {
      vx_core::Func_any_from_reduce output = new vx_core::Class_any_from_reduce();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_reduce::vx_any_from_reduce(vx_core::Type_any result, vx_core::Type_any item) const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn(result, item);
      }
      return output;
    }

    vx_core::Type_any Class_any_from_reduce::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_reduce output = vx_core::e_any_from_reduce;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_reduce::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_reduce output = vx_core::e_any_from_reduce;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_reduce::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-reduce", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_reduce::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_reduce::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-reduce", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_reduce::vx_empty() const {return vx_core::e_any_from_reduce;}
    vx_core::Type_any Class_any_from_reduce::vx_type() const {return vx_core::t_any_from_reduce;}
    vx_core::Type_msgblock Class_any_from_reduce::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_reduce::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_reduce::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any result = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any item = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_any_from_reduce(generic_any_1, result, item);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function any_from_reduce_async
   * @param  {any-1} result
   * @param  {any-2} item
   * @return {any-1}
   * (func any<-reduce-async)
   */
  // (func any<-reduce-async)
  // class Class_any_from_reduce_async {
    Abstract_any_from_reduce_async::~Abstract_any_from_reduce_async() {}

    Class_any_from_reduce_async::Class_any_from_reduce_async() : Abstract_any_from_reduce_async::Abstract_any_from_reduce_async() {
      vx_core::refcount += 1;
    }

    Class_any_from_reduce_async::~Class_any_from_reduce_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_reduce_async Class_any_from_reduce_async::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_reduce_async::IFn fn) const {
      vx_core::Func_any_from_reduce_async output = new vx_core::Class_any_from_reduce_async();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::vx_Type_async Class_any_from_reduce_async::vx_any_from_reduce_async(vx_core::Type_any generic_any_1, vx_core::Type_any result, vx_core::Type_any item) const {
      vx_core::vx_Type_async output = NULL;
      if (fn) {
        output = fn(result, item);
        output->type = generic_any_1;
      } else {
        output = vx_core::vx_async_new_from_value(vx_core::vx_empty(generic_any_1));
      }
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_reduce_async output = vx_core::e_any_from_reduce_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_reduce_async output = vx_core::e_any_from_reduce_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_reduce_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-reduce-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_reduce_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_reduce_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_async::vx_empty() const {return vx_core::e_any_from_reduce_async;}
    vx_core::Type_any Class_any_from_reduce_async::vx_type() const {return vx_core::t_any_from_reduce_async;}
    vx_core::Type_msgblock Class_any_from_reduce_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_reduce_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_any_from_reduce_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any result = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any item = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_any_from_reduce_async(generic_any_1, result, item);
      vx_core::vx_release(arglist);
      return output;
    }

  //}
  /**
   * @function any_from_reduce_next
   * @param  {any-1} result
   * @param  {any-2} current
   * @param  {any-2} next
   * @return {any-1}
   * (func any<-reduce-next)
   */
  // (func any<-reduce-next)
  // class Class_any_from_reduce_next {
    Abstract_any_from_reduce_next::~Abstract_any_from_reduce_next() {}

    Class_any_from_reduce_next::Class_any_from_reduce_next() : Abstract_any_from_reduce_next::Abstract_any_from_reduce_next() {
      vx_core::refcount += 1;
    }

    Class_any_from_reduce_next::~Class_any_from_reduce_next() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_reduce_next Class_any_from_reduce_next::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_reduce_next::IFn fn) const {
      vx_core::Func_any_from_reduce_next output = new vx_core::Class_any_from_reduce_next();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_next::vx_any_from_reduce_next(vx_core::Type_any result, vx_core::Type_any current, vx_core::Type_any next) const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn(result, current, next);
      }
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_next::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_reduce_next output = vx_core::e_any_from_reduce_next;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_next::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_reduce_next output = vx_core::e_any_from_reduce_next;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_reduce_next::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-reduce-next", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_reduce_next::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_reduce_next::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_next::vx_empty() const {return vx_core::e_any_from_reduce_next;}
    vx_core::Type_any Class_any_from_reduce_next::vx_type() const {return vx_core::t_any_from_reduce_next;}
    vx_core::Type_msgblock Class_any_from_reduce_next::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_reduce_next::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_reduce_next::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any result = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any current = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Type_any next = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_any_from_reduce_next(generic_any_1, result, current, next);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function any_from_reduce_next_async
   * @param  {any-1} result
   * @param  {any-2} current
   * @param  {any-2} next
   * @return {any-1}
   * (func any<-reduce-next-async)
   */
  // (func any<-reduce-next-async)
  // class Class_any_from_reduce_next_async {
    Abstract_any_from_reduce_next_async::~Abstract_any_from_reduce_next_async() {}

    Class_any_from_reduce_next_async::Class_any_from_reduce_next_async() : Abstract_any_from_reduce_next_async::Abstract_any_from_reduce_next_async() {
      vx_core::refcount += 1;
    }

    Class_any_from_reduce_next_async::~Class_any_from_reduce_next_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_reduce_next_async Class_any_from_reduce_next_async::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_reduce_next_async::IFn fn) const {
      vx_core::Func_any_from_reduce_next_async output = new vx_core::Class_any_from_reduce_next_async();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::vx_Type_async Class_any_from_reduce_next_async::vx_any_from_reduce_next_async(vx_core::Type_any generic_any_1, vx_core::Type_any result, vx_core::Type_any current, vx_core::Type_any next) const {
      vx_core::vx_Type_async output = NULL;
      if (fn) {
        output = fn(result, current, next);
        output->type = generic_any_1;
      } else {
        output = vx_core::vx_async_new_from_value(vx_core::vx_empty(generic_any_1));
      }
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_next_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_reduce_next_async output = vx_core::e_any_from_reduce_next_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_next_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_reduce_next_async output = vx_core::e_any_from_reduce_next_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_reduce_next_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-reduce-next-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_reduce_next_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_reduce_next_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_reduce_next_async::vx_empty() const {return vx_core::e_any_from_reduce_next_async;}
    vx_core::Type_any Class_any_from_reduce_next_async::vx_type() const {return vx_core::t_any_from_reduce_next_async;}
    vx_core::Type_msgblock Class_any_from_reduce_next_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_reduce_next_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_any_from_reduce_next_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any result = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any current = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Type_any next = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_any_from_reduce_next_async(generic_any_1, result, current, next);
      vx_core::vx_release(arglist);
      return output;
    }

  //}
  /**
   * @function any_from_struct
   * Returns value from a struct
   * @param  {struct-2} vstruct
   * @param  {string} key
   * @return {any-1}
   * (func any<-struct)
   */
  // (func any<-struct)
  // class Class_any_from_struct {
    Abstract_any_from_struct::~Abstract_any_from_struct() {}

    Class_any_from_struct::Class_any_from_struct() : Abstract_any_from_struct::Abstract_any_from_struct() {
      vx_core::refcount += 1;
    }

    Class_any_from_struct::~Class_any_from_struct() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_any_from_struct::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_struct output = vx_core::e_any_from_struct;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_struct::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_struct output = vx_core::e_any_from_struct;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_struct::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-struct", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_struct::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_struct::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-struct", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_struct::vx_empty() const {return vx_core::e_any_from_struct;}
    vx_core::Type_any Class_any_from_struct::vx_type() const {return vx_core::t_any_from_struct;}
    vx_core::Type_msgblock Class_any_from_struct::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_struct::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_struct::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_struct vstruct = vx_core::vx_any_from_any(vx_core::t_struct, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string key = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_any_from_struct(generic_any_1, vstruct, key);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function async
   * Returns an asynchonous version value. This exists mostly for type-casting.
   * @param  {any-1} value
   * @return {any-1}
   * (func async)
   */
  // (func async)
  // class Class_async {
    Abstract_async::~Abstract_async() {}

    Class_async::Class_async() : Abstract_async::Abstract_async() {
      vx_core::refcount += 1;
    }

    Class_async::~Class_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_async output = vx_core::e_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_async output = vx_core::e_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_async::vx_empty() const {return vx_core::e_async;}
    vx_core::Type_any Class_async::vx_type() const {return vx_core::t_async;}
    vx_core::Type_msgblock Class_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any_async Class_async::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_async::IFn fn) const {
      return vx_core::e_any_from_any_async;
    }

    vx_core::vx_Type_async Class_async::vx_any_from_any_async(vx_core::Type_any generic_any_1, vx_core::Type_any val) const {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(val);
      vx_core::vx_release(val);
      return output;
    }

    vx_core::vx_Type_async Class_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_async(generic_any_1, value);
      vx_core::vx_release(arglist);
      return output;
    }

  //}

  // (func boolean<-any)
  vx_core::Type_boolean f_boolean_from_any(vx_core::Type_any value) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(value);
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function boolean_from_any
   * Function Type taking generic any-1 and returning boolean
   * @param  {any-1} value
   * @return {boolean}
   * (func boolean<-any)
   */
  // (func boolean<-any)
  // class Class_boolean_from_any {
    Abstract_boolean_from_any::~Abstract_boolean_from_any() {}

    Class_boolean_from_any::Class_boolean_from_any() : Abstract_boolean_from_any::Abstract_boolean_from_any() {
      vx_core::refcount += 1;
    }

    Class_boolean_from_any::~Class_boolean_from_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_boolean_from_any Class_boolean_from_any::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_boolean_from_any::IFn fn) const {
      vx_core::Func_boolean_from_any output = new vx_core::Class_boolean_from_any();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_boolean Class_boolean_from_any::vx_boolean_from_any(vx_core::Type_any value) const {
      vx_core::Type_boolean output = vx_core::e_boolean;
      if (fn) {
        output = fn(value);
      }
      return output;
    }

    vx_core::Type_any Class_boolean_from_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_from_any output = vx_core::e_boolean_from_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_boolean_from_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_from_any output = vx_core::e_boolean_from_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_boolean_from_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "boolean<-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_boolean_from_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_boolean_from_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "boolean<-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_boolean_from_any::vx_empty() const {return vx_core::e_boolean_from_any;}
    vx_core::Type_any Class_boolean_from_any::vx_type() const {return vx_core::t_boolean_from_any;}
    vx_core::Type_msgblock Class_boolean_from_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_boolean_from_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_boolean_from_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_boolean_from_any(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func boolean<-func)
  vx_core::Type_boolean f_boolean_from_func() {
    vx_core::Type_boolean output = vx_core::e_boolean;
    return output;
  }
  /**
   * @function boolean_from_func
   * Function Type returning boolean with any parameters
   * @return {boolean}
   * (func boolean<-func)
   */
  // (func boolean<-func)
  // class Class_boolean_from_func {
    Abstract_boolean_from_func::~Abstract_boolean_from_func() {}

    Class_boolean_from_func::Class_boolean_from_func() : Abstract_boolean_from_func::Abstract_boolean_from_func() {
      vx_core::refcount += 1;
    }

    Class_boolean_from_func::~Class_boolean_from_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Type_any Class_boolean_from_func::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_from_func output = vx_core::e_boolean_from_func;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_boolean_from_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_from_func output = vx_core::e_boolean_from_func;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_boolean_from_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "boolean<-func", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_boolean_from_func::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_boolean_from_func::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "boolean<-func", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_boolean_from_func::vx_empty() const {return vx_core::e_boolean_from_func;}
    vx_core::Type_any Class_boolean_from_func::vx_type() const {return vx_core::t_boolean_from_func;}
    vx_core::Type_msgblock Class_boolean_from_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_boolean_from_func::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_boolean_from_func vx_core::Class_boolean_from_func::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_boolean_from_func::IFn fn) const {
      vx_core::Func_boolean_from_func output = new vx_core::Class_boolean_from_func();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_boolean Class_boolean_from_func::vx_boolean_from_func() const {
      vx_core::Type_boolean output = vx_core::e_boolean;
      if (fn) {
        output = fn();
      }
      return output;
    }

    vx_core::Type_any Class_boolean_from_func::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      output = vx_core::f_boolean_from_func();
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func boolean<-none)
  vx_core::Type_boolean f_boolean_from_none() {
    vx_core::Type_boolean output = vx_core::e_boolean;
    return output;
  }
  /**
   * @function boolean_from_none
   * Function Type returning boolean with no parameters
   * @return {boolean}
   * (func boolean<-none)
   */
  // (func boolean<-none)
  // class Class_boolean_from_none {
    Abstract_boolean_from_none::~Abstract_boolean_from_none() {}

    Class_boolean_from_none::Class_boolean_from_none() : Abstract_boolean_from_none::Abstract_boolean_from_none() {
      vx_core::refcount += 1;
    }

    Class_boolean_from_none::~Class_boolean_from_none() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Type_any Class_boolean_from_none::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_from_none output = vx_core::e_boolean_from_none;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_boolean_from_none::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_from_none output = vx_core::e_boolean_from_none;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_boolean_from_none::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "boolean<-none", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_boolean_from_none::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_boolean_from_none::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "boolean<-none", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_boolean_from_none::vx_empty() const {return vx_core::e_boolean_from_none;}
    vx_core::Type_any Class_boolean_from_none::vx_type() const {return vx_core::t_boolean_from_none;}
    vx_core::Type_msgblock Class_boolean_from_none::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_boolean_from_none::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_boolean_from_none vx_core::Class_boolean_from_none::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_boolean_from_func::IFn fn) const {
      vx_core::Func_boolean_from_none output = new vx_core::Class_boolean_from_none();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_boolean Class_boolean_from_none::vx_boolean_from_none() const {
      vx_core::Type_boolean output = vx_core::e_boolean;
      if (fn) {
        output = fn();
      }
      return output;
    }

    vx_core::Type_any Class_boolean_from_none::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      output = vx_core::f_boolean_from_none();
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function empty
   * Returns the empty value for a given type. Can be called using (empty type) or simply (type)
   * @param  {any-1} type
   * @return {any-1}
   * (func empty)
   */
  // (func empty)
  // class Class_empty {
    Abstract_empty::~Abstract_empty() {}

    Class_empty::Class_empty() : Abstract_empty::Abstract_empty() {
      vx_core::refcount += 1;
    }

    Class_empty::~Class_empty() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_empty::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_empty output = vx_core::e_empty;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_empty::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_empty output = vx_core::e_empty;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_empty::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "empty", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_empty::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_empty::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "empty", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_empty::vx_empty() const {return vx_core::e_empty;}
    vx_core::Type_any Class_empty::vx_type() const {return vx_core::t_empty;}
    vx_core::Type_msgblock Class_empty::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_empty::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_empty::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_empty::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_empty(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_empty::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any type = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_empty(type);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function new
   * Create a new Value of Type A
   * @param  {anylist} values
   * @return {any-1}
   * (func new)
   */
  // (func new)
  // class Class_new {
    Abstract_new::~Abstract_new() {}

    Class_new::Class_new() : Abstract_new::Abstract_new() {
      vx_core::refcount += 1;
    }

    Class_new::~Class_new() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_new::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_new output = vx_core::e_new;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_new::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_new output = vx_core::e_new;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_new::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "new", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_new::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_new::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "new", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_new::vx_empty() const {return vx_core::e_new;}
    vx_core::Type_any Class_new::vx_type() const {return vx_core::t_new;}
    vx_core::Type_msgblock Class_new::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_new::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_new::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_new::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist inputval = vx_core::vx_any_from_any(vx_core::t_anylist, val);
      output = vx_core::f_new(vx_core::t_any, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_new::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_anylist values = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_new(generic_any_1, values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function copy
   * Returns a copy of a given value with the given values added or updated.
   * @param  {any-1} value
   * @param  {anylist} values
   * @return {any-1}
   * (func copy)
   */
  // (func copy)
  // class Class_copy {
    Abstract_copy::~Abstract_copy() {}

    Class_copy::Class_copy() : Abstract_copy::Abstract_copy() {
      vx_core::refcount += 1;
    }

    Class_copy::~Class_copy() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_copy::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_copy output = vx_core::e_copy;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_copy::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_copy output = vx_core::e_copy;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_copy::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "copy", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_copy::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_copy::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "copy", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_copy::vx_empty() const {return vx_core::e_copy;}
    vx_core::Type_any Class_copy::vx_type() const {return vx_core::t_copy;}
    vx_core::Type_msgblock Class_copy::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_copy::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_copy::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_anylist values = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_copy(generic_any_1, value, values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func is-empty)
  vx_core::Type_boolean f_is_empty(vx_core::Type_string text) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(text);
    if (text->vx_p_iref == -2) {
      output = vx_core::c_true;
    };
    vx_core::vx_release_one_except(text, output);
    return output;
  }
  /**
   * @function is_empty
   * Returns true if text is empty.
   * @param  {string} text
   * @return {boolean}
   * (func is-empty)
   */
  // (func is-empty)
  // class Class_is_empty {
    Abstract_is_empty::~Abstract_is_empty() {}

    Class_is_empty::Class_is_empty() : Abstract_is_empty::Abstract_is_empty() {
      vx_core::refcount += 1;
    }

    Class_is_empty::~Class_is_empty() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_is_empty::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_empty output = vx_core::e_is_empty;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_is_empty::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_empty output = vx_core::e_is_empty;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_is_empty::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "is-empty", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_is_empty::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_is_empty::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_is_empty::vx_empty() const {return vx_core::e_is_empty;}
    vx_core::Type_any Class_is_empty::vx_type() const {return vx_core::t_is_empty;}
    vx_core::Type_msgblock Class_is_empty::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_is_empty::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_is_empty::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_is_empty::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_is_empty(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_is_empty::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string text = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_is_empty(text);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func is-empty)
  vx_core::Type_boolean f_is_empty_1(vx_core::Type_any value) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(value);
    if (value == value->vx_empty()) {
      output = vx_core::c_true;
    };
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function is_empty 1
   * Returns true if an value is empty
   * @param  {any} value
   * @return {boolean}
   * (func is-empty)
   */
  // (func is-empty)
  // class Class_is_empty_1 {
    Abstract_is_empty_1::~Abstract_is_empty_1() {}

    Class_is_empty_1::Class_is_empty_1() : Abstract_is_empty_1::Abstract_is_empty_1() {
      vx_core::refcount += 1;
    }

    Class_is_empty_1::~Class_is_empty_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_is_empty_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_empty_1 output = vx_core::e_is_empty_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_is_empty_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_empty_1 output = vx_core::e_is_empty_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_is_empty_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "is-empty", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_is_empty_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_is_empty_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_is_empty_1::vx_empty() const {return vx_core::e_is_empty_1;}
    vx_core::Type_any Class_is_empty_1::vx_type() const {return vx_core::t_is_empty_1;}
    vx_core::Type_msgblock Class_is_empty_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_is_empty_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_is_empty_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_is_empty_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_is_empty_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_is_empty_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_is_empty_1(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func !)
  vx_core::Type_boolean f_not(vx_core::Type_boolean value) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(value);
    output = vx_core::vx_new_boolean(!value->vx_boolean());
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function not
   * Boolean not
   * @param  {boolean} value Thing to not
   * @return {boolean}
   * (func !)
   */
  // (func !)
  // class Class_not {
    Abstract_not::~Abstract_not() {}

    Class_not::Class_not() : Abstract_not::Abstract_not() {
      vx_core::refcount += 1;
    }

    Class_not::~Class_not() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_not::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_not output = vx_core::e_not;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_not::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_not output = vx_core::e_not;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_not::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "!", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_not::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_not::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "!", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_not::vx_empty() const {return vx_core::e_not;}
    vx_core::Type_any Class_not::vx_type() const {return vx_core::t_not;}
    vx_core::Type_msgblock Class_not::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_not::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_not::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_not::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_boolean inputval = vx_core::vx_any_from_any(vx_core::t_boolean, val);
      output = vx_core::f_not(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_not::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_boolean value = vx_core::vx_any_from_any(vx_core::t_boolean, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_not(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func !-empty)
  vx_core::Type_boolean f_notempty(vx_core::Type_string text) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(text);
    output = vx_core::f_not(
      vx_core::f_is_empty(text)
    );
    vx_core::vx_release_one_except(text, output);
    return output;
  }
  /**
   * @function notempty
   * Returns true if text is not empty.
   * @param  {string} text
   * @return {boolean}
   * (func !-empty)
   */
  // (func !-empty)
  // class Class_notempty {
    Abstract_notempty::~Abstract_notempty() {}

    Class_notempty::Class_notempty() : Abstract_notempty::Abstract_notempty() {
      vx_core::refcount += 1;
    }

    Class_notempty::~Class_notempty() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_notempty::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_notempty output = vx_core::e_notempty;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_notempty::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_notempty output = vx_core::e_notempty;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_notempty::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "!-empty", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_notempty::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_notempty::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_notempty::vx_empty() const {return vx_core::e_notempty;}
    vx_core::Type_any Class_notempty::vx_type() const {return vx_core::t_notempty;}
    vx_core::Type_msgblock Class_notempty::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_notempty::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_notempty::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_notempty::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_notempty(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_notempty::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string text = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_notempty(text);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func !-empty)
  vx_core::Type_boolean f_notempty_1(vx_core::Type_any value) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(value);
    output = vx_core::f_not(
      vx_core::f_is_empty_1(value)
    );
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function notempty 1
   * Returns true if value is not empty.
   * @param  {any} value
   * @return {boolean}
   * (func !-empty)
   */
  // (func !-empty)
  // class Class_notempty_1 {
    Abstract_notempty_1::~Abstract_notempty_1() {}

    Class_notempty_1::Class_notempty_1() : Abstract_notempty_1::Abstract_notempty_1() {
      vx_core::refcount += 1;
    }

    Class_notempty_1::~Class_notempty_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_notempty_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_notempty_1 output = vx_core::e_notempty_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_notempty_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_notempty_1 output = vx_core::e_notempty_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_notempty_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "!-empty", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_notempty_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_notempty_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_notempty_1::vx_empty() const {return vx_core::e_notempty_1;}
    vx_core::Type_any Class_notempty_1::vx_type() const {return vx_core::t_notempty_1;}
    vx_core::Type_msgblock Class_notempty_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_notempty_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_notempty_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_notempty_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_notempty_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_notempty_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_notempty_1(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func =)
  vx_core::Type_boolean f_eq(vx_core::Type_any val1, vx_core::Type_any val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    bool isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      std::string str1 = vx_core::vx_string_from_any(val1);
      std::string str2 = vx_core::vx_string_from_any(val2);
      if (str1 == str2) {
        isequal = true;
      }
    }
    output = vx_core::vx_new_boolean(isequal);
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function eq
   * Boolean equal/equivalent
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func =)
   */
  // (func =)
  // class Class_eq {
    Abstract_eq::~Abstract_eq() {}

    Class_eq::Class_eq() : Abstract_eq::Abstract_eq() {
      vx_core::refcount += 1;
    }

    Class_eq::~Class_eq() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_eq::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_eq output = vx_core::e_eq;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_eq::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_eq output = vx_core::e_eq;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_eq::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "=", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_eq::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_eq::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "=", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_eq::vx_empty() const {return vx_core::e_eq;}
    vx_core::Type_any Class_eq::vx_type() const {return vx_core::t_eq;}
    vx_core::Type_msgblock Class_eq::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_eq::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_eq::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any val1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any val2 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_eq(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func =)
  vx_core::Type_boolean f_eq_1(vx_core::Type_anylist values) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(values);
    output = vx_core::f_any_from_list_start_reduce_next(
      vx_core::t_boolean,
      values,
      vx_core::vx_new_boolean(false),
      vx_core::t_any_from_reduce_next->vx_fn_new({}, [](vx_core::Type_any reduce_any, vx_core::Type_any current, vx_core::Type_any next) {
        vx_core::Type_boolean reduce = vx_core::vx_any_from_any(vx_core::t_boolean, reduce_any);
        vx_core::Type_any output_1 = 
          vx_core::f_and(
            reduce,
            vx_core::f_eq(current, next)
          );
        return output_1;
      })
    );
    vx_core::vx_release_one_except(values, output);
    return output;
  }
  /**
   * @function eq 1
   * Boolean equal/equivalent
   * @param  {anylist} values
   * @return {boolean}
   * (func =)
   */
  // (func =)
  // class Class_eq_1 {
    Abstract_eq_1::~Abstract_eq_1() {}

    Class_eq_1::Class_eq_1() : Abstract_eq_1::Abstract_eq_1() {
      vx_core::refcount += 1;
    }

    Class_eq_1::~Class_eq_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_eq_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_eq_1 output = vx_core::e_eq_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_eq_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_eq_1 output = vx_core::e_eq_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_eq_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "=", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_eq_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_eq_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "=", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_eq_1::vx_empty() const {return vx_core::e_eq_1;}
    vx_core::Type_any Class_eq_1::vx_type() const {return vx_core::t_eq_1;}
    vx_core::Type_msgblock Class_eq_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_eq_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_eq_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_eq_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist inputval = vx_core::vx_any_from_any(vx_core::t_anylist, val);
      output = vx_core::f_eq_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_eq_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist values = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_eq_1(values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func !=)
  vx_core::Type_boolean f_ne(vx_core::Type_any val1, vx_core::Type_any val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    output = vx_core::f_not(
      vx_core::f_eq(val1, val2)
    );
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function ne
   * Returns true if the first arg is not equal to any of the other arg.
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func !=)
   */
  // (func !=)
  // class Class_ne {
    Abstract_ne::~Abstract_ne() {}

    Class_ne::Class_ne() : Abstract_ne::Abstract_ne() {
      vx_core::refcount += 1;
    }

    Class_ne::~Class_ne() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_ne::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_ne output = vx_core::e_ne;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_ne::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_ne output = vx_core::e_ne;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_ne::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "!=", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_ne::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_ne::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "!=", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_ne::vx_empty() const {return vx_core::e_ne;}
    vx_core::Type_any Class_ne::vx_type() const {return vx_core::t_ne;}
    vx_core::Type_msgblock Class_ne::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_ne::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_ne::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any val1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any val2 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_ne(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func then)
  vx_core::Type_thenelse f_then(vx_core::Func_boolean_from_func fn_cond, vx_core::Func_any_from_func fn_any) {
    vx_core::Type_thenelse output = vx_core::e_thenelse;
    vx_core::vx_reserve({fn_cond, fn_any});
    output = vx_core::f_new(
      vx_core::t_thenelse,
      vx_core::vx_new(vx_core::t_anylist, {
        vx_core::vx_new_string(":code"),
        vx_core::vx_new_string(":then"),
        vx_core::vx_new_string(":fn-cond"),
        fn_cond,
        vx_core::vx_new_string(":fn-any"),
        fn_any
      })
    );
    vx_core::vx_release_one_except({fn_cond, fn_any}, output);
    return output;
  }
  /**
   * @function then
   * Returns a thenelse struct from a given condition function and value function
   * @param  {boolean<-func} fn-cond
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func then)
   */
  // (func then)
  // class Class_then {
    Abstract_then::~Abstract_then() {}

    Class_then::Class_then() : Abstract_then::Abstract_then() {
      vx_core::refcount += 1;
    }

    Class_then::~Class_then() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_then::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_then output = vx_core::e_then;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_then::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_then output = vx_core::e_then;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_then::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "then", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_then::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_then::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "then", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_then::vx_empty() const {return vx_core::e_then;}
    vx_core::Type_any Class_then::vx_type() const {return vx_core::t_then;}
    vx_core::Type_msgblock Class_then::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_then::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_then::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Func_boolean_from_func fn_cond = vx_core::vx_any_from_any(vx_core::t_boolean_from_func, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_func fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_then(fn_cond, fn_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func else)
  vx_core::Type_thenelse f_else(vx_core::Func_any_from_func fn_any) {
    vx_core::Type_thenelse output = vx_core::e_thenelse;
    vx_core::vx_reserve(fn_any);
    output = vx_core::f_new(
      vx_core::t_thenelse,
      vx_core::vx_new(vx_core::t_anylist, {
        vx_core::vx_new_string(":code"),
        vx_core::vx_new_string(":else"),
        vx_core::vx_new_string(":fn-any"),
        fn_any
      })
    );
    vx_core::vx_release_one_except(fn_any, output);
    return output;
  }
  /**
   * @function else
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func else)
   */
  // (func else)
  // class Class_else {
    Abstract_else::~Abstract_else() {}

    Class_else::Class_else() : Abstract_else::Abstract_else() {
      vx_core::refcount += 1;
    }

    Class_else::~Class_else() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_else::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_else output = vx_core::e_else;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_else::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_else output = vx_core::e_else;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_else::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "else", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_else::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_else::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "else", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_else::vx_empty() const {return vx_core::e_else;}
    vx_core::Type_any Class_else::vx_type() const {return vx_core::t_else;}
    vx_core::Type_msgblock Class_else::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_else::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_else::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_else::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Func_any_from_func inputval = vx_core::vx_any_from_any(vx_core::t_any_from_func, val);
      output = vx_core::f_else(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_else::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Func_any_from_func fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_else(fn_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function if
   * Logical If function
   * @param  {boolean} clause
   * @param  {any-1} then
   * @return {any-1}
   * (func if)
   */
  // (func if)
  // class Class_if {
    Abstract_if::~Abstract_if() {}

    Class_if::Class_if() : Abstract_if::Abstract_if() {
      vx_core::refcount += 1;
    }

    Class_if::~Class_if() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_if::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_if output = vx_core::e_if;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_if::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_if output = vx_core::e_if;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_if::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "if", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_if::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_if::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "if", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_if::vx_empty() const {return vx_core::e_if;}
    vx_core::Type_any Class_if::vx_type() const {return vx_core::t_if;}
    vx_core::Type_msgblock Class_if::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_if::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_if::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_boolean clause = vx_core::vx_any_from_any(vx_core::t_boolean, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any then = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_if(generic_any_1, clause, then);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function if 1
   * Logical If function
   * @param  {boolean} clause
   * @param  {any-1} thenval
   * @param  {any-1} elseval
   * @return {any-1}
   * (func if)
   */
  // (func if)
  // class Class_if_1 {
    Abstract_if_1::~Abstract_if_1() {}

    Class_if_1::Class_if_1() : Abstract_if_1::Abstract_if_1() {
      vx_core::refcount += 1;
    }

    Class_if_1::~Class_if_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_if_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_if_1 output = vx_core::e_if_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_if_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_if_1 output = vx_core::e_if_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_if_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "if", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_if_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_if_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "if", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_if_1::vx_empty() const {return vx_core::e_if_1;}
    vx_core::Type_any Class_if_1::vx_type() const {return vx_core::t_if_1;}
    vx_core::Type_msgblock Class_if_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_if_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_if_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_boolean clause = vx_core::vx_any_from_any(vx_core::t_boolean, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any thenval = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Type_any elseval = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_if_1(generic_any_1, clause, thenval, elseval);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function if 2
   * Logical If function
   * @param  {thenelselist} thenelselist
   * @return {any-1}
   * (func if)
   */
  // (func if)
  // class Class_if_2 {
    Abstract_if_2::~Abstract_if_2() {}

    Class_if_2::Class_if_2() : Abstract_if_2::Abstract_if_2() {
      vx_core::refcount += 1;
    }

    Class_if_2::~Class_if_2() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_if_2::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_if_2 output = vx_core::e_if_2;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_if_2::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_if_2 output = vx_core::e_if_2;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_if_2::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "if", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_if_2::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_if_2::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "if", // name
        2, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_if_2::vx_empty() const {return vx_core::e_if_2;}
    vx_core::Type_any Class_if_2::vx_type() const {return vx_core::t_if_2;}
    vx_core::Type_msgblock Class_if_2::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_if_2::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_if_2::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_if_2::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_thenelselist inputval = vx_core::vx_any_from_any(vx_core::t_thenelselist, val);
      output = vx_core::f_if_2(vx_core::t_any, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_if_2::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_thenelselist thenelselist = vx_core::vx_any_from_any(vx_core::t_thenelselist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_if_2(generic_any_1, thenelselist);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func case)
  vx_core::Type_thenelse f_case(vx_core::Type_list values, vx_core::Func_any_from_func fn_any) {
    vx_core::Type_thenelse output = vx_core::e_thenelse;
    vx_core::vx_reserve({values, fn_any});
    output = vx_core::f_new(
      vx_core::t_thenelse,
      vx_core::vx_new(vx_core::t_anylist, {
        vx_core::vx_new_string(":code"),
        vx_core::vx_new_string(":casemany"),
        vx_core::vx_new_string(":values"),
        values,
        vx_core::vx_new_string(":fn-any"),
        fn_any
      })
    );
    vx_core::vx_release_one_except({values, fn_any}, output);
    return output;
  }
  /**
   * @function case
   * @param  {list-1} values
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func case)
   */
  // (func case)
  // class Class_case {
    Abstract_case::~Abstract_case() {}

    Class_case::Class_case() : Abstract_case::Abstract_case() {
      vx_core::refcount += 1;
    }

    Class_case::~Class_case() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_case::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_case output = vx_core::e_case;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_case::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_case output = vx_core::e_case;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_case::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "case", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_case::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_case::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "case", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_case::vx_empty() const {return vx_core::e_case;}
    vx_core::Type_any Class_case::vx_type() const {return vx_core::t_case;}
    vx_core::Type_msgblock Class_case::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_case::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_case::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_func fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_case(values, fn_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func case)
  vx_core::Type_thenelse f_case_1(vx_core::Type_any value, vx_core::Func_any_from_func fn_any) {
    vx_core::Type_thenelse output = vx_core::e_thenelse;
    vx_core::vx_reserve({value, fn_any});
    output = vx_core::f_new(
      vx_core::t_thenelse,
      vx_core::vx_new(vx_core::t_anylist, {
        vx_core::vx_new_string(":code"),
        vx_core::vx_new_string(":case"),
        vx_core::vx_new_string(":value"),
        value,
        vx_core::vx_new_string(":fn-any"),
        fn_any
      })
    );
    vx_core::vx_release_one_except({value, fn_any}, output);
    return output;
  }
  /**
   * @function case 1
   * @param  {any-1} value
   * @param  {any<-func} fn-any
   * @return {thenelse}
   * (func case)
   */
  // (func case)
  // class Class_case_1 {
    Abstract_case_1::~Abstract_case_1() {}

    Class_case_1::Class_case_1() : Abstract_case_1::Abstract_case_1() {
      vx_core::refcount += 1;
    }

    Class_case_1::~Class_case_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_case_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_case_1 output = vx_core::e_case_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_case_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_case_1 output = vx_core::e_case_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_case_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "case", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_case_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_case_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "case", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_case_1::vx_empty() const {return vx_core::e_case_1;}
    vx_core::Type_any Class_case_1::vx_type() const {return vx_core::t_case_1;}
    vx_core::Type_msgblock Class_case_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_case_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_case_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_func fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_case_1(value, fn_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function switch
   * Returns a value based on a logical switch
   * @param  {any-2} value
   * @param  {thenelselist} thenelselist
   * @return {any-1}
   * (func switch)
   */
  // (func switch)
  // class Class_switch {
    Abstract_switch::~Abstract_switch() {}

    Class_switch::Class_switch() : Abstract_switch::Abstract_switch() {
      vx_core::refcount += 1;
    }

    Class_switch::~Class_switch() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_switch::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_switch output = vx_core::e_switch;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_switch::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_switch output = vx_core::e_switch;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_switch::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "switch", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_switch::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_switch::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "switch", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_switch::vx_empty() const {return vx_core::e_switch;}
    vx_core::Type_any Class_switch::vx_type() const {return vx_core::t_switch;}
    vx_core::Type_msgblock Class_switch::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_switch::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_switch::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_thenelselist thenelselist = vx_core::vx_any_from_any(vx_core::t_thenelselist, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_switch(generic_any_1, value, thenelselist);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func length)
  vx_core::Type_int f_length(vx_core::Type_string text) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve(text);
    long len = text->vx_string().length();
    output = vx_core::vx_new_int(len);
    vx_core::vx_release_one_except(text, output);
    return output;
  }
  /**
   * @function length
   * Returns length of a string.
   * @param  {string} text
   * @return {int}
   * (func length)
   */
  // (func length)
  // class Class_length {
    Abstract_length::~Abstract_length() {}

    Class_length::Class_length() : Abstract_length::Abstract_length() {
      vx_core::refcount += 1;
    }

    Class_length::~Class_length() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_length::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_length output = vx_core::e_length;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_length::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_length output = vx_core::e_length;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_length::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "length", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_length::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_length::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "length", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_length::vx_empty() const {return vx_core::e_length;}
    vx_core::Type_any Class_length::vx_type() const {return vx_core::t_length;}
    vx_core::Type_msgblock Class_length::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_length::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_length::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_length::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_length(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_length::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string text = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_length(text);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func length)
  vx_core::Type_int f_length_1(vx_core::Type_list values) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve(values);
    long len = vx_core::vx_int_from_sizet(values->vx_list().size());
    if (len > 0) {
      output = vx_core::vx_new_int(len);
    };
    vx_core::vx_release_one_except(values, output);
    return output;
  }
  /**
   * @function length 1
   * Returns the currently used size/length of a list
   * @param  {list-1} values
   * @return {int}
   * (func length)
   */
  // (func length)
  // class Class_length_1 {
    Abstract_length_1::~Abstract_length_1() {}

    Class_length_1::Class_length_1() : Abstract_length_1::Abstract_length_1() {
      vx_core::refcount += 1;
    }

    Class_length_1::~Class_length_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_length_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_length_1 output = vx_core::e_length_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_length_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_length_1 output = vx_core::e_length_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_length_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "length", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_length_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_length_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "length", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_length_1::vx_empty() const {return vx_core::e_length_1;}
    vx_core::Type_any Class_length_1::vx_type() const {return vx_core::t_length_1;}
    vx_core::Type_msgblock Class_length_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_length_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_length_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_length_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list inputval = vx_core::vx_any_from_any(vx_core::t_list, val);
      output = vx_core::f_length_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_length_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_length_1(values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func length)
  vx_core::Type_int f_length_2(vx_core::Type_map valuemap) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve(valuemap);
    output = vx_core::f_length_1(
      vx_core::f_stringlist_from_map(valuemap)
    );
    vx_core::vx_release_one_except(valuemap, output);
    return output;
  }
  /**
   * @function length 2
   * Returns the length of the given map.
   * @param  {map-1} valuemap
   * @return {int}
   * (func length)
   */
  // (func length)
  // class Class_length_2 {
    Abstract_length_2::~Abstract_length_2() {}

    Class_length_2::Class_length_2() : Abstract_length_2::Abstract_length_2() {
      vx_core::refcount += 1;
    }

    Class_length_2::~Class_length_2() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_length_2::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_length_2 output = vx_core::e_length_2;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_length_2::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_length_2 output = vx_core::e_length_2;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_length_2::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "length", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_length_2::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_length_2::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "length", // name
        2, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_length_2::vx_empty() const {return vx_core::e_length_2;}
    vx_core::Type_any Class_length_2::vx_type() const {return vx_core::t_length_2;}
    vx_core::Type_msgblock Class_length_2::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_length_2::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_length_2::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_length_2::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map inputval = vx_core::vx_any_from_any(vx_core::t_map, val);
      output = vx_core::f_length_2(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_length_2::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map valuemap = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_length_2(valuemap);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func and)
  vx_core::Type_boolean f_and(vx_core::Type_boolean val1, vx_core::Type_boolean val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    if (val1->vx_boolean() && val2->vx_boolean()) {
      output = vx_core::c_true;
    } else {
      output = vx_core::c_false;
    };
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function and
   * Returns true if all values are true
   * @param  {boolean} val1
   * @param  {boolean} val2
   * @return {boolean}
   * (func and)
   */
  // (func and)
  // class Class_and {
    Abstract_and::~Abstract_and() {}

    Class_and::Class_and() : Abstract_and::Abstract_and() {
      vx_core::refcount += 1;
    }

    Class_and::~Class_and() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_and::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_and output = vx_core::e_and;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_and::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_and output = vx_core::e_and;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_and::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "and", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_and::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_and::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "and", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_and::vx_empty() const {return vx_core::e_and;}
    vx_core::Type_any Class_and::vx_type() const {return vx_core::t_and;}
    vx_core::Type_msgblock Class_and::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_and::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_and::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_boolean val1 = vx_core::vx_any_from_any(vx_core::t_boolean, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_boolean val2 = vx_core::vx_any_from_any(vx_core::t_boolean, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_and(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func and)
  vx_core::Type_boolean f_and_1(vx_core::Type_booleanlist values) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(values);
    output = vx_core::f_switch(
      vx_core::t_boolean,
      vx_core::f_length_1(values),
      vx_core::vx_new(vx_core::t_thenelselist, {
        vx_core::f_case_1(
          vx_core::vx_new_int(0),
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_boolean output_1 = vx_core::vx_new_boolean(true);
            return output_1;
          })
        ),
        vx_core::f_case_1(
          vx_core::vx_new_int(1),
          vx_core::t_any_from_func->vx_fn_new({values}, [values]() {
            vx_core::Type_boolean output_1 = vx_core::f_any_from_list(vx_core::t_boolean, values, vx_core::vx_new_int(1));
            return output_1;
          })
        ),
        vx_core::f_else(
          vx_core::t_any_from_func->vx_fn_new({values}, [values]() {
            vx_core::Type_boolean output_1 = vx_core::f_any_from_list_start_reduce_next(
              vx_core::t_boolean,
              values,
              vx_core::vx_new_boolean(true),
              vx_core::t_any_from_reduce_next->vx_fn_new({}, [](vx_core::Type_any reduce_any, vx_core::Type_any current_any, vx_core::Type_any next_any) {
                vx_core::Type_boolean reduce = vx_core::vx_any_from_any(vx_core::t_boolean, reduce_any);
                vx_core::Type_boolean current = vx_core::vx_any_from_any(vx_core::t_boolean, current_any);
                vx_core::Type_boolean next = vx_core::vx_any_from_any(vx_core::t_boolean, next_any);
                vx_core::Type_any output_1 = 
                  vx_core::f_and(
                    reduce,
                    vx_core::f_and(current, next)
                  );
                return output_1;
              })
            );
            return output_1;
          })
        )
      })
    );
    vx_core::vx_release_one_except(values, output);
    return output;
  }
  /**
   * @function and 1
   * Returns true if all values are true
   * @param  {booleanlist} values
   * @return {boolean}
   * (func and)
   */
  // (func and)
  // class Class_and_1 {
    Abstract_and_1::~Abstract_and_1() {}

    Class_and_1::Class_and_1() : Abstract_and_1::Abstract_and_1() {
      vx_core::refcount += 1;
    }

    Class_and_1::~Class_and_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_and_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_and_1 output = vx_core::e_and_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_and_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_and_1 output = vx_core::e_and_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_and_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "and", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_and_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_and_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "and", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_and_1::vx_empty() const {return vx_core::e_and_1;}
    vx_core::Type_any Class_and_1::vx_type() const {return vx_core::t_and_1;}
    vx_core::Type_msgblock Class_and_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_and_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_and_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_and_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_booleanlist inputval = vx_core::vx_any_from_any(vx_core::t_booleanlist, val);
      output = vx_core::f_and_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_and_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_booleanlist values = vx_core::vx_any_from_any(vx_core::t_booleanlist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_and_1(values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func or)
  vx_core::Type_boolean f_or(vx_core::Type_boolean val1, vx_core::Type_boolean val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    if (val1->vx_boolean() || val2->vx_boolean()) {
      output = vx_core::c_true;
    } else {
      output = vx_core::c_false;
    };
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function or
   * Returns true if any value is true
   * @param  {boolean} val1
   * @param  {boolean} val2
   * @return {boolean}
   * (func or)
   */
  // (func or)
  // class Class_or {
    Abstract_or::~Abstract_or() {}

    Class_or::Class_or() : Abstract_or::Abstract_or() {
      vx_core::refcount += 1;
    }

    Class_or::~Class_or() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_or::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_or output = vx_core::e_or;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_or::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_or output = vx_core::e_or;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_or::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "or", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_or::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_or::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "or", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_or::vx_empty() const {return vx_core::e_or;}
    vx_core::Type_any Class_or::vx_type() const {return vx_core::t_or;}
    vx_core::Type_msgblock Class_or::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_or::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_or::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_boolean val1 = vx_core::vx_any_from_any(vx_core::t_boolean, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_boolean val2 = vx_core::vx_any_from_any(vx_core::t_boolean, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_or(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func or)
  vx_core::Type_boolean f_or_1(vx_core::Type_booleanlist values) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(values);
    output = vx_core::f_any_from_list_start_reduce_next(
      vx_core::t_boolean,
      values,
      vx_core::vx_new_boolean(false),
      vx_core::t_any_from_reduce_next->vx_fn_new({}, [](vx_core::Type_any reduce_any, vx_core::Type_any current_any, vx_core::Type_any next_any) {
        vx_core::Type_boolean reduce = vx_core::vx_any_from_any(vx_core::t_boolean, reduce_any);
        vx_core::Type_boolean current = vx_core::vx_any_from_any(vx_core::t_boolean, current_any);
        vx_core::Type_boolean next = vx_core::vx_any_from_any(vx_core::t_boolean, next_any);
        vx_core::Type_any output_1 = 
          vx_core::f_or(
            reduce,
            vx_core::f_or(current, next)
          );
        return output_1;
      })
    );
    vx_core::vx_release_one_except(values, output);
    return output;
  }
  /**
   * @function or 1
   * Returns true if any value is true
   * @param  {booleanlist} values
   * @return {boolean}
   * (func or)
   */
  // (func or)
  // class Class_or_1 {
    Abstract_or_1::~Abstract_or_1() {}

    Class_or_1::Class_or_1() : Abstract_or_1::Abstract_or_1() {
      vx_core::refcount += 1;
    }

    Class_or_1::~Class_or_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_or_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_or_1 output = vx_core::e_or_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_or_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_or_1 output = vx_core::e_or_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_or_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "or", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_or_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_or_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "or", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_or_1::vx_empty() const {return vx_core::e_or_1;}
    vx_core::Type_any Class_or_1::vx_type() const {return vx_core::t_or_1;}
    vx_core::Type_msgblock Class_or_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_or_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_or_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_or_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_booleanlist inputval = vx_core::vx_any_from_any(vx_core::t_booleanlist, val);
      output = vx_core::f_or_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_or_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_booleanlist values = vx_core::vx_any_from_any(vx_core::t_booleanlist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_or_1(values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function let
   * @param  {arglist} args
   * @param  {any<-func} fn-any
   * @return {any-1}
   * (func let)
   */
  // (func let)
  // class Class_let {
    Abstract_let::~Abstract_let() {}

    Class_let::Class_let() : Abstract_let::Abstract_let() {
      vx_core::refcount += 1;
    }

    Class_let::~Class_let() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_let::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_let output = vx_core::e_let;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_let::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_let output = vx_core::e_let;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_let::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "let", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_let::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_let::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "let", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_let::vx_empty() const {return vx_core::e_let;}
    vx_core::Type_any Class_let::vx_type() const {return vx_core::t_let;}
    vx_core::Type_msgblock Class_let::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_let::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_let::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_func fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_let(generic_any_1, fn_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function let_async
   * Same as normal let but returns async values.
   * @param  {arglist} args
   * @param  {any<-func-async} fn-any-async
   * @return {any-1}
   * (func let-async)
   */
  // (func let-async)
  // class Class_let_async {
    Abstract_let_async::~Abstract_let_async() {}

    Class_let_async::Class_let_async() : Abstract_let_async::Abstract_let_async() {
      vx_core::refcount += 1;
    }

    Class_let_async::~Class_let_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_let_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_let_async output = vx_core::e_let_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_let_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_let_async output = vx_core::e_let_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_let_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "let-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_let_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_let_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "let-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_let_async::vx_empty() const {return vx_core::e_let_async;}
    vx_core::Type_any Class_let_async::vx_type() const {return vx_core::t_let_async;}
    vx_core::Type_msgblock Class_let_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_let_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_let_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_func_async fn_any_async = vx_core::vx_any_from_any(vx_core::t_any_from_func_async, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_let_async(generic_any_1, fn_any_async);
      vx_core::vx_release(arglist);
      return output;
    }

  //}

  // (func !==)
  vx_core::Type_boolean f_neqeq(vx_core::Type_any val1, vx_core::Type_any val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    output = vx_core::f_not(
      vx_core::f_eqeq(val1, val2)
    );
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function neqeq
   * Returns true if the first arg is not strictly equal to any of the other arg.
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func !==)
   */
  // (func !==)
  // class Class_neqeq {
    Abstract_neqeq::~Abstract_neqeq() {}

    Class_neqeq::Class_neqeq() : Abstract_neqeq::Abstract_neqeq() {
      vx_core::refcount += 1;
    }

    Class_neqeq::~Class_neqeq() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_neqeq::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_neqeq output = vx_core::e_neqeq;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_neqeq::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_neqeq output = vx_core::e_neqeq;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_neqeq::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "!==", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_neqeq::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_neqeq::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "!==", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_neqeq::vx_empty() const {return vx_core::e_neqeq;}
    vx_core::Type_any Class_neqeq::vx_type() const {return vx_core::t_neqeq;}
    vx_core::Type_msgblock Class_neqeq::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_neqeq::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_neqeq::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any val1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any val2 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_neqeq(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func *)
  vx_core::Type_number f_multiply_3(vx_core::Type_numberlist nums) {
    vx_core::Type_number output = vx_core::e_number;
    vx_core::vx_reserve(nums);
    output = vx_core::f_any_from_list_start_reduce(
      vx_core::t_number,
      nums,
      (vx_core::Type_number)vx_core::vx_new_int(1),
      vx_core::t_any_from_reduce->vx_fn_new({}, [](vx_core::Type_any total_any, vx_core::Type_any num_any) {
        vx_core::Type_number total = vx_core::vx_any_from_any(vx_core::t_number, total_any);
        vx_core::Type_number num = vx_core::vx_any_from_any(vx_core::t_number, num_any);
        vx_core::Type_any output_1 = 
          vx_core::f_multiply_1(total, num);
        return output_1;
      })
    );
    vx_core::vx_release_one_except(nums, output);
    return output;
  }
  /**
   * @function multiply 3
   * Math multiply
   * @param  {numberlist} nums
   * @return {number}
   * (func *)
   */
  // (func *)
  // class Class_multiply_3 {
    Abstract_multiply_3::~Abstract_multiply_3() {}

    Class_multiply_3::Class_multiply_3() : Abstract_multiply_3::Abstract_multiply_3() {
      vx_core::refcount += 1;
    }

    Class_multiply_3::~Class_multiply_3() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_multiply_3::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_multiply_3 output = vx_core::e_multiply_3;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_multiply_3::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_multiply_3 output = vx_core::e_multiply_3;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_multiply_3::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "*", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_multiply_3::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_multiply_3::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "*", // name
        3, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_multiply_3::vx_empty() const {return vx_core::e_multiply_3;}
    vx_core::Type_any Class_multiply_3::vx_type() const {return vx_core::t_multiply_3;}
    vx_core::Type_msgblock Class_multiply_3::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_multiply_3::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_multiply_3::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_multiply_3::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_numberlist inputval = vx_core::vx_any_from_any(vx_core::t_numberlist, val);
      output = vx_core::f_multiply_3(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_multiply_3::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_numberlist nums = vx_core::vx_any_from_any(vx_core::t_numberlist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_multiply_3(nums);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func *)
  vx_core::Type_int f_multiply_2(vx_core::Type_intlist nums) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve(nums);
    output = vx_core::f_any_from_list_start_reduce(
      vx_core::t_int,
      nums,
      vx_core::vx_new_int(1),
      vx_core::t_any_from_reduce->vx_fn_new({}, [](vx_core::Type_any total_any, vx_core::Type_any num_any) {
        vx_core::Type_int total = vx_core::vx_any_from_any(vx_core::t_int, total_any);
        vx_core::Type_int num = vx_core::vx_any_from_any(vx_core::t_int, num_any);
        vx_core::Type_any output_1 = 
          vx_core::f_multiply(total, num);
        return output_1;
      })
    );
    vx_core::vx_release_one_except(nums, output);
    return output;
  }
  /**
   * @function multiply 2
   * Math multiply
   * @param  {intlist} nums
   * @return {int}
   * (func *)
   */
  // (func *)
  // class Class_multiply_2 {
    Abstract_multiply_2::~Abstract_multiply_2() {}

    Class_multiply_2::Class_multiply_2() : Abstract_multiply_2::Abstract_multiply_2() {
      vx_core::refcount += 1;
    }

    Class_multiply_2::~Class_multiply_2() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_multiply_2::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_multiply_2 output = vx_core::e_multiply_2;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_multiply_2::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_multiply_2 output = vx_core::e_multiply_2;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_multiply_2::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "*", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_multiply_2::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_multiply_2::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "*", // name
        2, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_multiply_2::vx_empty() const {return vx_core::e_multiply_2;}
    vx_core::Type_any Class_multiply_2::vx_type() const {return vx_core::t_multiply_2;}
    vx_core::Type_msgblock Class_multiply_2::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_multiply_2::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_multiply_2::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_multiply_2::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_intlist inputval = vx_core::vx_any_from_any(vx_core::t_intlist, val);
      output = vx_core::f_multiply_2(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_multiply_2::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_intlist nums = vx_core::vx_any_from_any(vx_core::t_intlist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_multiply_2(nums);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func *)
  vx_core::Type_number f_multiply_1(vx_core::Type_number num1, vx_core::Type_number num2) {
    vx_core::Type_number output = vx_core::e_number;
    vx_core::vx_reserve({num1, num2});
    float result = vx_core::vx_float_from_number(num1) * vx_core::vx_float_from_number(num2);
    output = vx_core::vx_new_float(result);
    vx_core::vx_release_one_except({num1, num2}, output);
    return output;
  }
  /**
   * @function multiply 1
   * Math multipy
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func *)
   */
  // (func *)
  // class Class_multiply_1 {
    Abstract_multiply_1::~Abstract_multiply_1() {}

    Class_multiply_1::Class_multiply_1() : Abstract_multiply_1::Abstract_multiply_1() {
      vx_core::refcount += 1;
    }

    Class_multiply_1::~Class_multiply_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_multiply_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_multiply_1 output = vx_core::e_multiply_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_multiply_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_multiply_1 output = vx_core::e_multiply_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_multiply_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "*", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_multiply_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_multiply_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "*", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_multiply_1::vx_empty() const {return vx_core::e_multiply_1;}
    vx_core::Type_any Class_multiply_1::vx_type() const {return vx_core::t_multiply_1;}
    vx_core::Type_msgblock Class_multiply_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_multiply_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_multiply_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_number num1 = vx_core::vx_any_from_any(vx_core::t_number, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_number num2 = vx_core::vx_any_from_any(vx_core::t_number, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_multiply_1(num1, num2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func *)
  vx_core::Type_int f_multiply(vx_core::Type_int num1, vx_core::Type_int num2) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve({num1, num2});
    long result = num1->vx_int() * num2->vx_int();
    output = vx_core::vx_new_int(result);
    vx_core::vx_release_one_except({num1, num2}, output);
    return output;
  }
  /**
   * @function multiply
   * Math int multiply
   * @param  {int} num1
   * @param  {int} num2
   * @return {int}
   * (func *)
   */
  // (func *)
  // class Class_multiply {
    Abstract_multiply::~Abstract_multiply() {}

    Class_multiply::Class_multiply() : Abstract_multiply::Abstract_multiply() {
      vx_core::refcount += 1;
    }

    Class_multiply::~Class_multiply() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_multiply::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_multiply output = vx_core::e_multiply;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_multiply::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_multiply output = vx_core::e_multiply;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_multiply::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "*", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_multiply::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_multiply::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "*", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_multiply::vx_empty() const {return vx_core::e_multiply;}
    vx_core::Type_any Class_multiply::vx_type() const {return vx_core::t_multiply;}
    vx_core::Type_msgblock Class_multiply::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_multiply::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_multiply::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_int num1 = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_int num2 = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_multiply(num1, num2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func +)
  vx_core::Type_number f_plus_3(vx_core::Type_numberlist nums) {
    vx_core::Type_number output = vx_core::e_number;
    vx_core::vx_reserve(nums);
    output = vx_core::f_any_from_list_start_reduce(
      vx_core::t_number,
      nums,
      (vx_core::Type_number)vx_core::vx_new_int(0),
      vx_core::t_any_from_reduce->vx_fn_new({}, [](vx_core::Type_any total_any, vx_core::Type_any num_any) {
        vx_core::Type_number total = vx_core::vx_any_from_any(vx_core::t_number, total_any);
        vx_core::Type_number num = vx_core::vx_any_from_any(vx_core::t_number, num_any);
        vx_core::Type_any output_1 = 
          vx_core::f_plus_1(total, num);
        return output_1;
      })
    );
    vx_core::vx_release_one_except(nums, output);
    return output;
  }
  /**
   * @function plus 3
   * Math number plus
   * @param  {numberlist} nums
   * @return {number}
   * (func +)
   */
  // (func +)
  // class Class_plus_3 {
    Abstract_plus_3::~Abstract_plus_3() {}

    Class_plus_3::Class_plus_3() : Abstract_plus_3::Abstract_plus_3() {
      vx_core::refcount += 1;
    }

    Class_plus_3::~Class_plus_3() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_plus_3::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus_3 output = vx_core::e_plus_3;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_plus_3::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus_3 output = vx_core::e_plus_3;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_plus_3::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "+", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_plus_3::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_plus_3::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "+", // name
        3, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_plus_3::vx_empty() const {return vx_core::e_plus_3;}
    vx_core::Type_any Class_plus_3::vx_type() const {return vx_core::t_plus_3;}
    vx_core::Type_msgblock Class_plus_3::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_plus_3::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_plus_3::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_plus_3::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_numberlist inputval = vx_core::vx_any_from_any(vx_core::t_numberlist, val);
      output = vx_core::f_plus_3(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_plus_3::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_numberlist nums = vx_core::vx_any_from_any(vx_core::t_numberlist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_plus_3(nums);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func +)
  vx_core::Type_int f_plus_2(vx_core::Type_intlist nums) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve(nums);
    output = vx_core::f_any_from_list_start_reduce(
      vx_core::t_int,
      nums,
      vx_core::vx_new_int(0),
      vx_core::t_any_from_reduce->vx_fn_new({}, [](vx_core::Type_any total_any, vx_core::Type_any num_any) {
        vx_core::Type_int total = vx_core::vx_any_from_any(vx_core::t_int, total_any);
        vx_core::Type_int num = vx_core::vx_any_from_any(vx_core::t_int, num_any);
        vx_core::Type_any output_1 = 
          vx_core::f_plus(total, num);
        return output_1;
      })
    );
    vx_core::vx_release_one_except(nums, output);
    return output;
  }
  /**
   * @function plus 2
   * Math int plus
   * @param  {intlist} nums
   * @return {int}
   * (func +)
   */
  // (func +)
  // class Class_plus_2 {
    Abstract_plus_2::~Abstract_plus_2() {}

    Class_plus_2::Class_plus_2() : Abstract_plus_2::Abstract_plus_2() {
      vx_core::refcount += 1;
    }

    Class_plus_2::~Class_plus_2() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_plus_2::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus_2 output = vx_core::e_plus_2;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_plus_2::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus_2 output = vx_core::e_plus_2;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_plus_2::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "+", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_plus_2::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_plus_2::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "+", // name
        2, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_plus_2::vx_empty() const {return vx_core::e_plus_2;}
    vx_core::Type_any Class_plus_2::vx_type() const {return vx_core::t_plus_2;}
    vx_core::Type_msgblock Class_plus_2::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_plus_2::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_plus_2::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_plus_2::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_intlist inputval = vx_core::vx_any_from_any(vx_core::t_intlist, val);
      output = vx_core::f_plus_2(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_plus_2::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_intlist nums = vx_core::vx_any_from_any(vx_core::t_intlist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_plus_2(nums);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func +)
  vx_core::Type_number f_plus_1(vx_core::Type_number num1, vx_core::Type_number num2) {
    vx_core::Type_number output = vx_core::e_number;
    vx_core::vx_reserve({num1, num2});
    float result = vx_core::vx_float_from_number(num1) + vx_core::vx_float_from_number(num2);
    output = vx_core::vx_new_float(result);
    vx_core::vx_release_one_except({num1, num2}, output);
    return output;
  }
  /**
   * @function plus 1
   * Math number plus
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func +)
   */
  // (func +)
  // class Class_plus_1 {
    Abstract_plus_1::~Abstract_plus_1() {}

    Class_plus_1::Class_plus_1() : Abstract_plus_1::Abstract_plus_1() {
      vx_core::refcount += 1;
    }

    Class_plus_1::~Class_plus_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_plus_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus_1 output = vx_core::e_plus_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_plus_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus_1 output = vx_core::e_plus_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_plus_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "+", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_plus_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_plus_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "+", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_plus_1::vx_empty() const {return vx_core::e_plus_1;}
    vx_core::Type_any Class_plus_1::vx_type() const {return vx_core::t_plus_1;}
    vx_core::Type_msgblock Class_plus_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_plus_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_plus_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_number num1 = vx_core::vx_any_from_any(vx_core::t_number, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_number num2 = vx_core::vx_any_from_any(vx_core::t_number, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_plus_1(num1, num2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func +)
  vx_core::Type_int f_plus(vx_core::Type_int num1, vx_core::Type_int num2) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve({num1, num2});
    long result = num1->vx_int() + num2->vx_int();
    output = vx_core::vx_new_int(result);
    vx_core::vx_release_one_except({num1, num2}, output);
    return output;
  }
  /**
   * @function plus
   * Math int plus
   * @param  {int} num1
   * @param  {int} num2
   * @return {int}
   * (func +)
   */
  // (func +)
  // class Class_plus {
    Abstract_plus::~Abstract_plus() {}

    Class_plus::Class_plus() : Abstract_plus::Abstract_plus() {
      vx_core::refcount += 1;
    }

    Class_plus::~Class_plus() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_plus::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus output = vx_core::e_plus;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_plus::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus output = vx_core::e_plus;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_plus::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "+", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_plus::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_plus::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "+", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_plus::vx_empty() const {return vx_core::e_plus;}
    vx_core::Type_any Class_plus::vx_type() const {return vx_core::t_plus;}
    vx_core::Type_msgblock Class_plus::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_plus::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_plus::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_int num1 = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_int num2 = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_plus(num1, num2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func +1)
  vx_core::Type_int f_plus1(vx_core::Type_int num) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve(num);
    output = vx_core::f_plus(num, vx_core::vx_new_int(1));
    vx_core::vx_release_one_except(num, output);
    return output;
  }
  /**
   * @function plus1
   * Math int plus 1
   * @param  {int} num
   * @return {int}
   * (func +1)
   */
  // (func +1)
  // class Class_plus1 {
    Abstract_plus1::~Abstract_plus1() {}

    Class_plus1::Class_plus1() : Abstract_plus1::Abstract_plus1() {
      vx_core::refcount += 1;
    }

    Class_plus1::~Class_plus1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_plus1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus1 output = vx_core::e_plus1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_plus1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_plus1 output = vx_core::e_plus1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_plus1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "+1", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_plus1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_plus1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "+1", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_plus1::vx_empty() const {return vx_core::e_plus1;}
    vx_core::Type_any Class_plus1::vx_type() const {return vx_core::t_plus1;}
    vx_core::Type_msgblock Class_plus1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_plus1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_plus1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_plus1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_int inputval = vx_core::vx_any_from_any(vx_core::t_int, val);
      output = vx_core::f_plus1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_plus1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_int num = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_plus1(num);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func -)
  vx_core::Type_number f_minus_3(vx_core::Type_numberlist nums) {
    vx_core::Type_number output = vx_core::e_number;
    vx_core::vx_reserve(nums);
    output = vx_core::f_any_from_list_start_reduce(
      vx_core::t_number,
      nums,
      (vx_core::Type_number)vx_core::vx_new_int(0),
      vx_core::t_any_from_reduce->vx_fn_new({}, [](vx_core::Type_any total_any, vx_core::Type_any num_any) {
        vx_core::Type_number total = vx_core::vx_any_from_any(vx_core::t_number, total_any);
        vx_core::Type_number num = vx_core::vx_any_from_any(vx_core::t_number, num_any);
        vx_core::Type_any output_1 = 
          vx_core::f_minus_1(total, num);
        return output_1;
      })
    );
    vx_core::vx_release_one_except(nums, output);
    return output;
  }
  /**
   * @function minus 3
   * Math number minus
   * @param  {numberlist} nums
   * @return {number}
   * (func -)
   */
  // (func -)
  // class Class_minus_3 {
    Abstract_minus_3::~Abstract_minus_3() {}

    Class_minus_3::Class_minus_3() : Abstract_minus_3::Abstract_minus_3() {
      vx_core::refcount += 1;
    }

    Class_minus_3::~Class_minus_3() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_minus_3::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus_3 output = vx_core::e_minus_3;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_minus_3::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus_3 output = vx_core::e_minus_3;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_minus_3::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "-", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_minus_3::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_minus_3::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "-", // name
        3, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_minus_3::vx_empty() const {return vx_core::e_minus_3;}
    vx_core::Type_any Class_minus_3::vx_type() const {return vx_core::t_minus_3;}
    vx_core::Type_msgblock Class_minus_3::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_minus_3::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_minus_3::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_minus_3::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_numberlist inputval = vx_core::vx_any_from_any(vx_core::t_numberlist, val);
      output = vx_core::f_minus_3(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_minus_3::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_numberlist nums = vx_core::vx_any_from_any(vx_core::t_numberlist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_minus_3(nums);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func -)
  vx_core::Type_int f_minus_2(vx_core::Type_intlist nums) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve(nums);
    output = vx_core::f_any_from_list_start_reduce(
      vx_core::t_int,
      nums,
      vx_core::vx_new_int(0),
      vx_core::t_any_from_reduce->vx_fn_new({}, [](vx_core::Type_any total_any, vx_core::Type_any num_any) {
        vx_core::Type_int total = vx_core::vx_any_from_any(vx_core::t_int, total_any);
        vx_core::Type_int num = vx_core::vx_any_from_any(vx_core::t_int, num_any);
        vx_core::Type_any output_1 = 
          vx_core::f_minus(total, num);
        return output_1;
      })
    );
    vx_core::vx_release_one_except(nums, output);
    return output;
  }
  /**
   * @function minus 2
   * Math integer minus
   * @param  {intlist} nums
   * @return {int}
   * (func -)
   */
  // (func -)
  // class Class_minus_2 {
    Abstract_minus_2::~Abstract_minus_2() {}

    Class_minus_2::Class_minus_2() : Abstract_minus_2::Abstract_minus_2() {
      vx_core::refcount += 1;
    }

    Class_minus_2::~Class_minus_2() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_minus_2::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus_2 output = vx_core::e_minus_2;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_minus_2::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus_2 output = vx_core::e_minus_2;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_minus_2::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "-", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_minus_2::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_minus_2::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "-", // name
        2, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_minus_2::vx_empty() const {return vx_core::e_minus_2;}
    vx_core::Type_any Class_minus_2::vx_type() const {return vx_core::t_minus_2;}
    vx_core::Type_msgblock Class_minus_2::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_minus_2::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_minus_2::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_minus_2::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_intlist inputval = vx_core::vx_any_from_any(vx_core::t_intlist, val);
      output = vx_core::f_minus_2(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_minus_2::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_intlist nums = vx_core::vx_any_from_any(vx_core::t_intlist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_minus_2(nums);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func -)
  vx_core::Type_number f_minus_1(vx_core::Type_number num1, vx_core::Type_number num2) {
    vx_core::Type_number output = vx_core::e_number;
    vx_core::vx_reserve({num1, num2});
    float result = vx_core::vx_float_from_number(num1) - vx_core::vx_float_from_number(num2);
    output = vx_core::vx_new_float(result);
    vx_core::vx_release_one_except({num1, num2}, output);
    return output;
  }
  /**
   * @function minus 1
   * Math number minus
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func -)
   */
  // (func -)
  // class Class_minus_1 {
    Abstract_minus_1::~Abstract_minus_1() {}

    Class_minus_1::Class_minus_1() : Abstract_minus_1::Abstract_minus_1() {
      vx_core::refcount += 1;
    }

    Class_minus_1::~Class_minus_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_minus_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus_1 output = vx_core::e_minus_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_minus_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus_1 output = vx_core::e_minus_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_minus_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "-", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_minus_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_minus_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "-", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_minus_1::vx_empty() const {return vx_core::e_minus_1;}
    vx_core::Type_any Class_minus_1::vx_type() const {return vx_core::t_minus_1;}
    vx_core::Type_msgblock Class_minus_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_minus_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_minus_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_number num1 = vx_core::vx_any_from_any(vx_core::t_number, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_number num2 = vx_core::vx_any_from_any(vx_core::t_number, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_minus_1(num1, num2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func -)
  vx_core::Type_int f_minus(vx_core::Type_int num1, vx_core::Type_int num2) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve({num1, num2});
    long result = num1->vx_int() - num2->vx_int();
    output = vx_core::vx_new_int(result);
    vx_core::vx_release_one_except({num1, num2}, output);
    return output;
  }
  /**
   * @function minus
   * Math int minus
   * @param  {int} num1
   * @param  {int} num2
   * @return {int}
   * (func -)
   */
  // (func -)
  // class Class_minus {
    Abstract_minus::~Abstract_minus() {}

    Class_minus::Class_minus() : Abstract_minus::Abstract_minus() {
      vx_core::refcount += 1;
    }

    Class_minus::~Class_minus() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_minus::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus output = vx_core::e_minus;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_minus::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus output = vx_core::e_minus;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_minus::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "-", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_minus::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_minus::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "-", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_minus::vx_empty() const {return vx_core::e_minus;}
    vx_core::Type_any Class_minus::vx_type() const {return vx_core::t_minus;}
    vx_core::Type_msgblock Class_minus::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_minus::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_minus::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_int num1 = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_int num2 = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_minus(num1, num2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func -1)
  vx_core::Type_int f_minus1(vx_core::Type_int num) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve(num);
    output = vx_core::f_minus(num, vx_core::vx_new_int(1));
    vx_core::vx_release_one_except(num, output);
    return output;
  }
  /**
   * @function minus1
   * Math int minus 1
   * @param  {int} num
   * @return {int}
   * (func -1)
   */
  // (func -1)
  // class Class_minus1 {
    Abstract_minus1::~Abstract_minus1() {}

    Class_minus1::Class_minus1() : Abstract_minus1::Abstract_minus1() {
      vx_core::refcount += 1;
    }

    Class_minus1::~Class_minus1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_minus1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus1 output = vx_core::e_minus1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_minus1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_minus1 output = vx_core::e_minus1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_minus1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "-1", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_minus1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_minus1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "-1", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_minus1::vx_empty() const {return vx_core::e_minus1;}
    vx_core::Type_any Class_minus1::vx_type() const {return vx_core::t_minus1;}
    vx_core::Type_msgblock Class_minus1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_minus1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_minus1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_minus1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_int inputval = vx_core::vx_any_from_any(vx_core::t_int, val);
      output = vx_core::f_minus1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_minus1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_int num = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_minus1(num);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func .)
  vx_core::Type_any f_dotmethod(vx_core::Type_any target, vx_core::Type_string method, vx_core::Type_anylist parameters) {
    vx_core::Type_any output = vx_core::e_any;
    vx_core::vx_reserve({target, method, parameters});
    vx_core::vx_release_one_except({target, method, parameters}, output);
    return output;
  }
  /**
   * @function dotmethod
   * Not Recommened: Support for Object Oriented dot notation. e.g. (this.foo 'a') = this.foo('a')
   * @param  {any} target
   * @param  {string} method
   * @param  {anylist} parameters
   * @return {any}
   * (func .)
   */
  // (func .)
  // class Class_dotmethod {
    Abstract_dotmethod::~Abstract_dotmethod() {}

    Class_dotmethod::Class_dotmethod() : Abstract_dotmethod::Abstract_dotmethod() {
      vx_core::refcount += 1;
    }

    Class_dotmethod::~Class_dotmethod() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_dotmethod::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_dotmethod output = vx_core::e_dotmethod;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_dotmethod::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_dotmethod output = vx_core::e_dotmethod;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_dotmethod::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        ".", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_dotmethod::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_dotmethod::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        ".", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_dotmethod::vx_empty() const {return vx_core::e_dotmethod;}
    vx_core::Type_any Class_dotmethod::vx_type() const {return vx_core::t_dotmethod;}
    vx_core::Type_msgblock Class_dotmethod::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_dotmethod::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_dotmethod::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any target = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string method = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Type_anylist parameters = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_dotmethod(target, method, parameters);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func /)
  vx_core::Type_number f_divide(vx_core::Type_number num1, vx_core::Type_number num2) {
    vx_core::Type_number output = vx_core::e_number;
    vx_core::vx_reserve({num1, num2});
    float float1 = vx_core::vx_float_from_number(num1);
    float float2 = vx_core::vx_float_from_number(num2);
    if (float1 == 0) {
    } else if (float2 == 0) {
      output = vx_core::c_notanumber;
    } else {
      float result = float1 / float2;
      output = vx_core::vx_new_float(result);
    };
    vx_core::vx_release_one_except({num1, num2}, output);
    return output;
  }
  /**
   * @function divide
   * Math divide
   * @param  {number} num1
   * @param  {number} num2
   * @return {number}
   * (func /)
   */
  // (func /)
  // class Class_divide {
    Abstract_divide::~Abstract_divide() {}

    Class_divide::Class_divide() : Abstract_divide::Abstract_divide() {
      vx_core::refcount += 1;
    }

    Class_divide::~Class_divide() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_divide::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_divide output = vx_core::e_divide;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_divide::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_divide output = vx_core::e_divide;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_divide::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "/", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_divide::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_divide::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "/", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_divide::vx_empty() const {return vx_core::e_divide;}
    vx_core::Type_any Class_divide::vx_type() const {return vx_core::t_divide;}
    vx_core::Type_msgblock Class_divide::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_divide::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_divide::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_number num1 = vx_core::vx_any_from_any(vx_core::t_number, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_number num2 = vx_core::vx_any_from_any(vx_core::t_number, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_divide(num1, num2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func <)
  vx_core::Type_boolean f_lt_1(vx_core::Type_anylist values) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(values);
    output = vx_core::f_any_from_list_start_reduce_next(
      vx_core::t_boolean,
      values,
      vx_core::vx_new_boolean(true),
      vx_core::t_any_from_reduce_next->vx_fn_new({}, [](vx_core::Type_any reduce_any, vx_core::Type_any current, vx_core::Type_any next) {
        vx_core::Type_boolean reduce = vx_core::vx_any_from_any(vx_core::t_boolean, reduce_any);
        vx_core::Type_any output_1 = 
          vx_core::f_and(
            reduce,
            vx_core::f_lt(current, next)
          );
        return output_1;
      })
    );
    vx_core::vx_release_one_except(values, output);
    return output;
  }
  /**
   * @function lt 1
   * Returns true if the first arg is less than all of the other args
   * @param  {anylist} values
   * @return {boolean}
   * (func <)
   */
  // (func <)
  // class Class_lt_1 {
    Abstract_lt_1::~Abstract_lt_1() {}

    Class_lt_1::Class_lt_1() : Abstract_lt_1::Abstract_lt_1() {
      vx_core::refcount += 1;
    }

    Class_lt_1::~Class_lt_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_lt_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_lt_1 output = vx_core::e_lt_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_lt_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_lt_1 output = vx_core::e_lt_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_lt_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "<", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_lt_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_lt_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "<", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_lt_1::vx_empty() const {return vx_core::e_lt_1;}
    vx_core::Type_any Class_lt_1::vx_type() const {return vx_core::t_lt_1;}
    vx_core::Type_msgblock Class_lt_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_lt_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_lt_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_lt_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist inputval = vx_core::vx_any_from_any(vx_core::t_anylist, val);
      output = vx_core::f_lt_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_lt_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist values = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_lt_1(values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func <)
  vx_core::Type_boolean f_lt(vx_core::Type_any val1, vx_core::Type_any val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    output = vx_core::f_switch(
      vx_core::t_boolean,
      vx_core::f_compare(val1, val2),
      vx_core::vx_new(vx_core::t_thenelselist, {
        vx_core::f_case_1(
          vx_core::vx_new_int(-1),
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_boolean output_1 = vx_core::vx_new_boolean(true);
            return output_1;
          })
        ),
        vx_core::f_else(
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_boolean output_1 = vx_core::vx_new_boolean(false);
            return output_1;
          })
        )
      })
    );
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function lt
   * Returns true if the first arg is less than all of the other args
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func <)
   */
  // (func <)
  // class Class_lt {
    Abstract_lt::~Abstract_lt() {}

    Class_lt::Class_lt() : Abstract_lt::Abstract_lt() {
      vx_core::refcount += 1;
    }

    Class_lt::~Class_lt() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_lt::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_lt output = vx_core::e_lt;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_lt::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_lt output = vx_core::e_lt;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_lt::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "<", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_lt::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_lt::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "<", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_lt::vx_empty() const {return vx_core::e_lt;}
    vx_core::Type_any Class_lt::vx_type() const {return vx_core::t_lt;}
    vx_core::Type_msgblock Class_lt::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_lt::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_lt::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any val1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any val2 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_lt(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function chainfirst
   * This is a special function that applies a value as the first argument for the first function.
   * The result is then used as the first argument on the next function, etc. Sometimes this
   * improves readability.
   * @param  {any-1} value
   * @param  {any<-anylist} fnlist
   * @return {any-1}
   * (func <-)
   */
  // (func <-)
  // class Class_chainfirst {
    Abstract_chainfirst::~Abstract_chainfirst() {}

    Class_chainfirst::Class_chainfirst() : Abstract_chainfirst::Abstract_chainfirst() {
      vx_core::refcount += 1;
    }

    Class_chainfirst::~Class_chainfirst() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_chainfirst::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_chainfirst output = vx_core::e_chainfirst;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_chainfirst::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_chainfirst output = vx_core::e_chainfirst;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_chainfirst::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "<-", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_chainfirst::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_chainfirst::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "<-", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_chainfirst::vx_empty() const {return vx_core::e_chainfirst;}
    vx_core::Type_any Class_chainfirst::vx_type() const {return vx_core::t_chainfirst;}
    vx_core::Type_msgblock Class_chainfirst::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_chainfirst::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_chainfirst::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any_from_anylist fnlist = vx_core::vx_any_from_any(vx_core::t_any_from_anylist, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_chainfirst(generic_any_1, value, fnlist);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function chainlast
   * This is a special function that applies a value as the last argument for the first function.
   * The result is then used as the last argument on the next function, etc. Sometimes this
   * improves readability.
   * @param  {any-1} value
   * @param  {any<-anylist} fnlist
   * @return {any-1}
   * (func <<-)
   */
  // (func <<-)
  // class Class_chainlast {
    Abstract_chainlast::~Abstract_chainlast() {}

    Class_chainlast::Class_chainlast() : Abstract_chainlast::Abstract_chainlast() {
      vx_core::refcount += 1;
    }

    Class_chainlast::~Class_chainlast() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_chainlast::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_chainlast output = vx_core::e_chainlast;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_chainlast::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_chainlast output = vx_core::e_chainlast;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_chainlast::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "<<-", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_chainlast::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_chainlast::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "<<-", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_chainlast::vx_empty() const {return vx_core::e_chainlast;}
    vx_core::Type_any Class_chainlast::vx_type() const {return vx_core::t_chainlast;}
    vx_core::Type_msgblock Class_chainlast::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_chainlast::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_chainlast::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any_from_anylist fnlist = vx_core::vx_any_from_any(vx_core::t_any_from_anylist, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_chainlast(generic_any_1, value, fnlist);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func <=)
  vx_core::Type_boolean f_le_1(vx_core::Type_anylist args) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(args);
    output = vx_core::f_not(
      vx_core::f_gt_1(args)
    );
    vx_core::vx_release_one_except(args, output);
    return output;
  }
  /**
   * @function le 1
   * Returns true if the first arg is less or equal than all of the other args
   * @param  {anylist} args
   * @return {boolean}
   * (func <=)
   */
  // (func <=)
  // class Class_le_1 {
    Abstract_le_1::~Abstract_le_1() {}

    Class_le_1::Class_le_1() : Abstract_le_1::Abstract_le_1() {
      vx_core::refcount += 1;
    }

    Class_le_1::~Class_le_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_le_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_le_1 output = vx_core::e_le_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_le_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_le_1 output = vx_core::e_le_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_le_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "<=", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_le_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_le_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_le_1::vx_empty() const {return vx_core::e_le_1;}
    vx_core::Type_any Class_le_1::vx_type() const {return vx_core::t_le_1;}
    vx_core::Type_msgblock Class_le_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_le_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_le_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_le_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist inputval = vx_core::vx_any_from_any(vx_core::t_anylist, val);
      output = vx_core::f_le_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_le_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist args = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_le_1(args);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func <=)
  vx_core::Type_boolean f_le(vx_core::Type_any val1, vx_core::Type_any val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    output = vx_core::f_not(
      vx_core::f_gt(val1, val2)
    );
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function le
   * Returns true if the first arg is less or equal than all of the other args
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func <=)
   */
  // (func <=)
  // class Class_le {
    Abstract_le::~Abstract_le() {}

    Class_le::Class_le() : Abstract_le::Abstract_le() {
      vx_core::refcount += 1;
    }

    Class_le::~Class_le() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_le::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_le output = vx_core::e_le;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_le::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_le output = vx_core::e_le;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_le::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "<=", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_le::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_le::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_le::vx_empty() const {return vx_core::e_le;}
    vx_core::Type_any Class_le::vx_type() const {return vx_core::t_le;}
    vx_core::Type_msgblock Class_le::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_le::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_le::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any val1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any val2 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_le(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func ==)
  vx_core::Type_boolean f_eqeq(vx_core::Type_any val1, vx_core::Type_any val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    bool isequal = vx_core::vx_eqeq(val1, val2);
    output = vx_core::vx_new_boolean(isequal);
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function eqeq
   * Strict equality check. Note that all non-empty, non-constants will not be equal.
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func ==)
   */
  // (func ==)
  // class Class_eqeq {
    Abstract_eqeq::~Abstract_eqeq() {}

    Class_eqeq::Class_eqeq() : Abstract_eqeq::Abstract_eqeq() {
      vx_core::refcount += 1;
    }

    Class_eqeq::~Class_eqeq() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_eqeq::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_eqeq output = vx_core::e_eqeq;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_eqeq::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_eqeq output = vx_core::e_eqeq;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_eqeq::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "==", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_eqeq::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_eqeq::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "==", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_eqeq::vx_empty() const {return vx_core::e_eqeq;}
    vx_core::Type_any Class_eqeq::vx_type() const {return vx_core::t_eqeq;}
    vx_core::Type_msgblock Class_eqeq::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_eqeq::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_eqeq::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any val1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any val2 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_eqeq(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func >)
  vx_core::Type_boolean f_gt_1(vx_core::Type_anylist values) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(values);
    output = vx_core::f_any_from_list_start_reduce_next(
      vx_core::t_boolean,
      values,
      vx_core::vx_new_boolean(true),
      vx_core::t_any_from_reduce_next->vx_fn_new({}, [](vx_core::Type_any reduce_any, vx_core::Type_any current, vx_core::Type_any next) {
        vx_core::Type_boolean reduce = vx_core::vx_any_from_any(vx_core::t_boolean, reduce_any);
        vx_core::Type_any output_1 = 
          vx_core::f_and(
            reduce,
            vx_core::f_gt(current, next)
          );
        return output_1;
      })
    );
    vx_core::vx_release_one_except(values, output);
    return output;
  }
  /**
   * @function gt 1
   * Returns true if the first arg is greater than all of the other args
   * @param  {anylist} values
   * @return {boolean}
   * (func >)
   */
  // (func >)
  // class Class_gt_1 {
    Abstract_gt_1::~Abstract_gt_1() {}

    Class_gt_1::Class_gt_1() : Abstract_gt_1::Abstract_gt_1() {
      vx_core::refcount += 1;
    }

    Class_gt_1::~Class_gt_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_gt_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_gt_1 output = vx_core::e_gt_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_gt_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_gt_1 output = vx_core::e_gt_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_gt_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        ">", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_gt_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_gt_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        ">", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_gt_1::vx_empty() const {return vx_core::e_gt_1;}
    vx_core::Type_any Class_gt_1::vx_type() const {return vx_core::t_gt_1;}
    vx_core::Type_msgblock Class_gt_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_gt_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_gt_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_gt_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist inputval = vx_core::vx_any_from_any(vx_core::t_anylist, val);
      output = vx_core::f_gt_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_gt_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist values = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_gt_1(values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func >)
  vx_core::Type_boolean f_gt(vx_core::Type_any val1, vx_core::Type_any val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    output = vx_core::f_switch(
      vx_core::t_boolean,
      vx_core::f_compare(val1, val2),
      vx_core::vx_new(vx_core::t_thenelselist, {
        vx_core::f_case_1(
          vx_core::vx_new_int(1),
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_boolean output_1 = vx_core::vx_new_boolean(true);
            return output_1;
          })
        ),
        vx_core::f_else(
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_boolean output_1 = vx_core::vx_new_boolean(false);
            return output_1;
          })
        )
      })
    );
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function gt
   * Returns true if the first arg is greater than all of the other args
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func >)
   */
  // (func >)
  // class Class_gt {
    Abstract_gt::~Abstract_gt() {}

    Class_gt::Class_gt() : Abstract_gt::Abstract_gt() {
      vx_core::refcount += 1;
    }

    Class_gt::~Class_gt() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_gt::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_gt output = vx_core::e_gt;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_gt::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_gt output = vx_core::e_gt;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_gt::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        ">", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_gt::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_gt::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        ">", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_gt::vx_empty() const {return vx_core::e_gt;}
    vx_core::Type_any Class_gt::vx_type() const {return vx_core::t_gt;}
    vx_core::Type_msgblock Class_gt::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_gt::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_gt::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any val1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any val2 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_gt(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func >=)
  vx_core::Type_boolean f_ge_1(vx_core::Type_anylist args) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(args);
    output = vx_core::f_not(
      vx_core::f_lt_1(args)
    );
    vx_core::vx_release_one_except(args, output);
    return output;
  }
  /**
   * @function ge 1
   * Returns true if the first arg is greater or equal than all of the other args
   * @param  {anylist} args
   * @return {boolean}
   * (func >=)
   */
  // (func >=)
  // class Class_ge_1 {
    Abstract_ge_1::~Abstract_ge_1() {}

    Class_ge_1::Class_ge_1() : Abstract_ge_1::Abstract_ge_1() {
      vx_core::refcount += 1;
    }

    Class_ge_1::~Class_ge_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_ge_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_ge_1 output = vx_core::e_ge_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_ge_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_ge_1 output = vx_core::e_ge_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_ge_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        ">=", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_ge_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_ge_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_ge_1::vx_empty() const {return vx_core::e_ge_1;}
    vx_core::Type_any Class_ge_1::vx_type() const {return vx_core::t_ge_1;}
    vx_core::Type_msgblock Class_ge_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_ge_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_ge_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_ge_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist inputval = vx_core::vx_any_from_any(vx_core::t_anylist, val);
      output = vx_core::f_ge_1(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_ge_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist args = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_ge_1(args);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func >=)
  vx_core::Type_boolean f_ge(vx_core::Type_any val1, vx_core::Type_any val2) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({val1, val2});
    output = vx_core::f_not(
      vx_core::f_lt(val1, val2)
    );
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function ge
   * Returns true if val1 is greater or equal to val2
   * @param  {any} val1
   * @param  {any} val2
   * @return {boolean}
   * (func >=)
   */
  // (func >=)
  // class Class_ge {
    Abstract_ge::~Abstract_ge() {}

    Class_ge::Class_ge() : Abstract_ge::Abstract_ge() {
      vx_core::refcount += 1;
    }

    Class_ge::~Class_ge() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_ge::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_ge output = vx_core::e_ge;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_ge::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_ge output = vx_core::e_ge;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_ge::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        ">=", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_ge::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_ge::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_ge::vx_empty() const {return vx_core::e_ge;}
    vx_core::Type_any Class_ge::vx_type() const {return vx_core::t_ge;}
    vx_core::Type_msgblock Class_ge::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_ge::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_ge::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any val1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any val2 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_ge(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func allowfuncs<-security)
  vx_core::Type_funclist f_allowfuncs_from_security(vx_core::Type_security security) {
    vx_core::Type_funclist output = vx_core::e_funclist;
    vx_core::vx_reserve(security);
    output = security->allowfuncs();
    vx_core::vx_release_one_except(security, output);
    return output;
  }
  /**
   * @function allowfuncs_from_security
   * Returns allowfuncs from a given security.
   * @param  {security} security
   * @return {funclist}
   * (func allowfuncs<-security)
   */
  // (func allowfuncs<-security)
  // class Class_allowfuncs_from_security {
    Abstract_allowfuncs_from_security::~Abstract_allowfuncs_from_security() {}

    Class_allowfuncs_from_security::Class_allowfuncs_from_security() : Abstract_allowfuncs_from_security::Abstract_allowfuncs_from_security() {
      vx_core::refcount += 1;
    }

    Class_allowfuncs_from_security::~Class_allowfuncs_from_security() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_allowfuncs_from_security::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_allowfuncs_from_security output = vx_core::e_allowfuncs_from_security;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_allowfuncs_from_security::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_allowfuncs_from_security output = vx_core::e_allowfuncs_from_security;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_allowfuncs_from_security::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "allowfuncs<-security", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_allowfuncs_from_security::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_allowfuncs_from_security::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "allowfuncs<-security", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_allowfuncs_from_security::vx_empty() const {return vx_core::e_allowfuncs_from_security;}
    vx_core::Type_any Class_allowfuncs_from_security::vx_type() const {return vx_core::t_allowfuncs_from_security;}
    vx_core::Type_msgblock Class_allowfuncs_from_security::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_allowfuncs_from_security::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_allowfuncs_from_security::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_allowfuncs_from_security::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_security inputval = vx_core::vx_any_from_any(vx_core::t_security, val);
      output = vx_core::f_allowfuncs_from_security(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_allowfuncs_from_security::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_security security = vx_core::vx_any_from_any(vx_core::t_security, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_allowfuncs_from_security(security);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func allowtypenames<-typedef)
  vx_core::Type_stringlist f_allowtypenames_from_typedef(vx_core::Type_typedef vtypedef) {
    vx_core::Type_stringlist output = vx_core::e_stringlist;
    vx_core::vx_reserve(vtypedef);
    output = vx_core::f_typenames_from_typelist(
      vx_core::f_allowtypes_from_typedef(vtypedef)
    );
    vx_core::vx_release_one_except(vtypedef, output);
    return output;
  }
  /**
   * @function allowtypenames_from_typedef
   * Return allow name list from type
   * @param  {typedef} vtypedef
   * @return {stringlist}
   * (func allowtypenames<-typedef)
   */
  // (func allowtypenames<-typedef)
  // class Class_allowtypenames_from_typedef {
    Abstract_allowtypenames_from_typedef::~Abstract_allowtypenames_from_typedef() {}

    Class_allowtypenames_from_typedef::Class_allowtypenames_from_typedef() : Abstract_allowtypenames_from_typedef::Abstract_allowtypenames_from_typedef() {
      vx_core::refcount += 1;
    }

    Class_allowtypenames_from_typedef::~Class_allowtypenames_from_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_allowtypenames_from_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_allowtypenames_from_typedef output = vx_core::e_allowtypenames_from_typedef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_allowtypenames_from_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_allowtypenames_from_typedef output = vx_core::e_allowtypenames_from_typedef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_allowtypenames_from_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "allowtypenames<-typedef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_allowtypenames_from_typedef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_allowtypenames_from_typedef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "allowtypenames<-typedef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_allowtypenames_from_typedef::vx_empty() const {return vx_core::e_allowtypenames_from_typedef;}
    vx_core::Type_any Class_allowtypenames_from_typedef::vx_type() const {return vx_core::t_allowtypenames_from_typedef;}
    vx_core::Type_msgblock Class_allowtypenames_from_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_allowtypenames_from_typedef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_allowtypenames_from_typedef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_allowtypenames_from_typedef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef inputval = vx_core::vx_any_from_any(vx_core::t_typedef, val);
      output = vx_core::f_allowtypenames_from_typedef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_allowtypenames_from_typedef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef vtypedef = vx_core::vx_any_from_any(vx_core::t_typedef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_allowtypenames_from_typedef(vtypedef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func allowtypes<-typedef)
  vx_core::Type_typelist f_allowtypes_from_typedef(vx_core::Type_typedef vtypedef) {
    vx_core::Type_typelist output = vx_core::e_typelist;
    vx_core::vx_reserve(vtypedef);
    output = vtypedef->allowtypes();
    vx_core::vx_release_one_except(vtypedef, output);
    return output;
  }
  /**
   * @function allowtypes_from_typedef
   * Return allow type list from type
   * @param  {typedef} vtypedef
   * @return {typelist}
   * (func allowtypes<-typedef)
   */
  // (func allowtypes<-typedef)
  // class Class_allowtypes_from_typedef {
    Abstract_allowtypes_from_typedef::~Abstract_allowtypes_from_typedef() {}

    Class_allowtypes_from_typedef::Class_allowtypes_from_typedef() : Abstract_allowtypes_from_typedef::Abstract_allowtypes_from_typedef() {
      vx_core::refcount += 1;
    }

    Class_allowtypes_from_typedef::~Class_allowtypes_from_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_allowtypes_from_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_allowtypes_from_typedef output = vx_core::e_allowtypes_from_typedef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_allowtypes_from_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_allowtypes_from_typedef output = vx_core::e_allowtypes_from_typedef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_allowtypes_from_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "allowtypes<-typedef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_allowtypes_from_typedef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_allowtypes_from_typedef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "allowtypes<-typedef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_allowtypes_from_typedef::vx_empty() const {return vx_core::e_allowtypes_from_typedef;}
    vx_core::Type_any Class_allowtypes_from_typedef::vx_type() const {return vx_core::t_allowtypes_from_typedef;}
    vx_core::Type_msgblock Class_allowtypes_from_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_allowtypes_from_typedef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_allowtypes_from_typedef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_allowtypes_from_typedef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef inputval = vx_core::vx_any_from_any(vx_core::t_typedef, val);
      output = vx_core::f_allowtypes_from_typedef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_allowtypes_from_typedef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef vtypedef = vx_core::vx_any_from_any(vx_core::t_typedef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_allowtypes_from_typedef(vtypedef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function any_from_any_key_value
   * Generic Function returning Generic any-1 from a any-1, a key, and a value.
   * @param  {any-1} current
   * @param  {string} key
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-any-key-value)
   */
  // (func any<-any-key-value)
  // class Class_any_from_any_key_value {
    Abstract_any_from_any_key_value::~Abstract_any_from_any_key_value() {}

    Class_any_from_any_key_value::Class_any_from_any_key_value() : Abstract_any_from_any_key_value::Abstract_any_from_any_key_value() {
      vx_core::refcount += 1;
    }

    Class_any_from_any_key_value::~Class_any_from_any_key_value() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_any_key_value Class_any_from_any_key_value::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_key_value::IFn fn) const {
      vx_core::Func_any_from_any_key_value output = new vx_core::Class_any_from_any_key_value();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_any_key_value::vx_any_from_any_key_value(vx_core::Type_any current, vx_core::Type_string key, vx_core::Type_any value) const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn(current, key, value);
      }
      return output;
    }

    vx_core::Type_any Class_any_from_any_key_value::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any_key_value output = vx_core::e_any_from_any_key_value;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_any_key_value::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_any_key_value output = vx_core::e_any_from_any_key_value;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_any_key_value::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-any-key-value", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_any_key_value::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_any_key_value::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-any-key-value", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_any_key_value::vx_empty() const {return vx_core::e_any_from_any_key_value;}
    vx_core::Type_any Class_any_from_any_key_value::vx_type() const {return vx_core::t_any_from_any_key_value;}
    vx_core::Type_msgblock Class_any_from_any_key_value::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_any_key_value::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_any_key_value::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any current = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string key = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_any_from_any_key_value(generic_any_1, current, key, value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function any_from_int
   * Generic Function returning Generic any-1 from an int
   * @param  {int} value
   * @return {any-1}
   * (func any<-int)
   */
  // (func any<-int)
  // class Class_any_from_int {
    Abstract_any_from_int::~Abstract_any_from_int() {}

    Class_any_from_int::Class_any_from_int() : Abstract_any_from_int::Abstract_any_from_int() {
      vx_core::refcount += 1;
    }

    Class_any_from_int::~Class_any_from_int() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_int Class_any_from_int::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_int::IFn fn) const {
      vx_core::Func_any_from_int output = new vx_core::Class_any_from_int();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_int::vx_any_from_int(vx_core::Type_int value) const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn(value);
      }
      return output;
    }

    vx_core::Type_any Class_any_from_int::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_int output = vx_core::e_any_from_int;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_int::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_int output = vx_core::e_any_from_int;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_int::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-int", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_int::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_int::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-int", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_int::vx_empty() const {return vx_core::e_any_from_int;}
    vx_core::Type_any Class_any_from_int::vx_type() const {return vx_core::t_any_from_int;}
    vx_core::Type_msgblock Class_any_from_int::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_int::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_int::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_int value = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_any_from_int(generic_any_1, value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function any_from_int_any
   * Generic Function returning Generic any-1 from an int and a value
   * @param  {int} num
   * @param  {any-2} value
   * @return {any-1}
   * (func any<-int-any)
   */
  // (func any<-int-any)
  // class Class_any_from_int_any {
    Abstract_any_from_int_any::~Abstract_any_from_int_any() {}

    Class_any_from_int_any::Class_any_from_int_any() : Abstract_any_from_int_any::Abstract_any_from_int_any() {
      vx_core::refcount += 1;
    }

    Class_any_from_int_any::~Class_any_from_int_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Func_any_from_int_any Class_any_from_int_any::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_int_any::IFn fn) const {
      vx_core::Func_any_from_int_any output = new vx_core::Class_any_from_int_any();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_any Class_any_from_int_any::vx_any_from_int_any(vx_core::Type_int num, vx_core::Type_any value) const {
      vx_core::Type_any output = vx_core::e_any;
      if (fn) {
        output = fn(num, value);
      }
      return output;
    }

    vx_core::Type_any Class_any_from_int_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_int_any output = vx_core::e_any_from_int_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_int_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_int_any output = vx_core::e_any_from_int_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_int_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-int-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_int_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_int_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-int-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_int_any::vx_empty() const {return vx_core::e_any_from_int_any;}
    vx_core::Type_any Class_any_from_int_any::vx_type() const {return vx_core::t_any_from_int_any;}
    vx_core::Type_msgblock Class_any_from_int_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_int_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_int_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_int num = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_any_from_int_any(generic_any_1, num, value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function any_from_map_start_reduce
   * Returns a value by reducing each element of a map.
   * @param  {map-1} map
   * @param  {any-1} start
   * @param  {any<-any-key-value} fn-reduce
   * @return {any-1}
   * (func any<-map-start-reduce)
   */
  // (func any<-map-start-reduce)
  // class Class_any_from_map_start_reduce {
    Abstract_any_from_map_start_reduce::~Abstract_any_from_map_start_reduce() {}

    Class_any_from_map_start_reduce::Class_any_from_map_start_reduce() : Abstract_any_from_map_start_reduce::Abstract_any_from_map_start_reduce() {
      vx_core::refcount += 1;
    }

    Class_any_from_map_start_reduce::~Class_any_from_map_start_reduce() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_any_from_map_start_reduce::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_map_start_reduce output = vx_core::e_any_from_map_start_reduce;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_any_from_map_start_reduce::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_any_from_map_start_reduce output = vx_core::e_any_from_map_start_reduce;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_any_from_map_start_reduce::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "any<-map-start-reduce", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_any_from_map_start_reduce::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_any_from_map_start_reduce::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "any<-map-start-reduce", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_any_from_map_start_reduce::vx_empty() const {return vx_core::e_any_from_map_start_reduce;}
    vx_core::Type_any Class_any_from_map_start_reduce::vx_type() const {return vx_core::t_any_from_map_start_reduce;}
    vx_core::Type_msgblock Class_any_from_map_start_reduce::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_any_from_map_start_reduce::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_any_from_map_start_reduce::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_map map = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any start = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Func_any_from_any_key_value fn_reduce = vx_core::vx_any_from_any(vx_core::t_any_from_any_key_value, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func boolean-permission<-func)
  vx_core::Type_boolean f_boolean_permission_from_func(vx_core::Type_context context, vx_core::Type_func func) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(func);
    output = vx_core::f_contains_1(
      vx_core::f_allowfuncs_from_security(
        vx_core::f_security_from_context(context)
      ),
      func
    );
    vx_core::vx_release_one_except(func, output);
    return output;
  }
  /**
   * @function boolean_permission_from_func
   * Returns true if the given func has permission.
   * @param  {func} func
   * @return {boolean}
   * (func boolean-permission<-func)
   */
  // (func boolean-permission<-func)
  // class Class_boolean_permission_from_func {
    Abstract_boolean_permission_from_func::~Abstract_boolean_permission_from_func() {}

    Class_boolean_permission_from_func::Class_boolean_permission_from_func() : Abstract_boolean_permission_from_func::Abstract_boolean_permission_from_func() {
      vx_core::refcount += 1;
    }

    Class_boolean_permission_from_func::~Class_boolean_permission_from_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_boolean_permission_from_func::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_permission_from_func output = vx_core::e_boolean_permission_from_func;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_boolean_permission_from_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_permission_from_func output = vx_core::e_boolean_permission_from_func;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_boolean_permission_from_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "boolean-permission<-func", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_boolean_permission_from_func::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_boolean_permission_from_func::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "boolean-permission<-func", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_boolean_permission_from_func::vx_empty() const {return vx_core::e_boolean_permission_from_func;}
    vx_core::Type_any Class_boolean_permission_from_func::vx_type() const {return vx_core::t_boolean_permission_from_func;}
    vx_core::Type_msgblock Class_boolean_permission_from_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_boolean_permission_from_func::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any_context Class_boolean_permission_from_func::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_context::IFn fn) const {
      return vx_core::e_any_from_any_context;
    }

    vx_core::Type_any Class_boolean_permission_from_func::vx_any_from_any_context(vx_core::Type_context context, vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_func inputval = vx_core::vx_any_from_any(vx_core::t_func, val);
      output = vx_core::f_boolean_permission_from_func(context, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_boolean_permission_from_func::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_func func = vx_core::vx_any_from_any(vx_core::t_func, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_boolean_permission_from_func(context, func);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func boolean-write<-map-name-value)
  vx_core::Type_boolean f_boolean_write_from_map_name_value(vx_core::Type_map valuemap, vx_core::Type_string name, vx_core::Type_any value) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({valuemap, name, value});
    output = vx_core::vx_boolean_write_from_map_name_value(valuemap, name, value);
    vx_core::vx_release_one_except({valuemap, name, value}, output);
    return output;
  }
  /**
   * @function boolean_write_from_map_name_value
   * Returns true if it alters a mutable map false if it fails.
   * @param  {map-1} valuemap
   * @param  {string} name
   * @param  {any-1} value
   * @return {boolean}
   * (func boolean-write<-map-name-value)
   */
  // (func boolean-write<-map-name-value)
  // class Class_boolean_write_from_map_name_value {
    Abstract_boolean_write_from_map_name_value::~Abstract_boolean_write_from_map_name_value() {}

    Class_boolean_write_from_map_name_value::Class_boolean_write_from_map_name_value() : Abstract_boolean_write_from_map_name_value::Abstract_boolean_write_from_map_name_value() {
      vx_core::refcount += 1;
    }

    Class_boolean_write_from_map_name_value::~Class_boolean_write_from_map_name_value() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_boolean_write_from_map_name_value::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_write_from_map_name_value output = vx_core::e_boolean_write_from_map_name_value;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_boolean_write_from_map_name_value::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_boolean_write_from_map_name_value output = vx_core::e_boolean_write_from_map_name_value;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_boolean_write_from_map_name_value::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "boolean-write<-map-name-value", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_boolean_write_from_map_name_value::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_boolean_write_from_map_name_value::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "boolean-write<-map-name-value", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_boolean_write_from_map_name_value::vx_empty() const {return vx_core::e_boolean_write_from_map_name_value;}
    vx_core::Type_any Class_boolean_write_from_map_name_value::vx_type() const {return vx_core::t_boolean_write_from_map_name_value;}
    vx_core::Type_msgblock Class_boolean_write_from_map_name_value::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_boolean_write_from_map_name_value::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_boolean_write_from_map_name_value::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map valuemap = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string name = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_boolean_write_from_map_name_value(valuemap, name, value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func compare)
  vx_core::Type_int f_compare(vx_core::Type_any val1, vx_core::Type_any val2) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve({val1, val2});
    long intresult = vx_core::vx_compare(val1, val2);
    output = vx_core::vx_new_int(intresult);
    vx_core::vx_release_one_except({val1, val2}, output);
    return output;
  }
  /**
   * @function compare
   * Returns 0 if vals are equal, 1 if val1 > val2, -1 if val1 < val2
   * @param  {any} val1
   * @param  {any} val2
   * @return {int}
   * (func compare)
   */
  // (func compare)
  // class Class_compare {
    Abstract_compare::~Abstract_compare() {}

    Class_compare::Class_compare() : Abstract_compare::Abstract_compare() {
      vx_core::refcount += 1;
    }

    Class_compare::~Class_compare() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_compare::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_compare output = vx_core::e_compare;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_compare::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_compare output = vx_core::e_compare;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_compare::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "compare", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_compare::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_compare::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "compare", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_compare::vx_empty() const {return vx_core::e_compare;}
    vx_core::Type_any Class_compare::vx_type() const {return vx_core::t_compare;}
    vx_core::Type_msgblock Class_compare::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_compare::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_compare::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any val1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any val2 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_compare(val1, val2);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func contains)
  vx_core::Type_boolean f_contains_1(vx_core::Type_list values, vx_core::Type_any find) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({values, find});
    bool booleanresult = false;
    vx_core::vx_Type_listany listvalues = values->vx_list();
    for (vx_core::Type_any item : listvalues) {
      vx_core::Type_boolean iseq = vx_core::f_eq(item, find);
      if (iseq->vx_boolean()) {
        booleanresult = true;
        break;
      }
    }
    output = vx_core::vx_new_boolean(booleanresult);
    vx_core::vx_release_one_except({values, find}, output);
    return output;
  }
  /**
   * @function contains 1
   * Returns true if the given list contains the given value.
   * @param  {list-2} values Any list
   * @param  {any} find Any value
   * @return {boolean}
   * (func contains)
   */
  // (func contains)
  // class Class_contains_1 {
    Abstract_contains_1::~Abstract_contains_1() {}

    Class_contains_1::Class_contains_1() : Abstract_contains_1::Abstract_contains_1() {
      vx_core::refcount += 1;
    }

    Class_contains_1::~Class_contains_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_contains_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_contains_1 output = vx_core::e_contains_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_contains_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_contains_1 output = vx_core::e_contains_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_contains_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "contains", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_contains_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_contains_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_contains_1::vx_empty() const {return vx_core::e_contains_1;}
    vx_core::Type_any Class_contains_1::vx_type() const {return vx_core::t_contains_1;}
    vx_core::Type_msgblock Class_contains_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_contains_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_contains_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any find = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_contains_1(values, find);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func contains)
  vx_core::Type_boolean f_contains(vx_core::Type_string text, vx_core::Type_string find) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({text, find});
    bool check = vx_boolean_from_string_find(text->vx_string(), find->vx_string());
    output = vx_core::vx_new_boolean(check);
    vx_core::vx_release_one_except({text, find}, output);
    return output;
  }
  /**
   * @function contains
   * Returns true if the given list contains the given value.
   * @param  {string} text
   * @param  {string} find
   * @return {boolean}
   * (func contains)
   */
  // (func contains)
  // class Class_contains {
    Abstract_contains::~Abstract_contains() {}

    Class_contains::Class_contains() : Abstract_contains::Abstract_contains() {
      vx_core::refcount += 1;
    }

    Class_contains::~Class_contains() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_contains::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_contains output = vx_core::e_contains;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_contains::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_contains output = vx_core::e_contains;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_contains::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "contains", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_contains::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_contains::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_contains::vx_empty() const {return vx_core::e_contains;}
    vx_core::Type_any Class_contains::vx_type() const {return vx_core::t_contains;}
    vx_core::Type_msgblock Class_contains::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_contains::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_contains::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string text = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string find = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_contains(text, find);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func context-main)
  vx_core::Type_context f_context_main(vx_core::Type_anylist args) {
    vx_core::Type_context output = vx_core::e_context;
    vx_core::vx_reserve(args);
    output = vx_core::f_empty(
      vx_core::t_context
    );
    vx_core::vx_release_one_except(args, output);
    return output;
  }
  /**
   * @function context_main
   * Returns the default context for app main execution. Arguments come from the command line.
   * @param  {anylist} args
   * @return {context}
   * (func context-main)
   */
  // (func context-main)
  // class Class_context_main {
    Abstract_context_main::~Abstract_context_main() {}

    Class_context_main::Class_context_main() : Abstract_context_main::Abstract_context_main() {
      vx_core::refcount += 1;
    }

    Class_context_main::~Class_context_main() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_context_main::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_context_main output = vx_core::e_context_main;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_context_main::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_context_main output = vx_core::e_context_main;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_context_main::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "context-main", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_context_main::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_context_main::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "context-main", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_context_main::vx_empty() const {return vx_core::e_context_main;}
    vx_core::Type_any Class_context_main::vx_type() const {return vx_core::t_context_main;}
    vx_core::Type_msgblock Class_context_main::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_context_main::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_context_main::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_context_main::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist inputval = vx_core::vx_any_from_any(vx_core::t_anylist, val);
      output = vx_core::f_context_main(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_context_main::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist args = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_context_main(args);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func extends<-any)
  vx_core::Type_string f_extends_from_any(vx_core::Type_any value) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(value);
    output = vx_core::f_extends_from_typedef(
      vx_core::f_typedef_from_any(value)
    );
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function extends_from_any
   * @param  {any-1} value
   * @return {string}
   * (func extends<-any)
   */
  // (func extends<-any)
  // class Class_extends_from_any {
    Abstract_extends_from_any::~Abstract_extends_from_any() {}

    Class_extends_from_any::Class_extends_from_any() : Abstract_extends_from_any::Abstract_extends_from_any() {
      vx_core::refcount += 1;
    }

    Class_extends_from_any::~Class_extends_from_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_extends_from_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_extends_from_any output = vx_core::e_extends_from_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_extends_from_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_extends_from_any output = vx_core::e_extends_from_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_extends_from_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "extends<-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_extends_from_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_extends_from_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "extends<-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_extends_from_any::vx_empty() const {return vx_core::e_extends_from_any;}
    vx_core::Type_any Class_extends_from_any::vx_type() const {return vx_core::t_extends_from_any;}
    vx_core::Type_msgblock Class_extends_from_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_extends_from_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_extends_from_any::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_extends_from_any::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_extends_from_any(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_extends_from_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_extends_from_any(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func extends<-typedef)
  vx_core::Type_string f_extends_from_typedef(vx_core::Type_typedef vtypedef) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(vtypedef);
    output = vtypedef->extend();
    vx_core::vx_release_one_except(vtypedef, output);
    return output;
  }
  /**
   * @function extends_from_typedef
   * Get the basetype of a given type
   * @param  {typedef} vtypedef
   * @return {string}
   * (func extends<-typedef)
   */
  // (func extends<-typedef)
  // class Class_extends_from_typedef {
    Abstract_extends_from_typedef::~Abstract_extends_from_typedef() {}

    Class_extends_from_typedef::Class_extends_from_typedef() : Abstract_extends_from_typedef::Abstract_extends_from_typedef() {
      vx_core::refcount += 1;
    }

    Class_extends_from_typedef::~Class_extends_from_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_extends_from_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_extends_from_typedef output = vx_core::e_extends_from_typedef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_extends_from_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_extends_from_typedef output = vx_core::e_extends_from_typedef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_extends_from_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "extends<-typedef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_extends_from_typedef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_extends_from_typedef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "extends<-typedef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_extends_from_typedef::vx_empty() const {return vx_core::e_extends_from_typedef;}
    vx_core::Type_any Class_extends_from_typedef::vx_type() const {return vx_core::t_extends_from_typedef;}
    vx_core::Type_msgblock Class_extends_from_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_extends_from_typedef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_extends_from_typedef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_extends_from_typedef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef inputval = vx_core::vx_any_from_any(vx_core::t_typedef, val);
      output = vx_core::f_extends_from_typedef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_extends_from_typedef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef vtypedef = vx_core::vx_any_from_any(vx_core::t_typedef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_extends_from_typedef(vtypedef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function first_from_list
   * Returns first value
   * @param  {list-1} values
   * @return {any-1}
   * (func first<-list)
   */
  // (func first<-list)
  // class Class_first_from_list {
    Abstract_first_from_list::~Abstract_first_from_list() {}

    Class_first_from_list::Class_first_from_list() : Abstract_first_from_list::Abstract_first_from_list() {
      vx_core::refcount += 1;
    }

    Class_first_from_list::~Class_first_from_list() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_first_from_list::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_first_from_list output = vx_core::e_first_from_list;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_first_from_list::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_first_from_list output = vx_core::e_first_from_list;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_first_from_list::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "first<-list", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_first_from_list::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_first_from_list::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "first<-list", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_first_from_list::vx_empty() const {return vx_core::e_first_from_list;}
    vx_core::Type_any Class_first_from_list::vx_type() const {return vx_core::t_first_from_list;}
    vx_core::Type_msgblock Class_first_from_list::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_first_from_list::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_first_from_list::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_first_from_list::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list inputval = vx_core::vx_any_from_any(vx_core::t_list, val);
      output = vx_core::f_first_from_list(vx_core::t_any, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_first_from_list::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_first_from_list(generic_any_1, values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function first_from_list_any_from_any
   * Returns first value that is not nothing
   * @param  {list-1} values
   * @param  {any<-any} fn-any<-any
   * @return {any-1}
   * (func first<-list-any<-any)
   */
  // (func first<-list-any<-any)
  // class Class_first_from_list_any_from_any {
    Abstract_first_from_list_any_from_any::~Abstract_first_from_list_any_from_any() {}

    Class_first_from_list_any_from_any::Class_first_from_list_any_from_any() : Abstract_first_from_list_any_from_any::Abstract_first_from_list_any_from_any() {
      vx_core::refcount += 1;
    }

    Class_first_from_list_any_from_any::~Class_first_from_list_any_from_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_first_from_list_any_from_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_first_from_list_any_from_any output = vx_core::e_first_from_list_any_from_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_first_from_list_any_from_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_first_from_list_any_from_any output = vx_core::e_first_from_list_any_from_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_first_from_list_any_from_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "first<-list-any<-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_first_from_list_any_from_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_first_from_list_any_from_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "first<-list-any<-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_first_from_list_any_from_any::vx_empty() const {return vx_core::e_first_from_list_any_from_any;}
    vx_core::Type_any Class_first_from_list_any_from_any::vx_type() const {return vx_core::t_first_from_list_any_from_any;}
    vx_core::Type_msgblock Class_first_from_list_any_from_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_first_from_list_any_from_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_first_from_list_any_from_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_any fn_any_from_any = vx_core::vx_any_from_any(vx_core::t_any_from_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_first_from_list_any_from_any(generic_any_1, values, fn_any_from_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func float<-string)
  vx_core::Type_float f_float_from_string(vx_core::Type_string text) {
    vx_core::Type_float output = vx_core::e_float;
    vx_core::vx_reserve(text);
    float num = vx_core::vx_float_from_string(text->vx_string());
    output = vx_core::vx_new_float(num);
    vx_core::vx_release_one_except(text, output);
    return output;
  }
  /**
   * @function float_from_string
   * Returns float from a given string.
   * @param  {string} text
   * @return {float}
   * (func float<-string)
   */
  // (func float<-string)
  // class Class_float_from_string {
    Abstract_float_from_string::~Abstract_float_from_string() {}

    Class_float_from_string::Class_float_from_string() : Abstract_float_from_string::Abstract_float_from_string() {
      vx_core::refcount += 1;
    }

    Class_float_from_string::~Class_float_from_string() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_float_from_string::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_float_from_string output = vx_core::e_float_from_string;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_float_from_string::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_float_from_string output = vx_core::e_float_from_string;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_float_from_string::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "float<-string", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_float_from_string::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_float_from_string::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "float<-string", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_float_from_string::vx_empty() const {return vx_core::e_float_from_string;}
    vx_core::Type_any Class_float_from_string::vx_type() const {return vx_core::t_float_from_string;}
    vx_core::Type_msgblock Class_float_from_string::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_float_from_string::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_float_from_string::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_float_from_string::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_float_from_string(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_float_from_string::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string text = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_float_from_string(text);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function fn
   * Shell for lambda function calls
   * @param  {arglist} parameters
   * @param  {any<-func} fn-any
   * @return {any-1}
   * (func fn)
   */
  // (func fn)
  // class Class_fn {
    Abstract_fn::~Abstract_fn() {}

    Class_fn::Class_fn() : Abstract_fn::Abstract_fn() {
      vx_core::refcount += 1;
    }

    Class_fn::~Class_fn() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_fn::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_fn output = vx_core::e_fn;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_fn::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_fn output = vx_core::e_fn;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_fn::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "fn", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_fn::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_fn::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "fn", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_fn::vx_empty() const {return vx_core::e_fn;}
    vx_core::Type_any Class_fn::vx_type() const {return vx_core::t_fn;}
    vx_core::Type_msgblock Class_fn::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_fn::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_fn::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_arglist parameters = vx_core::vx_any_from_any(vx_core::t_arglist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_func fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_fn(generic_any_1, parameters, fn_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func funcdef<-func)
  vx_core::Type_funcdef f_funcdef_from_func(vx_core::Type_func value) {
    vx_core::Type_funcdef output = vx_core::e_funcdef;
    vx_core::vx_reserve(value);
    output = value->vx_funcdef();
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function funcdef_from_func
   * Returns the definition of a function
   * @param  {func} value
   * @return {funcdef}
   * (func funcdef<-func)
   */
  // (func funcdef<-func)
  // class Class_funcdef_from_func {
    Abstract_funcdef_from_func::~Abstract_funcdef_from_func() {}

    Class_funcdef_from_func::Class_funcdef_from_func() : Abstract_funcdef_from_func::Abstract_funcdef_from_func() {
      vx_core::refcount += 1;
    }

    Class_funcdef_from_func::~Class_funcdef_from_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_funcdef_from_func::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_funcdef_from_func output = vx_core::e_funcdef_from_func;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_funcdef_from_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_funcdef_from_func output = vx_core::e_funcdef_from_func;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_funcdef_from_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "funcdef<-func", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_funcdef_from_func::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_funcdef_from_func::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "funcdef<-func", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_funcdef_from_func::vx_empty() const {return vx_core::e_funcdef_from_func;}
    vx_core::Type_any Class_funcdef_from_func::vx_type() const {return vx_core::t_funcdef_from_func;}
    vx_core::Type_msgblock Class_funcdef_from_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_funcdef_from_func::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_funcdef_from_func::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_funcdef_from_func::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_func inputval = vx_core::vx_any_from_any(vx_core::t_func, val);
      output = vx_core::f_funcdef_from_func(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_funcdef_from_func::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_func value = vx_core::vx_any_from_any(vx_core::t_func, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_funcdef_from_func(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func funcname<-funcdef)
  vx_core::Type_string f_funcname_from_funcdef(vx_core::Type_funcdef funcdef) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(funcdef);
    output = vx_core::f_new(
      vx_core::t_string,
      vx_core::vx_new(vx_core::t_anylist, {
        funcdef->pkgname(),
        vx_core::vx_new_string("/"),
        funcdef->name()
      })
    );
    vx_core::vx_release_one_except(funcdef, output);
    return output;
  }
  /**
   * @function funcname_from_funcdef
   * Get the name of a given funcdef
   * @param  {funcdef} funcdef
   * @return {string}
   * (func funcname<-funcdef)
   */
  // (func funcname<-funcdef)
  // class Class_funcname_from_funcdef {
    Abstract_funcname_from_funcdef::~Abstract_funcname_from_funcdef() {}

    Class_funcname_from_funcdef::Class_funcname_from_funcdef() : Abstract_funcname_from_funcdef::Abstract_funcname_from_funcdef() {
      vx_core::refcount += 1;
    }

    Class_funcname_from_funcdef::~Class_funcname_from_funcdef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_funcname_from_funcdef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_funcname_from_funcdef output = vx_core::e_funcname_from_funcdef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_funcname_from_funcdef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_funcname_from_funcdef output = vx_core::e_funcname_from_funcdef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_funcname_from_funcdef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "funcname<-funcdef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_funcname_from_funcdef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_funcname_from_funcdef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "funcname<-funcdef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_funcname_from_funcdef::vx_empty() const {return vx_core::e_funcname_from_funcdef;}
    vx_core::Type_any Class_funcname_from_funcdef::vx_type() const {return vx_core::t_funcname_from_funcdef;}
    vx_core::Type_msgblock Class_funcname_from_funcdef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_funcname_from_funcdef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_funcname_from_funcdef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_funcname_from_funcdef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_funcdef inputval = vx_core::vx_any_from_any(vx_core::t_funcdef, val);
      output = vx_core::f_funcname_from_funcdef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_funcname_from_funcdef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_funcdef funcdef = vx_core::vx_any_from_any(vx_core::t_funcdef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_funcname_from_funcdef(funcdef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func int<-func)
  vx_core::Type_int f_int_from_func() {
    vx_core::Type_int output = vx_core::e_int;
    return output;
  }
  /**
   * @function int_from_func
   * Function Type returning int with any parameters
   * @return {int}
   * (func int<-func)
   */
  // (func int<-func)
  // class Class_int_from_func {
    Abstract_int_from_func::~Abstract_int_from_func() {}

    Class_int_from_func::Class_int_from_func() : Abstract_int_from_func::Abstract_int_from_func() {
      vx_core::refcount += 1;
    }

    Class_int_from_func::~Class_int_from_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Type_any Class_int_from_func::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_int_from_func output = vx_core::e_int_from_func;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_int_from_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_int_from_func output = vx_core::e_int_from_func;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_int_from_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "int<-func", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_int_from_func::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_int_from_func::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "int<-func", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_int_from_func::vx_empty() const {return vx_core::e_int_from_func;}
    vx_core::Type_any Class_int_from_func::vx_type() const {return vx_core::t_int_from_func;}
    vx_core::Type_msgblock Class_int_from_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_int_from_func::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_int_from_func vx_core::Class_int_from_func::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_int_from_func::IFn fn) const {
      vx_core::Func_int_from_func output = new vx_core::Class_int_from_func();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_int Class_int_from_func::vx_int_from_func() const {
      vx_core::Type_int output = vx_core::e_int;
      if (fn) {
        output = fn();
      }
      return output;
    }

    vx_core::Type_any Class_int_from_func::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      output = vx_core::f_int_from_func();
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func int<-string)
  vx_core::Type_int f_int_from_string(vx_core::Type_string value) {
    vx_core::Type_int output = vx_core::e_int;
    vx_core::vx_reserve(value);
    output = vx_core::f_switch(
      vx_core::t_int,
      value,
      vx_core::vx_new(vx_core::t_thenelselist, {
        vx_core::f_case_1(
          vx_core::vx_new_string("notanumber"),
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_int output_1 = vx_core::c_notanumber;
            return output_1;
          })
        ),
        vx_core::f_case_1(
          vx_core::vx_new_string("infinity"),
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_int output_1 = vx_core::c_infinity;
            return output_1;
          })
        ),
        vx_core::f_case_1(
          vx_core::vx_new_string("neginfinity"),
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_int output_1 = vx_core::c_neginfinity;
            return output_1;
          })
        ),
        vx_core::f_else(
          vx_core::t_any_from_func->vx_fn_new({value}, [value]() {// :capture value
            vx_core::Type_int intresult = vx_core::e_int;
            try {
              std::string sval = value->vx_string();
              long ival = std::stoll(sval);
              intresult = vx_core::vx_new_int(ival);
            } catch (std::exception ex) {
              intresult = vx_core::c_notanumber;
            }
            return intresult;
          })
        )
      })
    );
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function int_from_string
   * Function Type converting string to int
   * @param  {string} value
   * @return {int}
   * (func int<-string)
   */
  // (func int<-string)
  // class Class_int_from_string {
    Abstract_int_from_string::~Abstract_int_from_string() {}

    Class_int_from_string::Class_int_from_string() : Abstract_int_from_string::Abstract_int_from_string() {
      vx_core::refcount += 1;
    }

    Class_int_from_string::~Class_int_from_string() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_int_from_string::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_int_from_string output = vx_core::e_int_from_string;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_int_from_string::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_int_from_string output = vx_core::e_int_from_string;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_int_from_string::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "int<-string", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_int_from_string::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_int_from_string::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "int<-string", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_int_from_string::vx_empty() const {return vx_core::e_int_from_string;}
    vx_core::Type_any Class_int_from_string::vx_type() const {return vx_core::t_int_from_string;}
    vx_core::Type_msgblock Class_int_from_string::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_int_from_string::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_int_from_string::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_int_from_string::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_int_from_string(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_int_from_string::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string value = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_int_from_string(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func is-endswith)
  vx_core::Type_boolean f_is_endswith(vx_core::Type_string text, vx_core::Type_string find) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve({text, find});
    std::string stext = text->vx_string();
    std::string sfind = find->vx_string();
    if (vx_core::vx_boolean_from_string_ends(stext, sfind)) {
      output = vx_core::c_true;
    };
    vx_core::vx_release_one_except({text, find}, output);
    return output;
  }
  /**
   * @function is_endswith
   * Returns true if text ends with find.
   * @param  {string} text
   * @param  {string} find
   * @return {boolean}
   * (func is-endswith)
   */
  // (func is-endswith)
  // class Class_is_endswith {
    Abstract_is_endswith::~Abstract_is_endswith() {}

    Class_is_endswith::Class_is_endswith() : Abstract_is_endswith::Abstract_is_endswith() {
      vx_core::refcount += 1;
    }

    Class_is_endswith::~Class_is_endswith() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_is_endswith::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_endswith output = vx_core::e_is_endswith;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_is_endswith::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_endswith output = vx_core::e_is_endswith;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_is_endswith::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "is-endswith", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_is_endswith::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_is_endswith::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "is-endswith", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_is_endswith::vx_empty() const {return vx_core::e_is_endswith;}
    vx_core::Type_any Class_is_endswith::vx_type() const {return vx_core::t_is_endswith;}
    vx_core::Type_msgblock Class_is_endswith::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_is_endswith::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_is_endswith::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string text = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string find = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_is_endswith(text, find);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func is-float)
  vx_core::Type_boolean f_is_float(vx_core::Type_any value) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(value);
    bool result = vx_core::vx_is_float(value);
    output = vx_core::vx_new_boolean(result);
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function is_float
   * Returns true if the value is a float.
   * @param  {any} value
   * @return {boolean}
   * (func is-float)
   */
  // (func is-float)
  // class Class_is_float {
    Abstract_is_float::~Abstract_is_float() {}

    Class_is_float::Class_is_float() : Abstract_is_float::Abstract_is_float() {
      vx_core::refcount += 1;
    }

    Class_is_float::~Class_is_float() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_is_float::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_float output = vx_core::e_is_float;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_is_float::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_float output = vx_core::e_is_float;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_is_float::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "is-float", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_is_float::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_is_float::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "is-float", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_is_float::vx_empty() const {return vx_core::e_is_float;}
    vx_core::Type_any Class_is_float::vx_type() const {return vx_core::t_is_float;}
    vx_core::Type_msgblock Class_is_float::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_is_float::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_is_float::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_is_float::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_is_float(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_is_float::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_is_float(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func is-func)
  vx_core::Type_boolean f_is_func(vx_core::Type_any value) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(value);
    vx_core::Type_string extend = vx_core::f_extends_from_any(value);
    std::string sextend = extend->vx_string();
    vx_core::vx_release(extend);
    if (sextend == ":func") {
      output = vx_core::c_true;
    };
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function is_func
   * Returns true if value is a function.
   * @param  {any} value
   * @return {boolean}
   * (func is-func)
   */
  // (func is-func)
  // class Class_is_func {
    Abstract_is_func::~Abstract_is_func() {}

    Class_is_func::Class_is_func() : Abstract_is_func::Abstract_is_func() {
      vx_core::refcount += 1;
    }

    Class_is_func::~Class_is_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_is_func::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_func output = vx_core::e_is_func;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_is_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_func output = vx_core::e_is_func;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_is_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "is-func", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_is_func::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_is_func::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "is-func", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_is_func::vx_empty() const {return vx_core::e_is_func;}
    vx_core::Type_any Class_is_func::vx_type() const {return vx_core::t_is_func;}
    vx_core::Type_msgblock Class_is_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_is_func::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_is_func::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_is_func::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_is_func(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_is_func::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_is_func(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func is-int)
  vx_core::Type_boolean f_is_int(vx_core::Type_any value) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(value);
    bool result = vx_core::vx_is_int(value);
    output = vx_core::vx_new_boolean(result);
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function is_int
   * Returns true if the value is an integer.
   * @param  {any} value
   * @return {boolean}
   * (func is-int)
   */
  // (func is-int)
  // class Class_is_int {
    Abstract_is_int::~Abstract_is_int() {}

    Class_is_int::Class_is_int() : Abstract_is_int::Abstract_is_int() {
      vx_core::refcount += 1;
    }

    Class_is_int::~Class_is_int() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_is_int::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_int output = vx_core::e_is_int;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_is_int::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_int output = vx_core::e_is_int;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_is_int::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "is-int", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_is_int::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_is_int::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "is-int", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_is_int::vx_empty() const {return vx_core::e_is_int;}
    vx_core::Type_any Class_is_int::vx_type() const {return vx_core::t_is_int;}
    vx_core::Type_msgblock Class_is_int::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_is_int::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_is_int::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_is_int::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_is_int(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_is_int::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_is_int(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func is-number)
  vx_core::Type_boolean f_is_number(vx_core::Type_any value) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(value);
    output = vx_core::f_switch(
      vx_core::t_boolean,
      vx_core::f_typename_from_any(value),
      vx_core::vx_new(vx_core::t_thenelselist, {
        vx_core::f_case(
          vx_core::f_new(
            vx_core::t_list,
            vx_core::vx_new(vx_core::t_anylist, {
              vx_core::vx_new_string("vx/core/decimal"),
              vx_core::vx_new_string("vx/core/float"),
              vx_core::vx_new_string("vx/core/int"),
              vx_core::vx_new_string("vx/core/number")
            })
          ),
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_boolean output_1 = vx_core::vx_new_boolean(true);
            return output_1;
          })
        ),
        vx_core::f_else(
          vx_core::t_any_from_func->vx_fn_new({}, []() {
            vx_core::Type_boolean output_1 = vx_core::vx_new_boolean(false);
            return output_1;
          })
        )
      })
    );
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function is_number
   * Return true if value is a number
   * @param  {any} value
   * @return {boolean}
   * (func is-number)
   */
  // (func is-number)
  // class Class_is_number {
    Abstract_is_number::~Abstract_is_number() {}

    Class_is_number::Class_is_number() : Abstract_is_number::Abstract_is_number() {
      vx_core::refcount += 1;
    }

    Class_is_number::~Class_is_number() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_is_number::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_number output = vx_core::e_is_number;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_is_number::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_number output = vx_core::e_is_number;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_is_number::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "is-number", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_is_number::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_is_number::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "is-number", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_is_number::vx_empty() const {return vx_core::e_is_number;}
    vx_core::Type_any Class_is_number::vx_type() const {return vx_core::t_is_number;}
    vx_core::Type_msgblock Class_is_number::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_is_number::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_is_number::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_is_number::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_is_number(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_is_number::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_is_number(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func is-pass<-permission)
  vx_core::Type_boolean f_is_pass_from_permission(vx_core::Type_context context, vx_core::Type_permission permission) {
    vx_core::Type_boolean output = vx_core::e_boolean;
    vx_core::vx_reserve(permission);
    output = vx_core::f_let(
      vx_core::t_boolean,
      vx_core::t_any_from_func->vx_fn_new({permission, context}, [permission, context]() {
        vx_core::Type_string id = permission->id();
        vx_core::vx_ref_plus(id);
        vx_core::Type_permission lookup = vx_core::f_permission_from_id_context(context, id);
        vx_core::vx_ref_plus(lookup);
        vx_core::Type_boolean output_1 = vx_core::f_eq(lookup, permission);
        vx_core::vx_release_one_except({id, lookup}, output_1);
        return output_1;
      })
    );
    vx_core::vx_release_one_except(permission, output);
    return output;
  }
  /**
   * @function is_pass_from_permission
   * Returns true if permission passes.
   * @param  {permission} permission
   * @return {boolean}
   * (func is-pass<-permission)
   */
  // (func is-pass<-permission)
  // class Class_is_pass_from_permission {
    Abstract_is_pass_from_permission::~Abstract_is_pass_from_permission() {}

    Class_is_pass_from_permission::Class_is_pass_from_permission() : Abstract_is_pass_from_permission::Abstract_is_pass_from_permission() {
      vx_core::refcount += 1;
    }

    Class_is_pass_from_permission::~Class_is_pass_from_permission() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_is_pass_from_permission::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_pass_from_permission output = vx_core::e_is_pass_from_permission;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_is_pass_from_permission::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_is_pass_from_permission output = vx_core::e_is_pass_from_permission;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_is_pass_from_permission::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "is-pass<-permission", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_is_pass_from_permission::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_is_pass_from_permission::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "is-pass<-permission", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_is_pass_from_permission::vx_empty() const {return vx_core::e_is_pass_from_permission;}
    vx_core::Type_any Class_is_pass_from_permission::vx_type() const {return vx_core::t_is_pass_from_permission;}
    vx_core::Type_msgblock Class_is_pass_from_permission::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_is_pass_from_permission::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any_context Class_is_pass_from_permission::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_context::IFn fn) const {
      return vx_core::e_any_from_any_context;
    }

    vx_core::Type_any Class_is_pass_from_permission::vx_any_from_any_context(vx_core::Type_context context, vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_permission inputval = vx_core::vx_any_from_any(vx_core::t_permission, val);
      output = vx_core::f_is_pass_from_permission(context, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_is_pass_from_permission::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_permission permission = vx_core::vx_any_from_any(vx_core::t_permission, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_is_pass_from_permission(context, permission);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function last_from_list
   * Returns last value
   * @param  {list-1} values
   * @return {any-1}
   * (func last<-list)
   */
  // (func last<-list)
  // class Class_last_from_list {
    Abstract_last_from_list::~Abstract_last_from_list() {}

    Class_last_from_list::Class_last_from_list() : Abstract_last_from_list::Abstract_last_from_list() {
      vx_core::refcount += 1;
    }

    Class_last_from_list::~Class_last_from_list() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_last_from_list::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_last_from_list output = vx_core::e_last_from_list;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_last_from_list::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_last_from_list output = vx_core::e_last_from_list;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_last_from_list::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "last<-list", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_last_from_list::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_last_from_list::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "last<-list", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_last_from_list::vx_empty() const {return vx_core::e_last_from_list;}
    vx_core::Type_any Class_last_from_list::vx_type() const {return vx_core::t_last_from_list;}
    vx_core::Type_msgblock Class_last_from_list::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_last_from_list::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_last_from_list::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_last_from_list::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list inputval = vx_core::vx_any_from_any(vx_core::t_list, val);
      output = vx_core::f_last_from_list(vx_core::t_any, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_last_from_list::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_last_from_list(generic_any_1, values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function list_join_from_list 1
   * Returns a flattened list of processed items from another list
   * @param  {list-2} values
   * @param  {any<-any} fn-any<-any
   * @return {list-1}
   * (func list-join<-list)
   */
  // (func list-join<-list)
  // class Class_list_join_from_list_1 {
    Abstract_list_join_from_list_1::~Abstract_list_join_from_list_1() {}

    Class_list_join_from_list_1::Class_list_join_from_list_1() : Abstract_list_join_from_list_1::Abstract_list_join_from_list_1() {
      vx_core::refcount += 1;
    }

    Class_list_join_from_list_1::~Class_list_join_from_list_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_join_from_list_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_join_from_list_1 output = vx_core::e_list_join_from_list_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_join_from_list_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_join_from_list_1 output = vx_core::e_list_join_from_list_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_join_from_list_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_join_from_list_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_join_from_list_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_join_from_list_1::vx_empty() const {return vx_core::e_list_join_from_list_1;}
    vx_core::Type_any Class_list_join_from_list_1::vx_type() const {return vx_core::t_list_join_from_list_1;}
    vx_core::Type_msgblock Class_list_join_from_list_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_join_from_list_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_list_join_from_list_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_any fn_any_from_any = vx_core::vx_any_from_any(vx_core::t_any_from_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_list_join_from_list_1(generic_list_1, values, fn_any_from_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function list_join_from_list
   * Returns a list by joining the valid values in each value list
   * @param  {list-2} values
   * @return {list-1}
   * (func list-join<-list)
   */
  // (func list-join<-list)
  // class Class_list_join_from_list {
    Abstract_list_join_from_list::~Abstract_list_join_from_list() {}

    Class_list_join_from_list::Class_list_join_from_list() : Abstract_list_join_from_list::Abstract_list_join_from_list() {
      vx_core::refcount += 1;
    }

    Class_list_join_from_list::~Class_list_join_from_list() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_join_from_list::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_join_from_list output = vx_core::e_list_join_from_list;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_join_from_list::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_join_from_list output = vx_core::e_list_join_from_list;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_join_from_list::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_join_from_list::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_join_from_list::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_join_from_list::vx_empty() const {return vx_core::e_list_join_from_list;}
    vx_core::Type_any Class_list_join_from_list::vx_type() const {return vx_core::t_list_join_from_list;}
    vx_core::Type_msgblock Class_list_join_from_list::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_join_from_list::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_list_join_from_list::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_list_join_from_list::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list inputval = vx_core::vx_any_from_any(vx_core::t_list, val);
      output = vx_core::f_list_join_from_list(vx_core::t_list, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_list_join_from_list::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_list_join_from_list(generic_list_1, values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function list_from_list 1
   * Returns a list of processed items from another list
   * @param  {list-2} values
   * @param  {any<-any} fn-any<-any
   * @return {list-1}
   * (func list<-list)
   */
  // (func list<-list)
  // class Class_list_from_list_1 {
    Abstract_list_from_list_1::~Abstract_list_from_list_1() {}

    Class_list_from_list_1::Class_list_from_list_1() : Abstract_list_from_list_1::Abstract_list_from_list_1() {
      vx_core::refcount += 1;
    }

    Class_list_from_list_1::~Class_list_from_list_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_from_list_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_list_1 output = vx_core::e_list_from_list_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_from_list_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_list_1 output = vx_core::e_list_from_list_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_from_list_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list<-list", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_from_list_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_from_list_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_from_list_1::vx_empty() const {return vx_core::e_list_from_list_1;}
    vx_core::Type_any Class_list_from_list_1::vx_type() const {return vx_core::t_list_from_list_1;}
    vx_core::Type_msgblock Class_list_from_list_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_from_list_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_list_from_list_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_any fn_any_from_any = vx_core::vx_any_from_any(vx_core::t_any_from_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_list_from_list_1(generic_list_1, values, fn_any_from_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function list_from_list
   * Return a list with allowed values from another list
   * @param  {list-2} values
   * @return {list-1}
   * (func list<-list)
   */
  // (func list<-list)
  // class Class_list_from_list {
    Abstract_list_from_list::~Abstract_list_from_list() {}

    Class_list_from_list::Class_list_from_list() : Abstract_list_from_list::Abstract_list_from_list() {
      vx_core::refcount += 1;
    }

    Class_list_from_list::~Class_list_from_list() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_from_list::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_list output = vx_core::e_list_from_list;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_from_list::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_list output = vx_core::e_list_from_list;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_from_list::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list<-list", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_from_list::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_from_list::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_from_list::vx_empty() const {return vx_core::e_list_from_list;}
    vx_core::Type_any Class_list_from_list::vx_type() const {return vx_core::t_list_from_list;}
    vx_core::Type_msgblock Class_list_from_list::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_from_list::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_list_from_list::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_list_from_list::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list inputval = vx_core::vx_any_from_any(vx_core::t_list, val);
      output = vx_core::f_list_from_list(vx_core::t_list, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_list_from_list::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_list_from_list(generic_list_1, values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function list_from_list_async
   * Returns an asynchronous list of the processed asynchronous items from another list
   * @param  {list-2} values
   * @param  {any<-any-async} fn-any<-any-async
   * @return {list-1}
   * (func list<-list-async)
   */
  // (func list<-list-async)
  // class Class_list_from_list_async {
    Abstract_list_from_list_async::~Abstract_list_from_list_async() {}

    Class_list_from_list_async::Class_list_from_list_async() : Abstract_list_from_list_async::Abstract_list_from_list_async() {
      vx_core::refcount += 1;
    }

    Class_list_from_list_async::~Class_list_from_list_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_from_list_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_list_async output = vx_core::e_list_from_list_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_from_list_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_list_async output = vx_core::e_list_from_list_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_from_list_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list<-list-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_from_list_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_from_list_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list<-list-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_from_list_async::vx_empty() const {return vx_core::e_list_from_list_async;}
    vx_core::Type_any Class_list_from_list_async::vx_type() const {return vx_core::t_list_from_list_async;}
    vx_core::Type_msgblock Class_list_from_list_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_from_list_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_list_from_list_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_any_async fn_any_from_any_async = vx_core::vx_any_from_any(vx_core::t_any_from_any_async, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_list_from_list_async(generic_list_1, values, fn_any_from_any_async);
      vx_core::vx_release(arglist);
      return output;
    }

  //}
  /**
   * @function list_from_list_intany
   * Returns a list of processed items from another list
   * @param  {list-2} values
   * @param  {any<-int-any} fn-any<-int-any
   * @return {list-1}
   * (func list<-list-intany)
   */
  // (func list<-list-intany)
  // class Class_list_from_list_intany {
    Abstract_list_from_list_intany::~Abstract_list_from_list_intany() {}

    Class_list_from_list_intany::Class_list_from_list_intany() : Abstract_list_from_list_intany::Abstract_list_from_list_intany() {
      vx_core::refcount += 1;
    }

    Class_list_from_list_intany::~Class_list_from_list_intany() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_from_list_intany::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_list_intany output = vx_core::e_list_from_list_intany;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_from_list_intany::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_list_intany output = vx_core::e_list_from_list_intany;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_from_list_intany::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list<-list-intany", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_from_list_intany::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_from_list_intany::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list<-list-intany", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_from_list_intany::vx_empty() const {return vx_core::e_list_from_list_intany;}
    vx_core::Type_any Class_list_from_list_intany::vx_type() const {return vx_core::t_list_from_list_intany;}
    vx_core::Type_msgblock Class_list_from_list_intany::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_from_list_intany::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_list_from_list_intany::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list values = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_int_any fn_any_from_int_any = vx_core::vx_any_from_any(vx_core::t_any_from_int_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_list_from_list_intany(generic_list_1, values, fn_any_from_int_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function list_from_map 1
   * Returns a list from a map by applying a function to each key value.
   * @param  {map-2} valuemap
   * @param  {any<-key-value} fn-any<-key-value
   * @return {list-1}
   * (func list<-map)
   */
  // (func list<-map)
  // class Class_list_from_map_1 {
    Abstract_list_from_map_1::~Abstract_list_from_map_1() {}

    Class_list_from_map_1::Class_list_from_map_1() : Abstract_list_from_map_1::Abstract_list_from_map_1() {
      vx_core::refcount += 1;
    }

    Class_list_from_map_1::~Class_list_from_map_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_from_map_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_map_1 output = vx_core::e_list_from_map_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_from_map_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_map_1 output = vx_core::e_list_from_map_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_from_map_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list<-map", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_from_map_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_from_map_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_from_map_1::vx_empty() const {return vx_core::e_list_from_map_1;}
    vx_core::Type_any Class_list_from_map_1::vx_type() const {return vx_core::t_list_from_map_1;}
    vx_core::Type_msgblock Class_list_from_map_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_from_map_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_list_from_map_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_map valuemap = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_key_value fn_any_from_key_value = vx_core::vx_any_from_any(vx_core::t_any_from_key_value, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function list_from_map
   * Returns a list of allowed values from a map.
   * @param  {map-2} valuemap
   * @return {list-1}
   * (func list<-map)
   */
  // (func list<-map)
  // class Class_list_from_map {
    Abstract_list_from_map::~Abstract_list_from_map() {}

    Class_list_from_map::Class_list_from_map() : Abstract_list_from_map::Abstract_list_from_map() {
      vx_core::refcount += 1;
    }

    Class_list_from_map::~Class_list_from_map() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_from_map::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_map output = vx_core::e_list_from_map;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_from_map::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_map output = vx_core::e_list_from_map;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_from_map::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list<-map", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_from_map::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_from_map::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_from_map::vx_empty() const {return vx_core::e_list_from_map;}
    vx_core::Type_any Class_list_from_map::vx_type() const {return vx_core::t_list_from_map;}
    vx_core::Type_msgblock Class_list_from_map::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_from_map::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_list_from_map::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_list_from_map::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map inputval = vx_core::vx_any_from_any(vx_core::t_map, val);
      output = vx_core::f_list_from_map(vx_core::t_list, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_list_from_map::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_map valuemap = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_list_from_map(generic_list_1, valuemap);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function list_from_map_async
   * @param  {map-2} valuemap
   * @param  {any<-key-value-async} fn-any<-key-value-async
   * @return {list-1}
   * (func list<-map-async)
   */
  // (func list<-map-async)
  // class Class_list_from_map_async {
    Abstract_list_from_map_async::~Abstract_list_from_map_async() {}

    Class_list_from_map_async::Class_list_from_map_async() : Abstract_list_from_map_async::Abstract_list_from_map_async() {
      vx_core::refcount += 1;
    }

    Class_list_from_map_async::~Class_list_from_map_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_from_map_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_map_async output = vx_core::e_list_from_map_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_from_map_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_map_async output = vx_core::e_list_from_map_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_from_map_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list<-map-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_from_map_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_from_map_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list<-map-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_from_map_async::vx_empty() const {return vx_core::e_list_from_map_async;}
    vx_core::Type_any Class_list_from_map_async::vx_type() const {return vx_core::t_list_from_map_async;}
    vx_core::Type_msgblock Class_list_from_map_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_from_map_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::vx_Type_async Class_list_from_map_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_map valuemap = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_key_value_async fn_any_from_key_value_async = vx_core::vx_any_from_any(vx_core::t_any_from_key_value_async, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_list_from_map_async(generic_list_1, valuemap, fn_any_from_key_value_async);
      vx_core::vx_release(arglist);
      return output;
    }

  //}

  // (func list<-type)
  vx_core::Type_any f_list_from_type(vx_core::Type_any type) {
    vx_core::Type_any output = vx_core::e_any;
    vx_core::vx_reserve(type);
    vx_core::vx_release_one_except(type, output);
    return output;
  }
  /**
   * @function list_from_type
   * Create an empty list from a type. Used internally for default lists
   * @param  {any} type
   * @return {any}
   * (func list<-type)
   */
  // (func list<-type)
  // class Class_list_from_type {
    Abstract_list_from_type::~Abstract_list_from_type() {}

    Class_list_from_type::Class_list_from_type() : Abstract_list_from_type::Abstract_list_from_type() {
      vx_core::refcount += 1;
    }

    Class_list_from_type::~Class_list_from_type() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_list_from_type::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_type output = vx_core::e_list_from_type;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_list_from_type::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_list_from_type output = vx_core::e_list_from_type;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_list_from_type::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "list<-type", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_list_from_type::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_list_from_type::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "list<-type", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_list_from_type::vx_empty() const {return vx_core::e_list_from_type;}
    vx_core::Type_any Class_list_from_type::vx_type() const {return vx_core::t_list_from_type;}
    vx_core::Type_msgblock Class_list_from_type::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_list_from_type::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_list_from_type::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_list_from_type::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_list_from_type(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_list_from_type::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any type = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_list_from_type(type);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function log 1
   * Writes a string and a value to the console.
   * @param  {string} text
   * @param  {any-1} value
   * @return {any-1}
   * (func log)
   */
  // (func log)
  // class Class_log_1 {
    Abstract_log_1::~Abstract_log_1() {}

    Class_log_1::Class_log_1() : Abstract_log_1::Abstract_log_1() {
      vx_core::refcount += 1;
    }

    Class_log_1::~Class_log_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_log_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_log_1 output = vx_core::e_log_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_log_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_log_1 output = vx_core::e_log_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_log_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "log", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_log_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_log_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "log", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_log_1::vx_empty() const {return vx_core::e_log_1;}
    vx_core::Type_any Class_log_1::vx_type() const {return vx_core::t_log_1;}
    vx_core::Type_msgblock Class_log_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_log_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_log_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string text = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_log_1(generic_any_1, text, value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func log)
  vx_core::Type_any f_log(vx_core::Type_any value) {
    vx_core::Type_any output = vx_core::e_any;
    vx_core::vx_reserve(value);
    vx_core::vx_log(value);
    output = value;
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function log
   * Writes a value to the console.
   * @param  {any} value
   * @return {any}
   * (func log)
   */
  // (func log)
  // class Class_log {
    Abstract_log::~Abstract_log() {}

    Class_log::Class_log() : Abstract_log::Abstract_log() {
      vx_core::refcount += 1;
    }

    Class_log::~Class_log() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_log::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_log output = vx_core::e_log;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_log::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_log output = vx_core::e_log;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_log::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "log", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_log::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_log::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "log", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_log::vx_empty() const {return vx_core::e_log;}
    vx_core::Type_any Class_log::vx_type() const {return vx_core::t_log;}
    vx_core::Type_msgblock Class_log::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_log::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_log::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_log::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_log(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_log::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_log(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func main)
  vx_core::Type_string f_main(vx_core::Type_anylist args) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(args);
    output = vx_core::f_new(vx_core::t_string, args);
    vx_core::vx_release_one_except(args, output);
    return output;
  }
  /**
   * @function main
   * The default function for app main execution. Arguments come from the command line.
   * @param  {anylist} args
   * @return {string}
   * (func main)
   */
  // (func main)
  // class Class_main {
    Abstract_main::~Abstract_main() {}

    Class_main::Class_main() : Abstract_main::Abstract_main() {
      vx_core::refcount += 1;
    }

    Class_main::~Class_main() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_main::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_main output = vx_core::e_main;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_main::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_main output = vx_core::e_main;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_main::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "main", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_main::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_main::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "main", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_main::vx_empty() const {return vx_core::e_main;}
    vx_core::Type_any Class_main::vx_type() const {return vx_core::t_main;}
    vx_core::Type_msgblock Class_main::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_main::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_main::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_main::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist inputval = vx_core::vx_any_from_any(vx_core::t_anylist, val);
      output = vx_core::f_main(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_main::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist args = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_main(args);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function map_from_list
   * Returns a map from a list by applying a function to generate a key for each value.
   * @param  {list-2} vallist
   * @param  {any<-any} fn-any<-any
   * @return {map-1}
   * (func map<-list)
   */
  // (func map<-list)
  // class Class_map_from_list {
    Abstract_map_from_list::~Abstract_map_from_list() {}

    Class_map_from_list::Class_map_from_list() : Abstract_map_from_list::Abstract_map_from_list() {
      vx_core::refcount += 1;
    }

    Class_map_from_list::~Class_map_from_list() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_map_from_list::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_map_from_list output = vx_core::e_map_from_list;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_map_from_list::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_map_from_list output = vx_core::e_map_from_list;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_map_from_list::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "map<-list", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_map_from_list::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_map_from_list::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "map<-list", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_map_from_list::vx_empty() const {return vx_core::e_map_from_list;}
    vx_core::Type_any Class_map_from_list::vx_type() const {return vx_core::t_map_from_list;}
    vx_core::Type_msgblock Class_map_from_list::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_map_from_list::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_map_from_list::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map generic_map_1 = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list vallist = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_any fn_any_from_any = vx_core::vx_any_from_any(vx_core::t_any_from_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_map_from_list(generic_map_1, vallist, fn_any_from_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function map_from_map 1
   * Returns a map from a map by applying a function to each key value.
   * @param  {map-2} valuemap
   * @param  {any<-key-value} fn-any<-key-value
   * @return {map-1}
   * (func map<-map)
   */
  // (func map<-map)
  // class Class_map_from_map_1 {
    Abstract_map_from_map_1::~Abstract_map_from_map_1() {}

    Class_map_from_map_1::Class_map_from_map_1() : Abstract_map_from_map_1::Abstract_map_from_map_1() {
      vx_core::refcount += 1;
    }

    Class_map_from_map_1::~Class_map_from_map_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_map_from_map_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_map_from_map_1 output = vx_core::e_map_from_map_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_map_from_map_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_map_from_map_1 output = vx_core::e_map_from_map_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_map_from_map_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "map<-map", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_map_from_map_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_map_from_map_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_map_from_map_1::vx_empty() const {return vx_core::e_map_from_map_1;}
    vx_core::Type_any Class_map_from_map_1::vx_type() const {return vx_core::t_map_from_map_1;}
    vx_core::Type_msgblock Class_map_from_map_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_map_from_map_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_map_from_map_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map generic_map_1 = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_map valuemap = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_key_value fn_any_from_key_value = vx_core::vx_any_from_any(vx_core::t_any_from_key_value, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_map_from_map_1(generic_map_1, valuemap, fn_any_from_key_value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function map_from_map
   * Return a map with allowed values from another map
   * @param  {map-2} valuemap
   * @return {map-1}
   * (func map<-map)
   */
  // (func map<-map)
  // class Class_map_from_map {
    Abstract_map_from_map::~Abstract_map_from_map() {}

    Class_map_from_map::Class_map_from_map() : Abstract_map_from_map::Abstract_map_from_map() {
      vx_core::refcount += 1;
    }

    Class_map_from_map::~Class_map_from_map() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_map_from_map::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_map_from_map output = vx_core::e_map_from_map;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_map_from_map::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_map_from_map output = vx_core::e_map_from_map;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_map_from_map::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "map<-map", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_map_from_map::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_map_from_map::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_map_from_map::vx_empty() const {return vx_core::e_map_from_map;}
    vx_core::Type_any Class_map_from_map::vx_type() const {return vx_core::t_map_from_map;}
    vx_core::Type_msgblock Class_map_from_map::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_map_from_map::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_map_from_map::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_map_from_map::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map inputval = vx_core::vx_any_from_any(vx_core::t_map, val);
      output = vx_core::f_map_from_map(vx_core::t_map, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_map_from_map::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map generic_map_1 = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_map valuemap = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_map_from_map(generic_map_1, valuemap);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func msg<-error)
  vx_core::Type_msg f_msg_from_error_2(vx_core::Type_string path, vx_core::Type_string code, vx_core::Type_any detail) {
    vx_core::Type_msg output = vx_core::e_msg;
    vx_core::vx_reserve({path, code, detail});
    output = vx_core::f_new(
      vx_core::t_msg,
      vx_core::vx_new(vx_core::t_anylist, {
        vx_core::vx_new_string(":code"),
        code,
        vx_core::vx_new_string(":path"),
        path,
        vx_core::vx_new_string(":severity"),
        vx_core::c_msg_error,
        vx_core::vx_new_string(":detail"),
        detail
      })
    );
    vx_core::vx_release_one_except({path, code, detail}, output);
    return output;
  }
  /**
   * @function msg_from_error 2
   * Returns a msg from error path code and detail
   * @param  {string} path
   * @param  {string} code
   * @param  {any} detail
   * @return {msg}
   * (func msg<-error)
   */
  // (func msg<-error)
  // class Class_msg_from_error_2 {
    Abstract_msg_from_error_2::~Abstract_msg_from_error_2() {}

    Class_msg_from_error_2::Class_msg_from_error_2() : Abstract_msg_from_error_2::Abstract_msg_from_error_2() {
      vx_core::refcount += 1;
    }

    Class_msg_from_error_2::~Class_msg_from_error_2() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_msg_from_error_2::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_msg_from_error_2 output = vx_core::e_msg_from_error_2;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_msg_from_error_2::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_msg_from_error_2 output = vx_core::e_msg_from_error_2;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_msg_from_error_2::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msg_from_error_2::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_msg_from_error_2::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        2, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_msg_from_error_2::vx_empty() const {return vx_core::e_msg_from_error_2;}
    vx_core::Type_any Class_msg_from_error_2::vx_type() const {return vx_core::t_msg_from_error_2;}
    vx_core::Type_msgblock Class_msg_from_error_2::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_msg_from_error_2::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_msg_from_error_2::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string path = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string code = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Type_any detail = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_msg_from_error_2(path, code, detail);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func msg<-error)
  vx_core::Type_msg f_msg_from_error_1(vx_core::Type_string code, vx_core::Type_any detail) {
    vx_core::Type_msg output = vx_core::e_msg;
    vx_core::vx_reserve({code, detail});
    output = vx_core::f_new(
      vx_core::t_msg,
      vx_core::vx_new(vx_core::t_anylist, {
        vx_core::vx_new_string(":code"),
        code,
        vx_core::vx_new_string(":detail"),
        detail,
        vx_core::vx_new_string(":severity"),
        vx_core::c_msg_error
      })
    );
    vx_core::vx_release_one_except({code, detail}, output);
    return output;
  }
  /**
   * @function msg_from_error 1
   * Returns a msg from error code and detail
   * @param  {string} code
   * @param  {any} detail
   * @return {msg}
   * (func msg<-error)
   */
  // (func msg<-error)
  // class Class_msg_from_error_1 {
    Abstract_msg_from_error_1::~Abstract_msg_from_error_1() {}

    Class_msg_from_error_1::Class_msg_from_error_1() : Abstract_msg_from_error_1::Abstract_msg_from_error_1() {
      vx_core::refcount += 1;
    }

    Class_msg_from_error_1::~Class_msg_from_error_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_msg_from_error_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_msg_from_error_1 output = vx_core::e_msg_from_error_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_msg_from_error_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_msg_from_error_1 output = vx_core::e_msg_from_error_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_msg_from_error_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msg_from_error_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_msg_from_error_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_msg_from_error_1::vx_empty() const {return vx_core::e_msg_from_error_1;}
    vx_core::Type_any Class_msg_from_error_1::vx_type() const {return vx_core::t_msg_from_error_1;}
    vx_core::Type_msgblock Class_msg_from_error_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_msg_from_error_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_msg_from_error_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string code = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any detail = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_msg_from_error_1(code, detail);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func msg<-error)
  vx_core::Type_msg f_msg_from_error(vx_core::Type_string error) {
    vx_core::Type_msg output = vx_core::e_msg;
    vx_core::vx_reserve(error);
    output = vx_core::f_new(
      vx_core::t_msg,
      vx_core::vx_new(vx_core::t_anylist, {
        vx_core::vx_new_string(":severity"),
        vx_core::c_msg_error,
        vx_core::vx_new_string(":text"),
        error
      })
    );
    vx_core::vx_release_one_except(error, output);
    return output;
  }
  /**
   * @function msg_from_error
   * Returns a msg from error string
   * @param  {string} error
   * @return {msg}
   * (func msg<-error)
   */
  // (func msg<-error)
  // class Class_msg_from_error {
    Abstract_msg_from_error::~Abstract_msg_from_error() {}

    Class_msg_from_error::Class_msg_from_error() : Abstract_msg_from_error::Abstract_msg_from_error() {
      vx_core::refcount += 1;
    }

    Class_msg_from_error::~Class_msg_from_error() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_msg_from_error::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_msg_from_error output = vx_core::e_msg_from_error;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_msg_from_error::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_msg_from_error output = vx_core::e_msg_from_error;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_msg_from_error::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msg_from_error::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_msg_from_error::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_msg_from_error::vx_empty() const {return vx_core::e_msg_from_error;}
    vx_core::Type_any Class_msg_from_error::vx_type() const {return vx_core::t_msg_from_error;}
    vx_core::Type_msgblock Class_msg_from_error::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_msg_from_error::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_msg_from_error::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_msg_from_error::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_msg_from_error(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_msg_from_error::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string error = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_msg_from_error(error);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func msg<-warning)
  vx_core::Type_msg f_msg_from_warning(vx_core::Type_string warning) {
    vx_core::Type_msg output = vx_core::e_msg;
    vx_core::vx_reserve(warning);
    output = vx_core::f_new(
      vx_core::t_msg,
      vx_core::vx_new(vx_core::t_anylist, {
        vx_core::vx_new_string(":severity"),
        vx_core::c_msg_warning,
        vx_core::vx_new_string(":text"),
        warning
      })
    );
    vx_core::vx_release_one_except(warning, output);
    return output;
  }
  /**
   * @function msg_from_warning
   * Returns a msg from a warning string
   * @param  {string} warning
   * @return {msg}
   * (func msg<-warning)
   */
  // (func msg<-warning)
  // class Class_msg_from_warning {
    Abstract_msg_from_warning::~Abstract_msg_from_warning() {}

    Class_msg_from_warning::Class_msg_from_warning() : Abstract_msg_from_warning::Abstract_msg_from_warning() {
      vx_core::refcount += 1;
    }

    Class_msg_from_warning::~Class_msg_from_warning() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_msg_from_warning::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_msg_from_warning output = vx_core::e_msg_from_warning;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_msg_from_warning::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_msg_from_warning output = vx_core::e_msg_from_warning;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_msg_from_warning::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msg<-warning", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msg_from_warning::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_msg_from_warning::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "msg<-warning", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_msg_from_warning::vx_empty() const {return vx_core::e_msg_from_warning;}
    vx_core::Type_any Class_msg_from_warning::vx_type() const {return vx_core::t_msg_from_warning;}
    vx_core::Type_msgblock Class_msg_from_warning::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_msg_from_warning::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_msg_from_warning::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_msg_from_warning::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_msg_from_warning(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_msg_from_warning::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string warning = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_msg_from_warning(warning);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func msgblock<-msgblock-msg)
  vx_core::Type_msgblock f_msgblock_from_msgblock_msg(vx_core::Type_msgblock origblock, vx_core::Type_msg addmsg) {
    vx_core::Type_msgblock output = vx_core::e_msgblock;
    vx_core::vx_reserve({origblock, addmsg});
    output = vx_core::f_copy(vx_core::t_msgblock, origblock, vx_core::vx_new(vx_core::t_anylist, {
      addmsg}));
    vx_core::vx_release_one_except({origblock, addmsg}, output);
    return output;
  }
  /**
   * @function msgblock_from_msgblock_msg
   * Return a new Msgblock with the added msg
   * @param  {msgblock} origblock
   * @param  {msg} addmsg
   * @return {msgblock}
   * (func msgblock<-msgblock-msg)
   */
  // (func msgblock<-msgblock-msg)
  // class Class_msgblock_from_msgblock_msg {
    Abstract_msgblock_from_msgblock_msg::~Abstract_msgblock_from_msgblock_msg() {}

    Class_msgblock_from_msgblock_msg::Class_msgblock_from_msgblock_msg() : Abstract_msgblock_from_msgblock_msg::Abstract_msgblock_from_msgblock_msg() {
      vx_core::refcount += 1;
    }

    Class_msgblock_from_msgblock_msg::~Class_msgblock_from_msgblock_msg() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_msgblock_from_msgblock_msg::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_msgblock_from_msgblock_msg output = vx_core::e_msgblock_from_msgblock_msg;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_msgblock_from_msgblock_msg::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_msgblock_from_msgblock_msg output = vx_core::e_msgblock_from_msgblock_msg;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_msgblock_from_msgblock_msg::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msg", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msgblock_from_msgblock_msg::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_msgblock_from_msgblock_msg::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msg", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_msgblock_from_msgblock_msg::vx_empty() const {return vx_core::e_msgblock_from_msgblock_msg;}
    vx_core::Type_any Class_msgblock_from_msgblock_msg::vx_type() const {return vx_core::t_msgblock_from_msgblock_msg;}
    vx_core::Type_msgblock Class_msgblock_from_msgblock_msg::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_msgblock_from_msgblock_msg::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_msgblock_from_msgblock_msg::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_msgblock origblock = vx_core::vx_any_from_any(vx_core::t_msgblock, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_msg addmsg = vx_core::vx_any_from_any(vx_core::t_msg, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_msgblock_from_msgblock_msg(origblock, addmsg);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func msgblock<-msgblock-msgblock)
  vx_core::Type_msgblock f_msgblock_from_msgblock_msgblock(vx_core::Type_msgblock origblock, vx_core::Type_msgblock addblock) {
    vx_core::Type_msgblock output = vx_core::e_msgblock;
    vx_core::vx_reserve({origblock, addblock});
    output = vx_core::f_new(
      vx_core::t_msgblock,
      vx_core::vx_new(vx_core::t_anylist, {
        origblock,
        addblock
      })
    );
    vx_core::vx_release_one_except({origblock, addblock}, output);
    return output;
  }
  /**
   * @function msgblock_from_msgblock_msgblock
   * Return a new Msgblock with the added block
   * @param  {msgblock} origblock
   * @param  {msgblock} addblock
   * @return {msgblock}
   * (func msgblock<-msgblock-msgblock)
   */
  // (func msgblock<-msgblock-msgblock)
  // class Class_msgblock_from_msgblock_msgblock {
    Abstract_msgblock_from_msgblock_msgblock::~Abstract_msgblock_from_msgblock_msgblock() {}

    Class_msgblock_from_msgblock_msgblock::Class_msgblock_from_msgblock_msgblock() : Abstract_msgblock_from_msgblock_msgblock::Abstract_msgblock_from_msgblock_msgblock() {
      vx_core::refcount += 1;
    }

    Class_msgblock_from_msgblock_msgblock::~Class_msgblock_from_msgblock_msgblock() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_msgblock_from_msgblock_msgblock::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_msgblock_from_msgblock_msgblock output = vx_core::e_msgblock_from_msgblock_msgblock;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_msgblock_from_msgblock_msgblock::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_msgblock_from_msgblock_msgblock output = vx_core::e_msgblock_from_msgblock_msgblock;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_msgblock_from_msgblock_msgblock::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msgblock", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_msgblock_from_msgblock_msgblock::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_msgblock_from_msgblock_msgblock::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msgblock", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_msgblock_from_msgblock_msgblock::vx_empty() const {return vx_core::e_msgblock_from_msgblock_msgblock;}
    vx_core::Type_any Class_msgblock_from_msgblock_msgblock::vx_type() const {return vx_core::t_msgblock_from_msgblock_msgblock;}
    vx_core::Type_msgblock Class_msgblock_from_msgblock_msgblock::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_msgblock_from_msgblock_msgblock::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_msgblock_from_msgblock_msgblock::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_msgblock origblock = vx_core::vx_any_from_any(vx_core::t_msgblock, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_msgblock addblock = vx_core::vx_any_from_any(vx_core::t_msgblock, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_msgblock_from_msgblock_msgblock(origblock, addblock);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func name<-typedef)
  vx_core::Type_string f_name_from_typedef(vx_core::Type_typedef vtypedef) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(vtypedef);
    output = vtypedef->name();
    vx_core::vx_release_one_except(vtypedef, output);
    return output;
  }
  /**
   * @function name_from_typedef
   * Returns the name from a typedef.
   * @param  {typedef} vtypedef
   * @return {string}
   * (func name<-typedef)
   */
  // (func name<-typedef)
  // class Class_name_from_typedef {
    Abstract_name_from_typedef::~Abstract_name_from_typedef() {}

    Class_name_from_typedef::Class_name_from_typedef() : Abstract_name_from_typedef::Abstract_name_from_typedef() {
      vx_core::refcount += 1;
    }

    Class_name_from_typedef::~Class_name_from_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_name_from_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_name_from_typedef output = vx_core::e_name_from_typedef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_name_from_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_name_from_typedef output = vx_core::e_name_from_typedef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_name_from_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "name<-typedef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_name_from_typedef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_name_from_typedef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "name<-typedef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_name_from_typedef::vx_empty() const {return vx_core::e_name_from_typedef;}
    vx_core::Type_any Class_name_from_typedef::vx_type() const {return vx_core::t_name_from_typedef;}
    vx_core::Type_msgblock Class_name_from_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_name_from_typedef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_name_from_typedef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_name_from_typedef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef inputval = vx_core::vx_any_from_any(vx_core::t_typedef, val);
      output = vx_core::f_name_from_typedef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_name_from_typedef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef vtypedef = vx_core::vx_any_from_any(vx_core::t_typedef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_name_from_typedef(vtypedef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function native
   * Native Function Call
   * @param  {anylist} clauses
   * @return {any-1}
   * (func native)
   */
  // (func native)
  // class Class_native {
    Abstract_native::~Abstract_native() {}

    Class_native::Class_native() : Abstract_native::Abstract_native() {
      vx_core::refcount += 1;
    }

    Class_native::~Class_native() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_native::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_native output = vx_core::e_native;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_native::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_native output = vx_core::e_native;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_native::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "native", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_native::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_native::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "native", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_native::vx_empty() const {return vx_core::e_native;}
    vx_core::Type_any Class_native::vx_type() const {return vx_core::t_native;}
    vx_core::Type_msgblock Class_native::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_native::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_native::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_native::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_anylist inputval = vx_core::vx_any_from_any(vx_core::t_anylist, val);
      output = vx_core::f_native(vx_core::t_any, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_native::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_anylist clauses = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_native(generic_any_1, clauses);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func native<-any)
  vx_core::Type_any f_native_from_any(vx_core::Type_any value) {
    vx_core::Type_any output = vx_core::e_any;
    vx_core::vx_reserve(value);
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function native_from_any
   * Returns native value of value object
   * @param  {any-1} value
   * @return {any}
   * (func native<-any)
   */
  // (func native<-any)
  // class Class_native_from_any {
    Abstract_native_from_any::~Abstract_native_from_any() {}

    Class_native_from_any::Class_native_from_any() : Abstract_native_from_any::Abstract_native_from_any() {
      vx_core::refcount += 1;
    }

    Class_native_from_any::~Class_native_from_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_native_from_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_native_from_any output = vx_core::e_native_from_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_native_from_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_native_from_any output = vx_core::e_native_from_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_native_from_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "native<-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_native_from_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_native_from_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "native<-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_native_from_any::vx_empty() const {return vx_core::e_native_from_any;}
    vx_core::Type_any Class_native_from_any::vx_type() const {return vx_core::t_native_from_any;}
    vx_core::Type_msgblock Class_native_from_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_native_from_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_native_from_any::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_native_from_any::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_native_from_any(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_native_from_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_native_from_any(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function new_from_type
   * Create a new Value of Type A
   * @param  {any-1} type
   * @param  {anylist} values
   * @return {any-1}
   * (func new<-type)
   */
  // (func new<-type)
  // class Class_new_from_type {
    Abstract_new_from_type::~Abstract_new_from_type() {}

    Class_new_from_type::Class_new_from_type() : Abstract_new_from_type::Abstract_new_from_type() {
      vx_core::refcount += 1;
    }

    Class_new_from_type::~Class_new_from_type() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_new_from_type::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_new_from_type output = vx_core::e_new_from_type;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_new_from_type::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_new_from_type output = vx_core::e_new_from_type;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_new_from_type::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "new<-type", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_new_from_type::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_new_from_type::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "new<-type", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_new_from_type::vx_empty() const {return vx_core::e_new_from_type;}
    vx_core::Type_any Class_new_from_type::vx_type() const {return vx_core::t_new_from_type;}
    vx_core::Type_msgblock Class_new_from_type::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_new_from_type::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_new_from_type::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any type = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_anylist values = vx_core::vx_any_from_any(vx_core::t_anylist, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_new_from_type(type, values);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func number<-func)
  vx_core::Type_number f_number_from_func() {
    vx_core::Type_number output = vx_core::e_number;
    return output;
  }
  /**
   * @function number_from_func
   * Function Type returning number with any parameters
   * @return {number}
   * (func number<-func)
   */
  // (func number<-func)
  // class Class_number_from_func {
    Abstract_number_from_func::~Abstract_number_from_func() {}

    Class_number_from_func::Class_number_from_func() : Abstract_number_from_func::Abstract_number_from_func() {
      vx_core::refcount += 1;
    }

    Class_number_from_func::~Class_number_from_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_number_from_func::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_number_from_func output = vx_core::e_number_from_func;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_number_from_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_number_from_func output = vx_core::e_number_from_func;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_number_from_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "number<-func", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_number_from_func::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_number_from_func::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "number<-func", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_number_from_func::vx_empty() const {return vx_core::e_number_from_func;}
    vx_core::Type_any Class_number_from_func::vx_type() const {return vx_core::t_number_from_func;}
    vx_core::Type_msgblock Class_number_from_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_number_from_func::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_number_from_func::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      output = vx_core::f_number_from_func();
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func package-global<-name)
  vx_core::Type_package f_package_global_from_name(vx_core::Type_string name) {
    vx_core::Type_package output = vx_core::e_package;
    vx_core::vx_reserve(name);
    output = vx_core::f_any_from_map(
      vx_core::t_package,
      vx_core::f_any_from_struct(
        vx_core::t_packagemap,
        vx_core::c_global,
        vx_core::vx_new_string(":packagemap")
      ),
      name
    );
    vx_core::vx_release_one_except(name, output);
    return output;
  }
  /**
   * @function package_global_from_name
   * Returns a package from global with the given name.
   * @param  {string} name
   * @return {package}
   * (func package-global<-name)
   */
  // (func package-global<-name)
  // class Class_package_global_from_name {
    Abstract_package_global_from_name::~Abstract_package_global_from_name() {}

    Class_package_global_from_name::Class_package_global_from_name() : Abstract_package_global_from_name::Abstract_package_global_from_name() {
      vx_core::refcount += 1;
    }

    Class_package_global_from_name::~Class_package_global_from_name() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_package_global_from_name::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_package_global_from_name output = vx_core::e_package_global_from_name;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_package_global_from_name::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_package_global_from_name output = vx_core::e_package_global_from_name;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_package_global_from_name::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "package-global<-name", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_package_global_from_name::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_package_global_from_name::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "package-global<-name", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_package_global_from_name::vx_empty() const {return vx_core::e_package_global_from_name;}
    vx_core::Type_any Class_package_global_from_name::vx_type() const {return vx_core::t_package_global_from_name;}
    vx_core::Type_msgblock Class_package_global_from_name::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_package_global_from_name::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_package_global_from_name::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_package_global_from_name::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_package_global_from_name(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_package_global_from_name::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string name = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_package_global_from_name(name);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func packagename<-typedef)
  vx_core::Type_string f_packagename_from_typedef(vx_core::Type_typedef vtypedef) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(vtypedef);
    output = vtypedef->pkgname();
    vx_core::vx_release_one_except(vtypedef, output);
    return output;
  }
  /**
   * @function packagename_from_typedef
   * Returns the package name from a typedef.
   * @param  {typedef} vtypedef
   * @return {string}
   * (func packagename<-typedef)
   */
  // (func packagename<-typedef)
  // class Class_packagename_from_typedef {
    Abstract_packagename_from_typedef::~Abstract_packagename_from_typedef() {}

    Class_packagename_from_typedef::Class_packagename_from_typedef() : Abstract_packagename_from_typedef::Abstract_packagename_from_typedef() {
      vx_core::refcount += 1;
    }

    Class_packagename_from_typedef::~Class_packagename_from_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_packagename_from_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_packagename_from_typedef output = vx_core::e_packagename_from_typedef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_packagename_from_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_packagename_from_typedef output = vx_core::e_packagename_from_typedef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_packagename_from_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "packagename<-typedef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_packagename_from_typedef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_packagename_from_typedef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "packagename<-typedef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_packagename_from_typedef::vx_empty() const {return vx_core::e_packagename_from_typedef;}
    vx_core::Type_any Class_packagename_from_typedef::vx_type() const {return vx_core::t_packagename_from_typedef;}
    vx_core::Type_msgblock Class_packagename_from_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_packagename_from_typedef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_packagename_from_typedef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_packagename_from_typedef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef inputval = vx_core::vx_any_from_any(vx_core::t_typedef, val);
      output = vx_core::f_packagename_from_typedef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_packagename_from_typedef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef vtypedef = vx_core::vx_any_from_any(vx_core::t_typedef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_packagename_from_typedef(vtypedef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func path<-context-path)
  vx_core::Type_string f_path_from_context_path(vx_core::Type_context context, vx_core::Type_string path) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(path);
    output = vx_core::f_path_from_setting_path(
      vx_core::f_setting_from_context(context),
      path
    );
    vx_core::vx_release_one_except(path, output);
    return output;
  }
  /**
   * @function path_from_context_path
   * Returns a path from a context
   * @param  {string} path
   * @return {string}
   * (func path<-context-path)
   */
  // (func path<-context-path)
  // class Class_path_from_context_path {
    Abstract_path_from_context_path::~Abstract_path_from_context_path() {}

    Class_path_from_context_path::Class_path_from_context_path() : Abstract_path_from_context_path::Abstract_path_from_context_path() {
      vx_core::refcount += 1;
    }

    Class_path_from_context_path::~Class_path_from_context_path() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_path_from_context_path::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_path_from_context_path output = vx_core::e_path_from_context_path;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_path_from_context_path::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_path_from_context_path output = vx_core::e_path_from_context_path;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_path_from_context_path::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "path<-context-path", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_path_from_context_path::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_path_from_context_path::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "path<-context-path", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_path_from_context_path::vx_empty() const {return vx_core::e_path_from_context_path;}
    vx_core::Type_any Class_path_from_context_path::vx_type() const {return vx_core::t_path_from_context_path;}
    vx_core::Type_msgblock Class_path_from_context_path::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_path_from_context_path::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any_context Class_path_from_context_path::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_context::IFn fn) const {
      return vx_core::e_any_from_any_context;
    }

    vx_core::Type_any Class_path_from_context_path::vx_any_from_any_context(vx_core::Type_context context, vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_path_from_context_path(context, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_path_from_context_path::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string path = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_path_from_context_path(context, path);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func path<-setting-path)
  vx_core::Type_string f_path_from_setting_path(vx_core::Type_setting session, vx_core::Type_string path) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve({session, path});
    vx_core::vx_release_one_except({session, path}, output);
    return output;
  }
  /**
   * @function path_from_setting_path
   * Returns a path from a setting
   * @param  {setting} session
   * @param  {string} path
   * @return {string}
   * (func path<-setting-path)
   */
  // (func path<-setting-path)
  // class Class_path_from_setting_path {
    Abstract_path_from_setting_path::~Abstract_path_from_setting_path() {}

    Class_path_from_setting_path::Class_path_from_setting_path() : Abstract_path_from_setting_path::Abstract_path_from_setting_path() {
      vx_core::refcount += 1;
    }

    Class_path_from_setting_path::~Class_path_from_setting_path() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_path_from_setting_path::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_path_from_setting_path output = vx_core::e_path_from_setting_path;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_path_from_setting_path::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_path_from_setting_path output = vx_core::e_path_from_setting_path;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_path_from_setting_path::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "path<-setting-path", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_path_from_setting_path::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_path_from_setting_path::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "path<-setting-path", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_path_from_setting_path::vx_empty() const {return vx_core::e_path_from_setting_path;}
    vx_core::Type_any Class_path_from_setting_path::vx_type() const {return vx_core::t_path_from_setting_path;}
    vx_core::Type_msgblock Class_path_from_setting_path::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_path_from_setting_path::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_path_from_setting_path::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_setting session = vx_core::vx_any_from_any(vx_core::t_setting, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string path = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_path_from_setting_path(session, path);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func permission<-id-context)
  vx_core::Type_permission f_permission_from_id_context(vx_core::Type_context context, vx_core::Type_string id) {
    vx_core::Type_permission output = vx_core::e_permission;
    vx_core::vx_reserve(id);
    output = vx_core::f_let(
      vx_core::t_permission,
      vx_core::t_any_from_func->vx_fn_new({context}, [context]() {
        vx_core::Type_user user = vx_core::f_user_from_context(context);
        vx_core::vx_ref_plus(user);
        vx_core::Type_security security = user->security();
        vx_core::vx_ref_plus(security);
        vx_core::Type_permissionmap permissionmap = security->permissionmap();
        vx_core::vx_ref_plus(permissionmap);
        vx_core::Type_permission output_1 = vx_core::f_any_from_map(vx_core::t_permission, permissionmap, vx_core::vx_new_string(":id"));
        vx_core::vx_release_one_except({user, security, permissionmap}, output_1);
        return output_1;
      })
    );
    vx_core::vx_release_one_except(id, output);
    return output;
  }
  /**
   * @function permission_from_id_context
   * Return a permission from context by id
   * @param  {string} id
   * @return {permission}
   * (func permission<-id-context)
   */
  // (func permission<-id-context)
  // class Class_permission_from_id_context {
    Abstract_permission_from_id_context::~Abstract_permission_from_id_context() {}

    Class_permission_from_id_context::Class_permission_from_id_context() : Abstract_permission_from_id_context::Abstract_permission_from_id_context() {
      vx_core::refcount += 1;
    }

    Class_permission_from_id_context::~Class_permission_from_id_context() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_permission_from_id_context::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_permission_from_id_context output = vx_core::e_permission_from_id_context;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_permission_from_id_context::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_permission_from_id_context output = vx_core::e_permission_from_id_context;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_permission_from_id_context::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "permission<-id-context", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_permission_from_id_context::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_permission_from_id_context::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "permission<-id-context", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_permission_from_id_context::vx_empty() const {return vx_core::e_permission_from_id_context;}
    vx_core::Type_any Class_permission_from_id_context::vx_type() const {return vx_core::t_permission_from_id_context;}
    vx_core::Type_msgblock Class_permission_from_id_context::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_permission_from_id_context::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any_context Class_permission_from_id_context::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_context::IFn fn) const {
      return vx_core::e_any_from_any_context;
    }

    vx_core::Type_any Class_permission_from_id_context::vx_any_from_any_context(vx_core::Type_context context, vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string inputval = vx_core::vx_any_from_any(vx_core::t_string, val);
      output = vx_core::f_permission_from_id_context(context, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_permission_from_id_context::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string id = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_permission_from_id_context(context, id);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func properties<-typedef)
  vx_core::Type_argmap f_properties_from_typedef(vx_core::Type_typedef vtypedef) {
    vx_core::Type_argmap output = vx_core::e_argmap;
    vx_core::vx_reserve(vtypedef);
    output = vtypedef->properties();
    vx_core::vx_release_one_except(vtypedef, output);
    return output;
  }
  /**
   * @function properties_from_typedef
   * Return property map from typedef
   * @param  {typedef} vtypedef
   * @return {argmap}
   * (func properties<-typedef)
   */
  // (func properties<-typedef)
  // class Class_properties_from_typedef {
    Abstract_properties_from_typedef::~Abstract_properties_from_typedef() {}

    Class_properties_from_typedef::Class_properties_from_typedef() : Abstract_properties_from_typedef::Abstract_properties_from_typedef() {
      vx_core::refcount += 1;
    }

    Class_properties_from_typedef::~Class_properties_from_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_properties_from_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_properties_from_typedef output = vx_core::e_properties_from_typedef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_properties_from_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_properties_from_typedef output = vx_core::e_properties_from_typedef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_properties_from_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "properties<-typedef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_properties_from_typedef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_properties_from_typedef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "properties<-typedef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_properties_from_typedef::vx_empty() const {return vx_core::e_properties_from_typedef;}
    vx_core::Type_any Class_properties_from_typedef::vx_type() const {return vx_core::t_properties_from_typedef;}
    vx_core::Type_msgblock Class_properties_from_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_properties_from_typedef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_properties_from_typedef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_properties_from_typedef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef inputval = vx_core::vx_any_from_any(vx_core::t_typedef, val);
      output = vx_core::f_properties_from_typedef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_properties_from_typedef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef vtypedef = vx_core::vx_any_from_any(vx_core::t_typedef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_properties_from_typedef(vtypedef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func proplast<-typedef)
  vx_core::Type_arg f_proplast_from_typedef(vx_core::Type_typedef vtypedef) {
    vx_core::Type_arg output = vx_core::e_arg;
    vx_core::vx_reserve(vtypedef);
    output = vtypedef->proplast();
    vx_core::vx_release_one_except(vtypedef, output);
    return output;
  }
  /**
   * @function proplast_from_typedef
   * Return last property from typedef
   * @param  {typedef} vtypedef
   * @return {arg}
   * (func proplast<-typedef)
   */
  // (func proplast<-typedef)
  // class Class_proplast_from_typedef {
    Abstract_proplast_from_typedef::~Abstract_proplast_from_typedef() {}

    Class_proplast_from_typedef::Class_proplast_from_typedef() : Abstract_proplast_from_typedef::Abstract_proplast_from_typedef() {
      vx_core::refcount += 1;
    }

    Class_proplast_from_typedef::~Class_proplast_from_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_proplast_from_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_proplast_from_typedef output = vx_core::e_proplast_from_typedef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_proplast_from_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_proplast_from_typedef output = vx_core::e_proplast_from_typedef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_proplast_from_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "proplast<-typedef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_proplast_from_typedef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_proplast_from_typedef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "proplast<-typedef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_proplast_from_typedef::vx_empty() const {return vx_core::e_proplast_from_typedef;}
    vx_core::Type_any Class_proplast_from_typedef::vx_type() const {return vx_core::t_proplast_from_typedef;}
    vx_core::Type_msgblock Class_proplast_from_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_proplast_from_typedef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_proplast_from_typedef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_proplast_from_typedef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef inputval = vx_core::vx_any_from_any(vx_core::t_typedef, val);
      output = vx_core::f_proplast_from_typedef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_proplast_from_typedef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef vtypedef = vx_core::vx_any_from_any(vx_core::t_typedef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_proplast_from_typedef(vtypedef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function resolve 1
   * @param  {any<-func} fn-any
   * @return {any-1}
   * (func resolve)
   */
  // (func resolve)
  // class Class_resolve_1 {
    Abstract_resolve_1::~Abstract_resolve_1() {}

    Class_resolve_1::Class_resolve_1() : Abstract_resolve_1::Abstract_resolve_1() {
      vx_core::refcount += 1;
    }

    Class_resolve_1::~Class_resolve_1() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_resolve_1::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve_1 output = vx_core::e_resolve_1;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_resolve_1::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve_1 output = vx_core::e_resolve_1;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_resolve_1::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "resolve", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_resolve_1::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_resolve_1::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        1, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_resolve_1::vx_empty() const {return vx_core::e_resolve_1;}
    vx_core::Type_any Class_resolve_1::vx_type() const {return vx_core::t_resolve_1;}
    vx_core::Type_msgblock Class_resolve_1::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_resolve_1::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_resolve_1::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_resolve_1::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Func_any_from_func inputval = vx_core::vx_any_from_any(vx_core::t_any_from_func, val);
      output = vx_core::f_resolve_1(vx_core::t_any, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_resolve_1::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_func fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_resolve_1(generic_any_1, fn_any);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function resolve
   * @param  {any-1} value
   * @return {any-1}
   * (func resolve)
   */
  // (func resolve)
  // class Class_resolve {
    Abstract_resolve::~Abstract_resolve() {}

    Class_resolve::Class_resolve() : Abstract_resolve::Abstract_resolve() {
      vx_core::refcount += 1;
    }

    Class_resolve::~Class_resolve() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_resolve::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve output = vx_core::e_resolve;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_resolve::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve output = vx_core::e_resolve;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_resolve::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "resolve", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_resolve::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_resolve::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_resolve::vx_empty() const {return vx_core::e_resolve;}
    vx_core::Type_any Class_resolve::vx_type() const {return vx_core::t_resolve;}
    vx_core::Type_msgblock Class_resolve::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_resolve::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_resolve::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_resolve::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_resolve(vx_core::t_any, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_resolve::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_resolve(generic_any_1, value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * 
   * @async
   * @function resolve_async
   * @param  {any<-func-async} fn-any
   * @return {any-1}
   * (func resolve-async)
   */
  // (func resolve-async)
  // class Class_resolve_async {
    Abstract_resolve_async::~Abstract_resolve_async() {}

    Class_resolve_async::Class_resolve_async() : Abstract_resolve_async::Abstract_resolve_async() {
      vx_core::refcount += 1;
    }

    Class_resolve_async::~Class_resolve_async() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_resolve_async::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve_async output = vx_core::e_resolve_async;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_resolve_async::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve_async output = vx_core::e_resolve_async;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_resolve_async::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "resolve-async", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_resolve_async::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_resolve_async::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "resolve-async", // name
        0, // idx
        true, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_resolve_async::vx_empty() const {return vx_core::e_resolve_async;}
    vx_core::Type_any Class_resolve_async::vx_type() const {return vx_core::t_resolve_async;}
    vx_core::Type_msgblock Class_resolve_async::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_resolve_async::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any_async Class_resolve_async::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any_async::IFn fn) const {
      return vx_core::e_any_from_any_async;
    }

    vx_core::vx_Type_async Class_resolve_async::vx_any_from_any_async(vx_core::Type_any generic_any_1, vx_core::Type_any val) const {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(val);
      vx_core::vx_release(val);
      return output;
    }

    vx_core::vx_Type_async Class_resolve_async::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::vx_Type_async output = vx_core::vx_async_new_from_value(vx_core::e_any);
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Func_any_from_func_async fn_any = vx_core::vx_any_from_any(vx_core::t_any_from_func_async, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_resolve_async(generic_any_1, fn_any);
      vx_core::vx_release(arglist);
      return output;
    }

  //}
  /**
   * @function resolve_first
   * Returns the first value that is not nothing
   * @param  {list-1} clauses
   * @return {any-1}
   * (func resolve-first)
   */
  // (func resolve-first)
  // class Class_resolve_first {
    Abstract_resolve_first::~Abstract_resolve_first() {}

    Class_resolve_first::Class_resolve_first() : Abstract_resolve_first::Abstract_resolve_first() {
      vx_core::refcount += 1;
    }

    Class_resolve_first::~Class_resolve_first() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_resolve_first::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve_first output = vx_core::e_resolve_first;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_resolve_first::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve_first output = vx_core::e_resolve_first;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_resolve_first::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "resolve-first", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_resolve_first::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_resolve_first::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "resolve-first", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_resolve_first::vx_empty() const {return vx_core::e_resolve_first;}
    vx_core::Type_any Class_resolve_first::vx_type() const {return vx_core::t_resolve_first;}
    vx_core::Type_msgblock Class_resolve_first::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_resolve_first::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_resolve_first::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_resolve_first::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list inputval = vx_core::vx_any_from_any(vx_core::t_list, val);
      output = vx_core::f_resolve_first(vx_core::t_any, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_resolve_first::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any generic_any_1 = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list clauses = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_resolve_first(generic_any_1, clauses);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}
  /**
   * @function resolve_list
   * @param  {list-1} clauses
   * @return {list-1}
   * (func resolve-list)
   */
  // (func resolve-list)
  // class Class_resolve_list {
    Abstract_resolve_list::~Abstract_resolve_list() {}

    Class_resolve_list::Class_resolve_list() : Abstract_resolve_list::Abstract_resolve_list() {
      vx_core::refcount += 1;
    }

    Class_resolve_list::~Class_resolve_list() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_resolve_list::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve_list output = vx_core::e_resolve_list;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_resolve_list::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_resolve_list output = vx_core::e_resolve_list;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_resolve_list::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "resolve-list", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_resolve_list::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_resolve_list::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "resolve-list", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_resolve_list::vx_empty() const {return vx_core::e_resolve_list;}
    vx_core::Type_any Class_resolve_list::vx_type() const {return vx_core::t_resolve_list;}
    vx_core::Type_msgblock Class_resolve_list::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_resolve_list::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_resolve_list::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_resolve_list::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list inputval = vx_core::vx_any_from_any(vx_core::t_list, val);
      output = vx_core::f_resolve_list(vx_core::t_list, inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_resolve_list::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_list generic_list_1 = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_list clauses = vx_core::vx_any_from_any(vx_core::t_list, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_resolve_list(generic_list_1, clauses);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func security<-context)
  vx_core::Type_security f_security_from_context(vx_core::Type_context context) {
    vx_core::Type_security output = vx_core::e_security;
    output = vx_core::f_security_from_user(
      vx_core::f_user_from_context(context)
    );
    return output;
  }
  /**
   * @function security_from_context
   * Return security from the given context.
   * @return {security}
   * (func security<-context)
   */
  // (func security<-context)
  // class Class_security_from_context {
    Abstract_security_from_context::~Abstract_security_from_context() {}

    Class_security_from_context::Class_security_from_context() : Abstract_security_from_context::Abstract_security_from_context() {
      vx_core::refcount += 1;
    }

    Class_security_from_context::~Class_security_from_context() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_security_from_context::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_security_from_context output = vx_core::e_security_from_context;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_security_from_context::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_security_from_context output = vx_core::e_security_from_context;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_security_from_context::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "security<-context", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_security_from_context::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_security_from_context::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "security<-context", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_security_from_context::vx_empty() const {return vx_core::e_security_from_context;}
    vx_core::Type_any Class_security_from_context::vx_type() const {return vx_core::t_security_from_context;}
    vx_core::Type_msgblock Class_security_from_context::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_security_from_context::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_security_from_context::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_security_from_context(context);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func security<-user)
  vx_core::Type_security f_security_from_user(vx_core::Type_user user) {
    vx_core::Type_security output = vx_core::e_security;
    vx_core::vx_reserve(user);
    output = user->security();
    vx_core::vx_release_one_except(user, output);
    return output;
  }
  /**
   * @function security_from_user
   * Return security from the given user.
   * @param  {user} user
   * @return {security}
   * (func security<-user)
   */
  // (func security<-user)
  // class Class_security_from_user {
    Abstract_security_from_user::~Abstract_security_from_user() {}

    Class_security_from_user::Class_security_from_user() : Abstract_security_from_user::Abstract_security_from_user() {
      vx_core::refcount += 1;
    }

    Class_security_from_user::~Class_security_from_user() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_security_from_user::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_security_from_user output = vx_core::e_security_from_user;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_security_from_user::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_security_from_user output = vx_core::e_security_from_user;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_security_from_user::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "security<-user", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_security_from_user::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_security_from_user::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "security<-user", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_security_from_user::vx_empty() const {return vx_core::e_security_from_user;}
    vx_core::Type_any Class_security_from_user::vx_type() const {return vx_core::t_security_from_user;}
    vx_core::Type_msgblock Class_security_from_user::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_security_from_user::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_security_from_user::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_security_from_user::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_user inputval = vx_core::vx_any_from_any(vx_core::t_user, val);
      output = vx_core::f_security_from_user(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_security_from_user::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_user user = vx_core::vx_any_from_any(vx_core::t_user, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_security_from_user(user);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func session<-context)
  vx_core::Type_session f_session_from_context(vx_core::Type_context context) {
    vx_core::Type_session output = vx_core::e_session;
    output = context->session();
    return output;
  }
  /**
   * @function session_from_context
   * Returns session from a context
   * @return {session}
   * (func session<-context)
   */
  // (func session<-context)
  // class Class_session_from_context {
    Abstract_session_from_context::~Abstract_session_from_context() {}

    Class_session_from_context::Class_session_from_context() : Abstract_session_from_context::Abstract_session_from_context() {
      vx_core::refcount += 1;
    }

    Class_session_from_context::~Class_session_from_context() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_session_from_context::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_session_from_context output = vx_core::e_session_from_context;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_session_from_context::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_session_from_context output = vx_core::e_session_from_context;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_session_from_context::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "session<-context", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_session_from_context::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_session_from_context::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "session<-context", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_session_from_context::vx_empty() const {return vx_core::e_session_from_context;}
    vx_core::Type_any Class_session_from_context::vx_type() const {return vx_core::t_session_from_context;}
    vx_core::Type_msgblock Class_session_from_context::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_session_from_context::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_session_from_context::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_session_from_context(context);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func setting<-context)
  vx_core::Type_setting f_setting_from_context(vx_core::Type_context context) {
    vx_core::Type_setting output = vx_core::e_setting;
    output = context->setting();
    return output;
  }
  /**
   * @function setting_from_context
   * Returns setting from a context
   * @return {setting}
   * (func setting<-context)
   */
  // (func setting<-context)
  // class Class_setting_from_context {
    Abstract_setting_from_context::~Abstract_setting_from_context() {}

    Class_setting_from_context::Class_setting_from_context() : Abstract_setting_from_context::Abstract_setting_from_context() {
      vx_core::refcount += 1;
    }

    Class_setting_from_context::~Class_setting_from_context() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_setting_from_context::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_setting_from_context output = vx_core::e_setting_from_context;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_setting_from_context::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_setting_from_context output = vx_core::e_setting_from_context;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_setting_from_context::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "setting<-context", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_setting_from_context::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_setting_from_context::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "setting<-context", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_setting_from_context::vx_empty() const {return vx_core::e_setting_from_context;}
    vx_core::Type_any Class_setting_from_context::vx_type() const {return vx_core::t_setting_from_context;}
    vx_core::Type_msgblock Class_setting_from_context::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_setting_from_context::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_setting_from_context::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_setting_from_context(context);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func string-repeat)
  vx_core::Type_string f_string_repeat(vx_core::Type_string text, vx_core::Type_int repeat) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve({text, repeat});
    std::string stringtext = vx_core::vx_string_from_string_repeat(text->vx_string(), repeat->vx_int());
    output = vx_core::vx_new_string(stringtext);
    vx_core::vx_release_one_except({text, repeat}, output);
    return output;
  }
  /**
   * @function string_repeat
   * @param  {string} text
   * @param  {int} repeat
   * @return {string}
   * (func string-repeat)
   */
  // (func string-repeat)
  // class Class_string_repeat {
    Abstract_string_repeat::~Abstract_string_repeat() {}

    Class_string_repeat::Class_string_repeat() : Abstract_string_repeat::Abstract_string_repeat() {
      vx_core::refcount += 1;
    }

    Class_string_repeat::~Class_string_repeat() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_string_repeat::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_repeat output = vx_core::e_string_repeat;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_string_repeat::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_repeat output = vx_core::e_string_repeat;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_string_repeat::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "string-repeat", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_string_repeat::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_string_repeat::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "string-repeat", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_string_repeat::vx_empty() const {return vx_core::e_string_repeat;}
    vx_core::Type_any Class_string_repeat::vx_type() const {return vx_core::t_string_repeat;}
    vx_core::Type_msgblock Class_string_repeat::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_string_repeat::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_string_repeat::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string text = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_int repeat = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(1)));
      output = vx_core::f_string_repeat(text, repeat);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func string<-any)
  vx_core::Type_string f_string_from_any(vx_core::Type_any value) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(value);
    output = vx_core::f_string_from_any_indent(
      value,
      vx_core::vx_new_int(0),
      vx_core::vx_new_boolean(true)
    );
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function string_from_any
   * Return a string representation of a value
   * @param  {any} value
   * @return {string}
   * (func string<-any)
   */
  // (func string<-any)
  // class Class_string_from_any {
    Abstract_string_from_any::~Abstract_string_from_any() {}

    Class_string_from_any::Class_string_from_any() : Abstract_string_from_any::Abstract_string_from_any() {
      vx_core::refcount += 1;
    }

    Class_string_from_any::~Class_string_from_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_string_from_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_from_any output = vx_core::e_string_from_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_string_from_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_from_any output = vx_core::e_string_from_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_string_from_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "string<-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_string_from_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_string_from_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "string<-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_string_from_any::vx_empty() const {return vx_core::e_string_from_any;}
    vx_core::Type_any Class_string_from_any::vx_type() const {return vx_core::t_string_from_any;}
    vx_core::Type_msgblock Class_string_from_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_string_from_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_string_from_any::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_string_from_any::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_string_from_any(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_string_from_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_string_from_any(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func string<-any-indent)
  vx_core::Type_string f_string_from_any_indent(vx_core::Type_any value, vx_core::Type_int indent, vx_core::Type_boolean linefeed) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve({value, indent, linefeed});
    std::string soutput = vx_core::vx_string_from_any_indent(value, indent->vx_int(), linefeed->vx_boolean(), false);
    output = vx_core::vx_new_string(soutput);
    vx_core::vx_release_one_except({value, indent, linefeed}, output);
    return output;
  }
  /**
   * @function string_from_any_indent
   * Return a string representation of a value
   * @param  {any} value
   * @param  {int} indent
   * @param  {boolean} linefeed
   * @return {string}
   * (func string<-any-indent)
   */
  // (func string<-any-indent)
  // class Class_string_from_any_indent {
    Abstract_string_from_any_indent::~Abstract_string_from_any_indent() {}

    Class_string_from_any_indent::Class_string_from_any_indent() : Abstract_string_from_any_indent::Abstract_string_from_any_indent() {
      vx_core::refcount += 1;
    }

    Class_string_from_any_indent::~Class_string_from_any_indent() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_string_from_any_indent::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_from_any_indent output = vx_core::e_string_from_any_indent;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_string_from_any_indent::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_from_any_indent output = vx_core::e_string_from_any_indent;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_string_from_any_indent::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "string<-any-indent", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_string_from_any_indent::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_string_from_any_indent::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "string<-any-indent", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_string_from_any_indent::vx_empty() const {return vx_core::e_string_from_any_indent;}
    vx_core::Type_any Class_string_from_any_indent::vx_type() const {return vx_core::t_string_from_any_indent;}
    vx_core::Type_msgblock Class_string_from_any_indent::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_string_from_any_indent::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_string_from_any_indent::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_int indent = vx_core::vx_any_from_any(vx_core::t_int, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Type_boolean linefeed = vx_core::vx_any_from_any(vx_core::t_boolean, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_string_from_any_indent(value, indent, linefeed);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func string<-func)
  vx_core::Type_string f_string_from_func() {
    vx_core::Type_string output = vx_core::e_string;
    return output;
  }
  /**
   * @function string_from_func
   * Function Type returning string with any parameters
   * @return {string}
   * (func string<-func)
   */
  // (func string<-func)
  // class Class_string_from_func {
    Abstract_string_from_func::~Abstract_string_from_func() {}

    Class_string_from_func::Class_string_from_func() : Abstract_string_from_func::Abstract_string_from_func() {
      vx_core::refcount += 1;
    }

    Class_string_from_func::~Class_string_from_func() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
      vx_core::vx_release_one(this->lambdavars);
    }

    vx_core::Type_any Class_string_from_func::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_from_func output = vx_core::e_string_from_func;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_string_from_func::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_from_func output = vx_core::e_string_from_func;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_string_from_func::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "string<-func", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_string_from_func::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_string_from_func::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "string<-func", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_string_from_func::vx_empty() const {return vx_core::e_string_from_func;}
    vx_core::Type_any Class_string_from_func::vx_type() const {return vx_core::t_string_from_func;}
    vx_core::Type_msgblock Class_string_from_func::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_string_from_func::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_string_from_func vx_core::Class_string_from_func::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_string_from_func::IFn fn) const {
      vx_core::Func_string_from_func output = new vx_core::Class_string_from_func();
      output->fn = fn;
      output->lambdavars = lambdavars;
      vx_core::vx_reserve(lambdavars);
      return output;
    }

    vx_core::Type_string Class_string_from_func::vx_string_from_func() const {
      vx_core::Type_string output = vx_core::e_string;
      if (fn) {
        output = fn();
      }
      return output;
    }

    vx_core::Type_any Class_string_from_func::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      output = vx_core::f_string_from_func();
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func string<-string-find-replace)
  vx_core::Type_string f_string_from_string_find_replace(vx_core::Type_string text, vx_core::Type_string find, vx_core::Type_string replace) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve({text, find, replace});
    output = vx_core::vx_string_from_string_find_replace(text, find, replace);
    vx_core::vx_release_one_except({text, find, replace}, output);
    return output;
  }
  /**
   * @function string_from_string_find_replace
   * Returns a string with all instances of find replaced by replace.
   * @param  {string} text
   * @param  {string} find
   * @param  {string} replace
   * @return {string}
   * (func string<-string-find-replace)
   */
  // (func string<-string-find-replace)
  // class Class_string_from_string_find_replace {
    Abstract_string_from_string_find_replace::~Abstract_string_from_string_find_replace() {}

    Class_string_from_string_find_replace::Class_string_from_string_find_replace() : Abstract_string_from_string_find_replace::Abstract_string_from_string_find_replace() {
      vx_core::refcount += 1;
    }

    Class_string_from_string_find_replace::~Class_string_from_string_find_replace() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_string_from_string_find_replace::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_from_string_find_replace output = vx_core::e_string_from_string_find_replace;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_string_from_string_find_replace::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_string_from_string_find_replace output = vx_core::e_string_from_string_find_replace;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_string_from_string_find_replace::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "string<-string-find-replace", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_string_from_string_find_replace::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_string_from_string_find_replace::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "string<-string-find-replace", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_string_from_string_find_replace::vx_empty() const {return vx_core::e_string_from_string_find_replace;}
    vx_core::Type_any Class_string_from_string_find_replace::vx_type() const {return vx_core::t_string_from_string_find_replace;}
    vx_core::Type_msgblock Class_string_from_string_find_replace::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_string_from_string_find_replace::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_string_from_string_find_replace::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_string text = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(0)));
      vx_core::Type_string find = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(1)));
      vx_core::Type_string replace = vx_core::vx_any_from_any(vx_core::t_string, arglist->vx_get_any(vx_core::vx_new_int(2)));
      output = vx_core::f_string_from_string_find_replace(text, find, replace);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func stringlist<-map)
  vx_core::Type_stringlist f_stringlist_from_map(vx_core::Type_map map) {
    vx_core::Type_stringlist output = vx_core::e_stringlist;
    vx_core::vx_reserve(map);
    output = vx_core::f_list_from_map_1(
      vx_core::t_stringlist,
      map,
      vx_core::t_any_from_key_value->vx_fn_new({}, [](vx_core::Type_any key_any, vx_core::Type_any value) {
        vx_core::Type_string key = vx_core::vx_any_from_any(vx_core::t_string, key_any);
        vx_core::Type_any output_1 = key;
        return output_1;
      })
    );
    vx_core::vx_release_one_except(map, output);
    return output;
  }
  /**
   * @function stringlist_from_map
   * Returns a stringlist of keys from any map in entry order.
   * @param  {map-1} map
   * @return {stringlist}
   * (func stringlist<-map)
   */
  // (func stringlist<-map)
  // class Class_stringlist_from_map {
    Abstract_stringlist_from_map::~Abstract_stringlist_from_map() {}

    Class_stringlist_from_map::Class_stringlist_from_map() : Abstract_stringlist_from_map::Abstract_stringlist_from_map() {
      vx_core::refcount += 1;
    }

    Class_stringlist_from_map::~Class_stringlist_from_map() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_stringlist_from_map::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_stringlist_from_map output = vx_core::e_stringlist_from_map;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_stringlist_from_map::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_stringlist_from_map output = vx_core::e_stringlist_from_map;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_stringlist_from_map::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "stringlist<-map", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_stringlist_from_map::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_stringlist_from_map::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "stringlist<-map", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_stringlist_from_map::vx_empty() const {return vx_core::e_stringlist_from_map;}
    vx_core::Type_any Class_stringlist_from_map::vx_type() const {return vx_core::t_stringlist_from_map;}
    vx_core::Type_msgblock Class_stringlist_from_map::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_stringlist_from_map::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_stringlist_from_map::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_stringlist_from_map::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map inputval = vx_core::vx_any_from_any(vx_core::t_map, val);
      output = vx_core::f_stringlist_from_map(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_stringlist_from_map::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_map map = vx_core::vx_any_from_any(vx_core::t_map, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_stringlist_from_map(map);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func traits<-typedef)
  vx_core::Type_typelist f_traits_from_typedef(vx_core::Type_typedef vtypedef) {
    vx_core::Type_typelist output = vx_core::e_typelist;
    vx_core::vx_reserve(vtypedef);
    output = vtypedef->traits();
    vx_core::vx_release_one_except(vtypedef, output);
    return output;
  }
  /**
   * @function traits_from_typedef
   * Get the traits of a given typedef
   * @param  {typedef} vtypedef
   * @return {typelist}
   * (func traits<-typedef)
   */
  // (func traits<-typedef)
  // class Class_traits_from_typedef {
    Abstract_traits_from_typedef::~Abstract_traits_from_typedef() {}

    Class_traits_from_typedef::Class_traits_from_typedef() : Abstract_traits_from_typedef::Abstract_traits_from_typedef() {
      vx_core::refcount += 1;
    }

    Class_traits_from_typedef::~Class_traits_from_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_traits_from_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_traits_from_typedef output = vx_core::e_traits_from_typedef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_traits_from_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_traits_from_typedef output = vx_core::e_traits_from_typedef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_traits_from_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "traits<-typedef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_traits_from_typedef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_traits_from_typedef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "traits<-typedef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_traits_from_typedef::vx_empty() const {return vx_core::e_traits_from_typedef;}
    vx_core::Type_any Class_traits_from_typedef::vx_type() const {return vx_core::t_traits_from_typedef;}
    vx_core::Type_msgblock Class_traits_from_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_traits_from_typedef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_traits_from_typedef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_traits_from_typedef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef inputval = vx_core::vx_any_from_any(vx_core::t_typedef, val);
      output = vx_core::f_traits_from_typedef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_traits_from_typedef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef vtypedef = vx_core::vx_any_from_any(vx_core::t_typedef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_traits_from_typedef(vtypedef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func type<-any)
  vx_core::Type_any f_type_from_any(vx_core::Type_any value) {
    vx_core::Type_any output = vx_core::e_any;
    vx_core::vx_reserve(value);
    output = value->vx_type();
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function type_from_any
   * Gets the Type of a given Value
   * @param  {any-1} value
   * @return {any}
   * (func type<-any)
   */
  // (func type<-any)
  // class Class_type_from_any {
    Abstract_type_from_any::~Abstract_type_from_any() {}

    Class_type_from_any::Class_type_from_any() : Abstract_type_from_any::Abstract_type_from_any() {
      vx_core::refcount += 1;
    }

    Class_type_from_any::~Class_type_from_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_type_from_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_type_from_any output = vx_core::e_type_from_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_type_from_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_type_from_any output = vx_core::e_type_from_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_type_from_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "type<-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_type_from_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_type_from_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "type<-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_type_from_any::vx_empty() const {return vx_core::e_type_from_any;}
    vx_core::Type_any Class_type_from_any::vx_type() const {return vx_core::t_type_from_any;}
    vx_core::Type_msgblock Class_type_from_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_type_from_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_type_from_any::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_type_from_any::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_type_from_any(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_type_from_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_type_from_any(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func typedef<-any)
  vx_core::Type_typedef f_typedef_from_any(vx_core::Type_any value) {
    vx_core::Type_typedef output = vx_core::e_typedef;
    vx_core::vx_reserve(value);
    output = vx_core::f_typedef_from_type(
      vx_core::f_type_from_any(value)
    );
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function typedef_from_any
   * Gets the typedef of a given value
   * @param  {any} value
   * @return {typedef}
   * (func typedef<-any)
   */
  // (func typedef<-any)
  // class Class_typedef_from_any {
    Abstract_typedef_from_any::~Abstract_typedef_from_any() {}

    Class_typedef_from_any::Class_typedef_from_any() : Abstract_typedef_from_any::Abstract_typedef_from_any() {
      vx_core::refcount += 1;
    }

    Class_typedef_from_any::~Class_typedef_from_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_typedef_from_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_typedef_from_any output = vx_core::e_typedef_from_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_typedef_from_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_typedef_from_any output = vx_core::e_typedef_from_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_typedef_from_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "typedef<-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_typedef_from_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_typedef_from_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "typedef<-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_typedef_from_any::vx_empty() const {return vx_core::e_typedef_from_any;}
    vx_core::Type_any Class_typedef_from_any::vx_type() const {return vx_core::t_typedef_from_any;}
    vx_core::Type_msgblock Class_typedef_from_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_typedef_from_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_typedef_from_any::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_typedef_from_any::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_typedef_from_any(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_typedef_from_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_typedef_from_any(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func typedef<-type)
  vx_core::Type_typedef f_typedef_from_type(vx_core::Type_any value) {
    vx_core::Type_typedef output = vx_core::e_typedef;
    vx_core::vx_reserve(value);
    output = value->vx_typedef();
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function typedef_from_type
   * Gets the typedef of a given type
   * @param  {any} value
   * @return {typedef}
   * (func typedef<-type)
   */
  // (func typedef<-type)
  // class Class_typedef_from_type {
    Abstract_typedef_from_type::~Abstract_typedef_from_type() {}

    Class_typedef_from_type::Class_typedef_from_type() : Abstract_typedef_from_type::Abstract_typedef_from_type() {
      vx_core::refcount += 1;
    }

    Class_typedef_from_type::~Class_typedef_from_type() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_typedef_from_type::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_typedef_from_type output = vx_core::e_typedef_from_type;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_typedef_from_type::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_typedef_from_type output = vx_core::e_typedef_from_type;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_typedef_from_type::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "typedef<-type", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_typedef_from_type::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_typedef_from_type::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "typedef<-type", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_typedef_from_type::vx_empty() const {return vx_core::e_typedef_from_type;}
    vx_core::Type_any Class_typedef_from_type::vx_type() const {return vx_core::t_typedef_from_type;}
    vx_core::Type_msgblock Class_typedef_from_type::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_typedef_from_type::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_typedef_from_type::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_typedef_from_type::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_typedef_from_type(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_typedef_from_type::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_typedef_from_type(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func typename<-any)
  vx_core::Type_string f_typename_from_any(vx_core::Type_any value) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(value);
    output = vx_core::f_typename_from_type(
      vx_core::f_type_from_any(value)
    );
    vx_core::vx_release_one_except(value, output);
    return output;
  }
  /**
   * @function typename_from_any
   * Gets the typename of a given value
   * @param  {any-2} value
   * @return {string}
   * (func typename<-any)
   */
  // (func typename<-any)
  // class Class_typename_from_any {
    Abstract_typename_from_any::~Abstract_typename_from_any() {}

    Class_typename_from_any::Class_typename_from_any() : Abstract_typename_from_any::Abstract_typename_from_any() {
      vx_core::refcount += 1;
    }

    Class_typename_from_any::~Class_typename_from_any() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_typename_from_any::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_typename_from_any output = vx_core::e_typename_from_any;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_typename_from_any::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_typename_from_any output = vx_core::e_typename_from_any;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_typename_from_any::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "typename<-any", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_typename_from_any::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_typename_from_any::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "typename<-any", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_typename_from_any::vx_empty() const {return vx_core::e_typename_from_any;}
    vx_core::Type_any Class_typename_from_any::vx_type() const {return vx_core::t_typename_from_any;}
    vx_core::Type_msgblock Class_typename_from_any::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_typename_from_any::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_typename_from_any::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_typename_from_any::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_typename_from_any(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_typename_from_any::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any value = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_typename_from_any(value);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func typename<-type)
  vx_core::Type_string f_typename_from_type(vx_core::Type_any type) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(type);
    output = vx_core::f_typename_from_typedef(
      vx_core::f_typedef_from_type(type)
    );
    vx_core::vx_release_one_except(type, output);
    return output;
  }
  /**
   * @function typename_from_type
   * Get the name of a given type
   * @param  {any} type
   * @return {string}
   * (func typename<-type)
   */
  // (func typename<-type)
  // class Class_typename_from_type {
    Abstract_typename_from_type::~Abstract_typename_from_type() {}

    Class_typename_from_type::Class_typename_from_type() : Abstract_typename_from_type::Abstract_typename_from_type() {
      vx_core::refcount += 1;
    }

    Class_typename_from_type::~Class_typename_from_type() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_typename_from_type::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_typename_from_type output = vx_core::e_typename_from_type;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_typename_from_type::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_typename_from_type output = vx_core::e_typename_from_type;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_typename_from_type::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "typename<-type", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_typename_from_type::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_typename_from_type::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "typename<-type", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_typename_from_type::vx_empty() const {return vx_core::e_typename_from_type;}
    vx_core::Type_any Class_typename_from_type::vx_type() const {return vx_core::t_typename_from_type;}
    vx_core::Type_msgblock Class_typename_from_type::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_typename_from_type::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_typename_from_type::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_typename_from_type::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any inputval = vx_core::vx_any_from_any(vx_core::t_any, val);
      output = vx_core::f_typename_from_type(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_typename_from_type::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_any type = vx_core::vx_any_from_any(vx_core::t_any, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_typename_from_type(type);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func typename<-typedef)
  vx_core::Type_string f_typename_from_typedef(vx_core::Type_typedef vtypedef) {
    vx_core::Type_string output = vx_core::e_string;
    vx_core::vx_reserve(vtypedef);
    output = vx_core::f_new(
      vx_core::t_string,
      vx_core::vx_new(vx_core::t_anylist, {
        vtypedef->pkgname(),
        vx_core::vx_new_string("/"),
        vtypedef->name()
      })
    );
    vx_core::vx_release_one_except(vtypedef, output);
    return output;
  }
  /**
   * @function typename_from_typedef
   * Get the name of a given type
   * @param  {typedef} vtypedef
   * @return {string}
   * (func typename<-typedef)
   */
  // (func typename<-typedef)
  // class Class_typename_from_typedef {
    Abstract_typename_from_typedef::~Abstract_typename_from_typedef() {}

    Class_typename_from_typedef::Class_typename_from_typedef() : Abstract_typename_from_typedef::Abstract_typename_from_typedef() {
      vx_core::refcount += 1;
    }

    Class_typename_from_typedef::~Class_typename_from_typedef() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_typename_from_typedef::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_typename_from_typedef output = vx_core::e_typename_from_typedef;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_typename_from_typedef::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_typename_from_typedef output = vx_core::e_typename_from_typedef;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_typename_from_typedef::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "typename<-typedef", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_typename_from_typedef::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_typename_from_typedef::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "typename<-typedef", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_typename_from_typedef::vx_empty() const {return vx_core::e_typename_from_typedef;}
    vx_core::Type_any Class_typename_from_typedef::vx_type() const {return vx_core::t_typename_from_typedef;}
    vx_core::Type_msgblock Class_typename_from_typedef::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_typename_from_typedef::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_typename_from_typedef::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_typename_from_typedef::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef inputval = vx_core::vx_any_from_any(vx_core::t_typedef, val);
      output = vx_core::f_typename_from_typedef(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_typename_from_typedef::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typedef vtypedef = vx_core::vx_any_from_any(vx_core::t_typedef, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_typename_from_typedef(vtypedef);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func typenames<-typelist)
  vx_core::Type_stringlist f_typenames_from_typelist(vx_core::Type_typelist typelist) {
    vx_core::Type_stringlist output = vx_core::e_stringlist;
    vx_core::vx_reserve(typelist);
    output = vx_core::f_list_from_list_1(
      vx_core::t_stringlist,
      typelist,
      vx_core::t_any_from_any->vx_fn_new({}, [](vx_core::Type_any type) {
        vx_core::Type_any output_1 = 
          vx_core::f_typename_from_type(type);
        return output_1;
      })
    );
    vx_core::vx_release_one_except(typelist, output);
    return output;
  }
  /**
   * @function typenames_from_typelist
   * Get the names from a type list
   * @param  {typelist} typelist
   * @return {stringlist}
   * (func typenames<-typelist)
   */
  // (func typenames<-typelist)
  // class Class_typenames_from_typelist {
    Abstract_typenames_from_typelist::~Abstract_typenames_from_typelist() {}

    Class_typenames_from_typelist::Class_typenames_from_typelist() : Abstract_typenames_from_typelist::Abstract_typenames_from_typelist() {
      vx_core::refcount += 1;
    }

    Class_typenames_from_typelist::~Class_typenames_from_typelist() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_typenames_from_typelist::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_typenames_from_typelist output = vx_core::e_typenames_from_typelist;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_typenames_from_typelist::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_typenames_from_typelist output = vx_core::e_typenames_from_typelist;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_typenames_from_typelist::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "typenames<-typelist", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_typenames_from_typelist::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_typenames_from_typelist::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "typenames<-typelist", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_typenames_from_typelist::vx_empty() const {return vx_core::e_typenames_from_typelist;}
    vx_core::Type_any Class_typenames_from_typelist::vx_type() const {return vx_core::t_typenames_from_typelist;}
    vx_core::Type_msgblock Class_typenames_from_typelist::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_typenames_from_typelist::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Func_any_from_any Class_typenames_from_typelist::vx_fn_new(vx_core::vx_Type_listany lambdavars, vx_core::Abstract_any_from_any::IFn fn) const {
      return vx_core::e_any_from_any;
    }

    vx_core::Type_any Class_typenames_from_typelist::vx_any_from_any(vx_core::Type_any val) const {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typelist inputval = vx_core::vx_any_from_any(vx_core::t_typelist, val);
      output = vx_core::f_typenames_from_typelist(inputval);
      vx_core::vx_release_except(val, output);
      return output;
    }

    vx_core::Type_any Class_typenames_from_typelist::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_typelist typelist = vx_core::vx_any_from_any(vx_core::t_typelist, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_typenames_from_typelist(typelist);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  // (func user<-context)
  vx_core::Type_user f_user_from_context(vx_core::Type_context context) {
    vx_core::Type_user output = vx_core::e_user;
    output = vx_core::f_any_from_struct(
      vx_core::t_user,
      vx_core::f_session_from_context(context),
      vx_core::vx_new_string(":user")
    );
    return output;
  }
  /**
   * @function user_from_context
   * Returns the current user from context.
   * @return {user}
   * (func user<-context)
   */
  // (func user<-context)
  // class Class_user_from_context {
    Abstract_user_from_context::~Abstract_user_from_context() {}

    Class_user_from_context::Class_user_from_context() : Abstract_user_from_context::Abstract_user_from_context() {
      vx_core::refcount += 1;
    }

    Class_user_from_context::~Class_user_from_context() {
      vx_core::refcount -= 1;
      if (this->vx_p_msgblock) {
        vx_core::vx_release_one(this->vx_p_msgblock);
      }
    }

    vx_core::Type_any Class_user_from_context::vx_new(vx_core::vx_Type_listany vals) const {
      vx_core::Func_user_from_context output = vx_core::e_user_from_context;
      vx_core::vx_release(vals);
      return output;
    }

    vx_core::Type_any Class_user_from_context::vx_copy(vx_core::Type_any copyval, vx_core::vx_Type_listany vals) const {
      vx_core::Func_user_from_context output = vx_core::e_user_from_context;
      vx_core::vx_release_except(copyval, output);
      vx_core::vx_release_except(vals, output);
      return output;
    }

    vx_core::Type_typedef Class_user_from_context::vx_typedef() const {
      vx_core::Type_typedef output = vx_core::Class_typedef::vx_typedef_new(
        "vx/core", // pkgname
        "user<-context", // name
        ":func", // extends
        vx_core::vx_new(vx_core::t_typelist, {vx_core::t_func}), // traits
        vx_core::e_typelist, // allowtypes
        vx_core::e_typelist, // disallowtypes
        vx_core::e_funclist, // allowfuncs
        vx_core::e_funclist, // disallowfuncs
        vx_core::e_anylist, // allowvalues
        vx_core::e_anylist, // disallowvalues
        vx_core::e_argmap // properties
      );
      return output;
    }

    vx_core::Type_constdef Class_user_from_context::vx_constdef() const {return this->vx_p_constdef;}

    vx_core::Type_funcdef Class_user_from_context::vx_funcdef() const {
      vx_core::Type_funcdef output = vx_core::Class_funcdef::vx_funcdef_new(
        "vx/core", // pkgname
        "user<-context", // name
        0, // idx
        false, // async
        this->vx_typedef() // typedef
      );
      return output;
    }

    vx_core::Type_any Class_user_from_context::vx_empty() const {return vx_core::e_user_from_context;}
    vx_core::Type_any Class_user_from_context::vx_type() const {return vx_core::t_user_from_context;}
    vx_core::Type_msgblock Class_user_from_context::vx_msgblock() const {return this->vx_p_msgblock;}
    vx_core::vx_Type_listany Class_user_from_context::vx_dispose() {return vx_core::emptylistany;}

    vx_core::Type_any Class_user_from_context::vx_repl(vx_core::Type_anylist arglist) {
      vx_core::Type_any output = vx_core::e_any;
      vx_core::Type_context context = vx_core::vx_any_from_any(vx_core::t_context, arglist->vx_get_any(vx_core::vx_new_int(0)));
      output = vx_core::f_user_from_context(context);
      vx_core::vx_release_except(arglist, output);
      return output;
    }

  //}

  vx_core::Type_any e_any = NULL;
  vx_core::Type_any t_any = NULL;
  vx_core::Type_list e_list = NULL;
  vx_core::Type_list t_list = NULL;
  vx_core::Type_map e_map = NULL;
  vx_core::Type_map t_map = NULL;
  vx_core::Type_struct e_struct = NULL;
  vx_core::Type_struct t_struct = NULL;
  vx_core::Type_msg e_msg = NULL;
  vx_core::Type_msg t_msg = NULL;
  vx_core::Type_msglist e_msglist = NULL;
  vx_core::Type_msglist t_msglist = NULL;
  vx_core::Type_msgblock e_msgblock = NULL;
  vx_core::Type_msgblock t_msgblock = NULL;
  vx_core::Type_msgblocklist e_msgblocklist = NULL;
  vx_core::Type_msgblocklist t_msgblocklist = NULL;
  vx_core::Type_boolean e_boolean = NULL;
  vx_core::Type_boolean t_boolean = NULL;
  vx_core::Type_number e_number = NULL;
  vx_core::Type_number t_number = NULL;
  vx_core::Type_decimal e_decimal = NULL;
  vx_core::Type_decimal t_decimal = NULL;
  vx_core::Type_float e_float = NULL;
  vx_core::Type_float t_float = NULL;
  vx_core::Type_int e_int = NULL;
  vx_core::Type_int t_int = NULL;
  vx_core::Type_string e_string = NULL;
  vx_core::Type_string t_string = NULL;
  vx_core::Type_func e_func = NULL;
  vx_core::Type_func t_func = NULL;
  vx_core::Type_typedef e_typedef = NULL;
  vx_core::Type_typedef t_typedef = NULL;
  vx_core::Type_funcdef e_funcdef = NULL;
  vx_core::Type_funcdef t_funcdef = NULL;
  vx_core::Type_any_async_from_func e_any_async_from_func = NULL;
  vx_core::Type_any_async_from_func t_any_async_from_func = NULL;
  vx_core::Type_any_from_anylist e_any_from_anylist = NULL;
  vx_core::Type_any_from_anylist t_any_from_anylist = NULL;
  vx_core::Type_anylist e_anylist = NULL;
  vx_core::Type_anylist t_anylist = NULL;
  vx_core::Type_anymap e_anymap = NULL;
  vx_core::Type_anymap t_anymap = NULL;
  vx_core::Type_anytype e_anytype = NULL;
  vx_core::Type_anytype t_anytype = NULL;
  vx_core::Type_arg e_arg = NULL;
  vx_core::Type_arg t_arg = NULL;
  vx_core::Type_arglist e_arglist = NULL;
  vx_core::Type_arglist t_arglist = NULL;
  vx_core::Type_argmap e_argmap = NULL;
  vx_core::Type_argmap t_argmap = NULL;
  vx_core::Type_booleanlist e_booleanlist = NULL;
  vx_core::Type_booleanlist t_booleanlist = NULL;
  vx_core::Type_collection e_collection = NULL;
  vx_core::Type_collection t_collection = NULL;
  vx_core::Type_compilelanguages e_compilelanguages = NULL;
  vx_core::Type_compilelanguages t_compilelanguages = NULL;
  vx_core::Type_connect e_connect = NULL;
  vx_core::Type_connect t_connect = NULL;
  vx_core::Type_connectlist e_connectlist = NULL;
  vx_core::Type_connectlist t_connectlist = NULL;
  vx_core::Type_connectmap e_connectmap = NULL;
  vx_core::Type_connectmap t_connectmap = NULL;
  vx_core::Type_const e_const = NULL;
  vx_core::Type_const t_const = NULL;
  vx_core::Type_constdef e_constdef = NULL;
  vx_core::Type_constdef t_constdef = NULL;
  vx_core::Type_constlist e_constlist = NULL;
  vx_core::Type_constlist t_constlist = NULL;
  vx_core::Type_constmap e_constmap = NULL;
  vx_core::Type_constmap t_constmap = NULL;
  vx_core::Type_context e_context = NULL;
  vx_core::Type_context t_context = NULL;
  vx_core::Type_date e_date = NULL;
  vx_core::Type_date t_date = NULL;
  vx_core::Type_error e_error = NULL;
  vx_core::Type_error t_error = NULL;
  vx_core::Type_funclist e_funclist = NULL;
  vx_core::Type_funclist t_funclist = NULL;
  vx_core::Type_funcmap e_funcmap = NULL;
  vx_core::Type_funcmap t_funcmap = NULL;
  vx_core::Type_intlist e_intlist = NULL;
  vx_core::Type_intlist t_intlist = NULL;
  vx_core::Type_intmap e_intmap = NULL;
  vx_core::Type_intmap t_intmap = NULL;
  vx_core::Type_listtype e_listtype = NULL;
  vx_core::Type_listtype t_listtype = NULL;
  vx_core::Type_locale e_locale = NULL;
  vx_core::Type_locale t_locale = NULL;
  vx_core::Type_maptype e_maptype = NULL;
  vx_core::Type_maptype t_maptype = NULL;
  vx_core::Type_mempool e_mempool = NULL;
  vx_core::Type_mempool t_mempool = NULL;
  vx_core::Type_none e_none = NULL;
  vx_core::Type_none t_none = NULL;
  vx_core::Type_notype e_notype = NULL;
  vx_core::Type_notype t_notype = NULL;
  vx_core::Type_numberlist e_numberlist = NULL;
  vx_core::Type_numberlist t_numberlist = NULL;
  vx_core::Type_numbermap e_numbermap = NULL;
  vx_core::Type_numbermap t_numbermap = NULL;
  vx_core::Type_package e_package = NULL;
  vx_core::Type_package t_package = NULL;
  vx_core::Type_packagemap e_packagemap = NULL;
  vx_core::Type_packagemap t_packagemap = NULL;
  vx_core::Type_permission e_permission = NULL;
  vx_core::Type_permission t_permission = NULL;
  vx_core::Type_permissionlist e_permissionlist = NULL;
  vx_core::Type_permissionlist t_permissionlist = NULL;
  vx_core::Type_permissionmap e_permissionmap = NULL;
  vx_core::Type_permissionmap t_permissionmap = NULL;
  vx_core::Type_project e_project = NULL;
  vx_core::Type_project t_project = NULL;
  vx_core::Type_security e_security = NULL;
  vx_core::Type_security t_security = NULL;
  vx_core::Type_session e_session = NULL;
  vx_core::Type_session t_session = NULL;
  vx_core::Type_setting e_setting = NULL;
  vx_core::Type_setting t_setting = NULL;
  vx_core::Type_state e_state = NULL;
  vx_core::Type_state t_state = NULL;
  vx_core::Type_statelistener e_statelistener = NULL;
  vx_core::Type_statelistener t_statelistener = NULL;
  vx_core::Type_statelistenermap e_statelistenermap = NULL;
  vx_core::Type_statelistenermap t_statelistenermap = NULL;
  vx_core::Type_stringlist e_stringlist = NULL;
  vx_core::Type_stringlist t_stringlist = NULL;
  vx_core::Type_stringlistlist e_stringlistlist = NULL;
  vx_core::Type_stringlistlist t_stringlistlist = NULL;
  vx_core::Type_stringmap e_stringmap = NULL;
  vx_core::Type_stringmap t_stringmap = NULL;
  vx_core::Type_stringmutablemap e_stringmutablemap = NULL;
  vx_core::Type_stringmutablemap t_stringmutablemap = NULL;
  vx_core::Type_thenelse e_thenelse = NULL;
  vx_core::Type_thenelse t_thenelse = NULL;
  vx_core::Type_thenelselist e_thenelselist = NULL;
  vx_core::Type_thenelselist t_thenelselist = NULL;
  vx_core::Type_translation e_translation = NULL;
  vx_core::Type_translation t_translation = NULL;
  vx_core::Type_translationlist e_translationlist = NULL;
  vx_core::Type_translationlist t_translationlist = NULL;
  vx_core::Type_translationmap e_translationmap = NULL;
  vx_core::Type_translationmap t_translationmap = NULL;
  vx_core::Type_type e_type = NULL;
  vx_core::Type_type t_type = NULL;
  vx_core::Type_typelist e_typelist = NULL;
  vx_core::Type_typelist t_typelist = NULL;
  vx_core::Type_typemap e_typemap = NULL;
  vx_core::Type_typemap t_typemap = NULL;
  vx_core::Type_user e_user = NULL;
  vx_core::Type_user t_user = NULL;
  vx_core::Type_value e_value = NULL;
  vx_core::Type_value t_value = NULL;
  vx_core::Const_false c_false = NULL;
  vx_core::Const_global c_global = NULL;
  vx_core::Const_infinity c_infinity = NULL;
  vx_core::Const_mempool_active c_mempool_active = NULL;
  vx_core::Const_msg_error c_msg_error = NULL;
  vx_core::Const_msg_info c_msg_info = NULL;
  vx_core::Const_msg_severe c_msg_severe = NULL;
  vx_core::Const_msg_warning c_msg_warning = NULL;
  vx_core::Const_neginfinity c_neginfinity = NULL;
  vx_core::Const_newline c_newline = NULL;
  vx_core::Const_notanumber c_notanumber = NULL;
  vx_core::Const_nothing c_nothing = NULL;
  vx_core::Const_path_test_resources c_path_test_resources = NULL;
  vx_core::Const_quote c_quote = NULL;
  vx_core::Const_true c_true = NULL;
  vx_core::Func_any_from_any e_any_from_any = NULL;
  vx_core::Func_any_from_any t_any_from_any = NULL;
  vx_core::Func_any_from_any_async e_any_from_any_async = NULL;
  vx_core::Func_any_from_any_async t_any_from_any_async = NULL;
  vx_core::Func_any_from_any_context e_any_from_any_context = NULL;
  vx_core::Func_any_from_any_context t_any_from_any_context = NULL;
  vx_core::Func_any_from_any_context_async e_any_from_any_context_async = NULL;
  vx_core::Func_any_from_any_context_async t_any_from_any_context_async = NULL;
  vx_core::Func_any_from_func e_any_from_func = NULL;
  vx_core::Func_any_from_func t_any_from_func = NULL;
  vx_core::Func_any_from_func_async e_any_from_func_async = NULL;
  vx_core::Func_any_from_func_async t_any_from_func_async = NULL;
  vx_core::Func_any_from_key_value e_any_from_key_value = NULL;
  vx_core::Func_any_from_key_value t_any_from_key_value = NULL;
  vx_core::Func_any_from_key_value_async e_any_from_key_value_async = NULL;
  vx_core::Func_any_from_key_value_async t_any_from_key_value_async = NULL;
  vx_core::Func_any_from_list e_any_from_list = NULL;
  vx_core::Func_any_from_list t_any_from_list = NULL;
  vx_core::Func_any_from_list_start_reduce e_any_from_list_start_reduce = NULL;
  vx_core::Func_any_from_list_start_reduce t_any_from_list_start_reduce = NULL;
  vx_core::Func_any_from_list_start_reduce_next e_any_from_list_start_reduce_next = NULL;
  vx_core::Func_any_from_list_start_reduce_next t_any_from_list_start_reduce_next = NULL;
  vx_core::Func_any_from_map e_any_from_map = NULL;
  vx_core::Func_any_from_map t_any_from_map = NULL;
  vx_core::Func_any_from_none e_any_from_none = NULL;
  vx_core::Func_any_from_none t_any_from_none = NULL;
  vx_core::Func_any_from_none_async e_any_from_none_async = NULL;
  vx_core::Func_any_from_none_async t_any_from_none_async = NULL;
  vx_core::Func_any_from_reduce e_any_from_reduce = NULL;
  vx_core::Func_any_from_reduce t_any_from_reduce = NULL;
  vx_core::Func_any_from_reduce_async e_any_from_reduce_async = NULL;
  vx_core::Func_any_from_reduce_async t_any_from_reduce_async = NULL;
  vx_core::Func_any_from_reduce_next e_any_from_reduce_next = NULL;
  vx_core::Func_any_from_reduce_next t_any_from_reduce_next = NULL;
  vx_core::Func_any_from_reduce_next_async e_any_from_reduce_next_async = NULL;
  vx_core::Func_any_from_reduce_next_async t_any_from_reduce_next_async = NULL;
  vx_core::Func_any_from_struct e_any_from_struct = NULL;
  vx_core::Func_any_from_struct t_any_from_struct = NULL;
  vx_core::Func_async e_async = NULL;
  vx_core::Func_async t_async = NULL;
  vx_core::Func_boolean_from_any e_boolean_from_any = NULL;
  vx_core::Func_boolean_from_any t_boolean_from_any = NULL;
  vx_core::Func_boolean_from_func e_boolean_from_func = NULL;
  vx_core::Func_boolean_from_func t_boolean_from_func = NULL;
  vx_core::Func_boolean_from_none e_boolean_from_none = NULL;
  vx_core::Func_boolean_from_none t_boolean_from_none = NULL;
  vx_core::Func_empty e_empty = NULL;
  vx_core::Func_empty t_empty = NULL;
  vx_core::Func_new e_new = NULL;
  vx_core::Func_new t_new = NULL;
  vx_core::Func_copy e_copy = NULL;
  vx_core::Func_copy t_copy = NULL;
  vx_core::Func_is_empty e_is_empty = NULL;
  vx_core::Func_is_empty t_is_empty = NULL;
  vx_core::Func_is_empty_1 e_is_empty_1 = NULL;
  vx_core::Func_is_empty_1 t_is_empty_1 = NULL;
  vx_core::Func_not e_not = NULL;
  vx_core::Func_not t_not = NULL;
  vx_core::Func_notempty e_notempty = NULL;
  vx_core::Func_notempty t_notempty = NULL;
  vx_core::Func_notempty_1 e_notempty_1 = NULL;
  vx_core::Func_notempty_1 t_notempty_1 = NULL;
  vx_core::Func_eq e_eq = NULL;
  vx_core::Func_eq t_eq = NULL;
  vx_core::Func_eq_1 e_eq_1 = NULL;
  vx_core::Func_eq_1 t_eq_1 = NULL;
  vx_core::Func_ne e_ne = NULL;
  vx_core::Func_ne t_ne = NULL;
  vx_core::Func_then e_then = NULL;
  vx_core::Func_then t_then = NULL;
  vx_core::Func_else e_else = NULL;
  vx_core::Func_else t_else = NULL;
  vx_core::Func_if e_if = NULL;
  vx_core::Func_if t_if = NULL;
  vx_core::Func_if_1 e_if_1 = NULL;
  vx_core::Func_if_1 t_if_1 = NULL;
  vx_core::Func_if_2 e_if_2 = NULL;
  vx_core::Func_if_2 t_if_2 = NULL;
  vx_core::Func_case e_case = NULL;
  vx_core::Func_case t_case = NULL;
  vx_core::Func_case_1 e_case_1 = NULL;
  vx_core::Func_case_1 t_case_1 = NULL;
  vx_core::Func_switch e_switch = NULL;
  vx_core::Func_switch t_switch = NULL;
  vx_core::Func_length e_length = NULL;
  vx_core::Func_length t_length = NULL;
  vx_core::Func_length_1 e_length_1 = NULL;
  vx_core::Func_length_1 t_length_1 = NULL;
  vx_core::Func_length_2 e_length_2 = NULL;
  vx_core::Func_length_2 t_length_2 = NULL;
  vx_core::Func_and e_and = NULL;
  vx_core::Func_and t_and = NULL;
  vx_core::Func_and_1 e_and_1 = NULL;
  vx_core::Func_and_1 t_and_1 = NULL;
  vx_core::Func_or e_or = NULL;
  vx_core::Func_or t_or = NULL;
  vx_core::Func_or_1 e_or_1 = NULL;
  vx_core::Func_or_1 t_or_1 = NULL;
  vx_core::Func_let e_let = NULL;
  vx_core::Func_let t_let = NULL;
  vx_core::Func_let_async e_let_async = NULL;
  vx_core::Func_let_async t_let_async = NULL;
  vx_core::Func_neqeq e_neqeq = NULL;
  vx_core::Func_neqeq t_neqeq = NULL;
  vx_core::Func_multiply_3 e_multiply_3 = NULL;
  vx_core::Func_multiply_3 t_multiply_3 = NULL;
  vx_core::Func_multiply_2 e_multiply_2 = NULL;
  vx_core::Func_multiply_2 t_multiply_2 = NULL;
  vx_core::Func_multiply_1 e_multiply_1 = NULL;
  vx_core::Func_multiply_1 t_multiply_1 = NULL;
  vx_core::Func_multiply e_multiply = NULL;
  vx_core::Func_multiply t_multiply = NULL;
  vx_core::Func_plus_3 e_plus_3 = NULL;
  vx_core::Func_plus_3 t_plus_3 = NULL;
  vx_core::Func_plus_2 e_plus_2 = NULL;
  vx_core::Func_plus_2 t_plus_2 = NULL;
  vx_core::Func_plus_1 e_plus_1 = NULL;
  vx_core::Func_plus_1 t_plus_1 = NULL;
  vx_core::Func_plus e_plus = NULL;
  vx_core::Func_plus t_plus = NULL;
  vx_core::Func_plus1 e_plus1 = NULL;
  vx_core::Func_plus1 t_plus1 = NULL;
  vx_core::Func_minus_3 e_minus_3 = NULL;
  vx_core::Func_minus_3 t_minus_3 = NULL;
  vx_core::Func_minus_2 e_minus_2 = NULL;
  vx_core::Func_minus_2 t_minus_2 = NULL;
  vx_core::Func_minus_1 e_minus_1 = NULL;
  vx_core::Func_minus_1 t_minus_1 = NULL;
  vx_core::Func_minus e_minus = NULL;
  vx_core::Func_minus t_minus = NULL;
  vx_core::Func_minus1 e_minus1 = NULL;
  vx_core::Func_minus1 t_minus1 = NULL;
  vx_core::Func_dotmethod e_dotmethod = NULL;
  vx_core::Func_dotmethod t_dotmethod = NULL;
  vx_core::Func_divide e_divide = NULL;
  vx_core::Func_divide t_divide = NULL;
  vx_core::Func_lt_1 e_lt_1 = NULL;
  vx_core::Func_lt_1 t_lt_1 = NULL;
  vx_core::Func_lt e_lt = NULL;
  vx_core::Func_lt t_lt = NULL;
  vx_core::Func_chainfirst e_chainfirst = NULL;
  vx_core::Func_chainfirst t_chainfirst = NULL;
  vx_core::Func_chainlast e_chainlast = NULL;
  vx_core::Func_chainlast t_chainlast = NULL;
  vx_core::Func_le_1 e_le_1 = NULL;
  vx_core::Func_le_1 t_le_1 = NULL;
  vx_core::Func_le e_le = NULL;
  vx_core::Func_le t_le = NULL;
  vx_core::Func_eqeq e_eqeq = NULL;
  vx_core::Func_eqeq t_eqeq = NULL;
  vx_core::Func_gt_1 e_gt_1 = NULL;
  vx_core::Func_gt_1 t_gt_1 = NULL;
  vx_core::Func_gt e_gt = NULL;
  vx_core::Func_gt t_gt = NULL;
  vx_core::Func_ge_1 e_ge_1 = NULL;
  vx_core::Func_ge_1 t_ge_1 = NULL;
  vx_core::Func_ge e_ge = NULL;
  vx_core::Func_ge t_ge = NULL;
  vx_core::Func_allowfuncs_from_security e_allowfuncs_from_security = NULL;
  vx_core::Func_allowfuncs_from_security t_allowfuncs_from_security = NULL;
  vx_core::Func_allowtypenames_from_typedef e_allowtypenames_from_typedef = NULL;
  vx_core::Func_allowtypenames_from_typedef t_allowtypenames_from_typedef = NULL;
  vx_core::Func_allowtypes_from_typedef e_allowtypes_from_typedef = NULL;
  vx_core::Func_allowtypes_from_typedef t_allowtypes_from_typedef = NULL;
  vx_core::Func_any_from_any_key_value e_any_from_any_key_value = NULL;
  vx_core::Func_any_from_any_key_value t_any_from_any_key_value = NULL;
  vx_core::Func_any_from_int e_any_from_int = NULL;
  vx_core::Func_any_from_int t_any_from_int = NULL;
  vx_core::Func_any_from_int_any e_any_from_int_any = NULL;
  vx_core::Func_any_from_int_any t_any_from_int_any = NULL;
  vx_core::Func_any_from_map_start_reduce e_any_from_map_start_reduce = NULL;
  vx_core::Func_any_from_map_start_reduce t_any_from_map_start_reduce = NULL;
  vx_core::Func_boolean_permission_from_func e_boolean_permission_from_func = NULL;
  vx_core::Func_boolean_permission_from_func t_boolean_permission_from_func = NULL;
  vx_core::Func_boolean_write_from_map_name_value e_boolean_write_from_map_name_value = NULL;
  vx_core::Func_boolean_write_from_map_name_value t_boolean_write_from_map_name_value = NULL;
  vx_core::Func_compare e_compare = NULL;
  vx_core::Func_compare t_compare = NULL;
  vx_core::Func_contains_1 e_contains_1 = NULL;
  vx_core::Func_contains_1 t_contains_1 = NULL;
  vx_core::Func_contains e_contains = NULL;
  vx_core::Func_contains t_contains = NULL;
  vx_core::Func_context_main e_context_main = NULL;
  vx_core::Func_context_main t_context_main = NULL;
  vx_core::Func_extends_from_any e_extends_from_any = NULL;
  vx_core::Func_extends_from_any t_extends_from_any = NULL;
  vx_core::Func_extends_from_typedef e_extends_from_typedef = NULL;
  vx_core::Func_extends_from_typedef t_extends_from_typedef = NULL;
  vx_core::Func_first_from_list e_first_from_list = NULL;
  vx_core::Func_first_from_list t_first_from_list = NULL;
  vx_core::Func_first_from_list_any_from_any e_first_from_list_any_from_any = NULL;
  vx_core::Func_first_from_list_any_from_any t_first_from_list_any_from_any = NULL;
  vx_core::Func_float_from_string e_float_from_string = NULL;
  vx_core::Func_float_from_string t_float_from_string = NULL;
  vx_core::Func_fn e_fn = NULL;
  vx_core::Func_fn t_fn = NULL;
  vx_core::Func_funcdef_from_func e_funcdef_from_func = NULL;
  vx_core::Func_funcdef_from_func t_funcdef_from_func = NULL;
  vx_core::Func_funcname_from_funcdef e_funcname_from_funcdef = NULL;
  vx_core::Func_funcname_from_funcdef t_funcname_from_funcdef = NULL;
  vx_core::Func_int_from_func e_int_from_func = NULL;
  vx_core::Func_int_from_func t_int_from_func = NULL;
  vx_core::Func_int_from_string e_int_from_string = NULL;
  vx_core::Func_int_from_string t_int_from_string = NULL;
  vx_core::Func_is_endswith e_is_endswith = NULL;
  vx_core::Func_is_endswith t_is_endswith = NULL;
  vx_core::Func_is_float e_is_float = NULL;
  vx_core::Func_is_float t_is_float = NULL;
  vx_core::Func_is_func e_is_func = NULL;
  vx_core::Func_is_func t_is_func = NULL;
  vx_core::Func_is_int e_is_int = NULL;
  vx_core::Func_is_int t_is_int = NULL;
  vx_core::Func_is_number e_is_number = NULL;
  vx_core::Func_is_number t_is_number = NULL;
  vx_core::Func_is_pass_from_permission e_is_pass_from_permission = NULL;
  vx_core::Func_is_pass_from_permission t_is_pass_from_permission = NULL;
  vx_core::Func_last_from_list e_last_from_list = NULL;
  vx_core::Func_last_from_list t_last_from_list = NULL;
  vx_core::Func_list_join_from_list_1 e_list_join_from_list_1 = NULL;
  vx_core::Func_list_join_from_list_1 t_list_join_from_list_1 = NULL;
  vx_core::Func_list_join_from_list e_list_join_from_list = NULL;
  vx_core::Func_list_join_from_list t_list_join_from_list = NULL;
  vx_core::Func_list_from_list_1 e_list_from_list_1 = NULL;
  vx_core::Func_list_from_list_1 t_list_from_list_1 = NULL;
  vx_core::Func_list_from_list e_list_from_list = NULL;
  vx_core::Func_list_from_list t_list_from_list = NULL;
  vx_core::Func_list_from_list_async e_list_from_list_async = NULL;
  vx_core::Func_list_from_list_async t_list_from_list_async = NULL;
  vx_core::Func_list_from_list_intany e_list_from_list_intany = NULL;
  vx_core::Func_list_from_list_intany t_list_from_list_intany = NULL;
  vx_core::Func_list_from_map_1 e_list_from_map_1 = NULL;
  vx_core::Func_list_from_map_1 t_list_from_map_1 = NULL;
  vx_core::Func_list_from_map e_list_from_map = NULL;
  vx_core::Func_list_from_map t_list_from_map = NULL;
  vx_core::Func_list_from_map_async e_list_from_map_async = NULL;
  vx_core::Func_list_from_map_async t_list_from_map_async = NULL;
  vx_core::Func_list_from_type e_list_from_type = NULL;
  vx_core::Func_list_from_type t_list_from_type = NULL;
  vx_core::Func_log_1 e_log_1 = NULL;
  vx_core::Func_log_1 t_log_1 = NULL;
  vx_core::Func_log e_log = NULL;
  vx_core::Func_log t_log = NULL;
  vx_core::Func_main e_main = NULL;
  vx_core::Func_main t_main = NULL;
  vx_core::Func_map_from_list e_map_from_list = NULL;
  vx_core::Func_map_from_list t_map_from_list = NULL;
  vx_core::Func_map_from_map_1 e_map_from_map_1 = NULL;
  vx_core::Func_map_from_map_1 t_map_from_map_1 = NULL;
  vx_core::Func_map_from_map e_map_from_map = NULL;
  vx_core::Func_map_from_map t_map_from_map = NULL;
  vx_core::Func_msg_from_error_2 e_msg_from_error_2 = NULL;
  vx_core::Func_msg_from_error_2 t_msg_from_error_2 = NULL;
  vx_core::Func_msg_from_error_1 e_msg_from_error_1 = NULL;
  vx_core::Func_msg_from_error_1 t_msg_from_error_1 = NULL;
  vx_core::Func_msg_from_error e_msg_from_error = NULL;
  vx_core::Func_msg_from_error t_msg_from_error = NULL;
  vx_core::Func_msg_from_warning e_msg_from_warning = NULL;
  vx_core::Func_msg_from_warning t_msg_from_warning = NULL;
  vx_core::Func_msgblock_from_msgblock_msg e_msgblock_from_msgblock_msg = NULL;
  vx_core::Func_msgblock_from_msgblock_msg t_msgblock_from_msgblock_msg = NULL;
  vx_core::Func_msgblock_from_msgblock_msgblock e_msgblock_from_msgblock_msgblock = NULL;
  vx_core::Func_msgblock_from_msgblock_msgblock t_msgblock_from_msgblock_msgblock = NULL;
  vx_core::Func_name_from_typedef e_name_from_typedef = NULL;
  vx_core::Func_name_from_typedef t_name_from_typedef = NULL;
  vx_core::Func_native e_native = NULL;
  vx_core::Func_native t_native = NULL;
  vx_core::Func_native_from_any e_native_from_any = NULL;
  vx_core::Func_native_from_any t_native_from_any = NULL;
  vx_core::Func_new_from_type e_new_from_type = NULL;
  vx_core::Func_new_from_type t_new_from_type = NULL;
  vx_core::Func_number_from_func e_number_from_func = NULL;
  vx_core::Func_number_from_func t_number_from_func = NULL;
  vx_core::Func_package_global_from_name e_package_global_from_name = NULL;
  vx_core::Func_package_global_from_name t_package_global_from_name = NULL;
  vx_core::Func_packagename_from_typedef e_packagename_from_typedef = NULL;
  vx_core::Func_packagename_from_typedef t_packagename_from_typedef = NULL;
  vx_core::Func_path_from_context_path e_path_from_context_path = NULL;
  vx_core::Func_path_from_context_path t_path_from_context_path = NULL;
  vx_core::Func_path_from_setting_path e_path_from_setting_path = NULL;
  vx_core::Func_path_from_setting_path t_path_from_setting_path = NULL;
  vx_core::Func_permission_from_id_context e_permission_from_id_context = NULL;
  vx_core::Func_permission_from_id_context t_permission_from_id_context = NULL;
  vx_core::Func_properties_from_typedef e_properties_from_typedef = NULL;
  vx_core::Func_properties_from_typedef t_properties_from_typedef = NULL;
  vx_core::Func_proplast_from_typedef e_proplast_from_typedef = NULL;
  vx_core::Func_proplast_from_typedef t_proplast_from_typedef = NULL;
  vx_core::Func_resolve_1 e_resolve_1 = NULL;
  vx_core::Func_resolve_1 t_resolve_1 = NULL;
  vx_core::Func_resolve e_resolve = NULL;
  vx_core::Func_resolve t_resolve = NULL;
  vx_core::Func_resolve_async e_resolve_async = NULL;
  vx_core::Func_resolve_async t_resolve_async = NULL;
  vx_core::Func_resolve_first e_resolve_first = NULL;
  vx_core::Func_resolve_first t_resolve_first = NULL;
  vx_core::Func_resolve_list e_resolve_list = NULL;
  vx_core::Func_resolve_list t_resolve_list = NULL;
  vx_core::Func_security_from_context e_security_from_context = NULL;
  vx_core::Func_security_from_context t_security_from_context = NULL;
  vx_core::Func_security_from_user e_security_from_user = NULL;
  vx_core::Func_security_from_user t_security_from_user = NULL;
  vx_core::Func_session_from_context e_session_from_context = NULL;
  vx_core::Func_session_from_context t_session_from_context = NULL;
  vx_core::Func_setting_from_context e_setting_from_context = NULL;
  vx_core::Func_setting_from_context t_setting_from_context = NULL;
  vx_core::Func_string_repeat e_string_repeat = NULL;
  vx_core::Func_string_repeat t_string_repeat = NULL;
  vx_core::Func_string_from_any e_string_from_any = NULL;
  vx_core::Func_string_from_any t_string_from_any = NULL;
  vx_core::Func_string_from_any_indent e_string_from_any_indent = NULL;
  vx_core::Func_string_from_any_indent t_string_from_any_indent = NULL;
  vx_core::Func_string_from_func e_string_from_func = NULL;
  vx_core::Func_string_from_func t_string_from_func = NULL;
  vx_core::Func_string_from_string_find_replace e_string_from_string_find_replace = NULL;
  vx_core::Func_string_from_string_find_replace t_string_from_string_find_replace = NULL;
  vx_core::Func_stringlist_from_map e_stringlist_from_map = NULL;
  vx_core::Func_stringlist_from_map t_stringlist_from_map = NULL;
  vx_core::Func_traits_from_typedef e_traits_from_typedef = NULL;
  vx_core::Func_traits_from_typedef t_traits_from_typedef = NULL;
  vx_core::Func_type_from_any e_type_from_any = NULL;
  vx_core::Func_type_from_any t_type_from_any = NULL;
  vx_core::Func_typedef_from_any e_typedef_from_any = NULL;
  vx_core::Func_typedef_from_any t_typedef_from_any = NULL;
  vx_core::Func_typedef_from_type e_typedef_from_type = NULL;
  vx_core::Func_typedef_from_type t_typedef_from_type = NULL;
  vx_core::Func_typename_from_any e_typename_from_any = NULL;
  vx_core::Func_typename_from_any t_typename_from_any = NULL;
  vx_core::Func_typename_from_type e_typename_from_type = NULL;
  vx_core::Func_typename_from_type t_typename_from_type = NULL;
  vx_core::Func_typename_from_typedef e_typename_from_typedef = NULL;
  vx_core::Func_typename_from_typedef t_typename_from_typedef = NULL;
  vx_core::Func_typenames_from_typelist e_typenames_from_typelist = NULL;
  vx_core::Func_typenames_from_typelist t_typenames_from_typelist = NULL;
  vx_core::Func_user_from_context e_user_from_context = NULL;
  vx_core::Func_user_from_context t_user_from_context = NULL;

  // class vx_Class_package {
    vx_Class_package::vx_Class_package() {
      init();
    }
    void vx_Class_package::init() {
      vx_core::c_false = new vx_core::Class_false();
      vx_core::c_global = new vx_core::Class_global();
      vx_core::c_infinity = new vx_core::Class_infinity();
      vx_core::c_mempool_active = new vx_core::Class_mempool_active();
      vx_core::c_msg_error = new vx_core::Class_msg_error();
      vx_core::c_msg_info = new vx_core::Class_msg_info();
      vx_core::c_msg_severe = new vx_core::Class_msg_severe();
      vx_core::c_msg_warning = new vx_core::Class_msg_warning();
      vx_core::c_neginfinity = new vx_core::Class_neginfinity();
      vx_core::c_newline = new vx_core::Class_newline();
      vx_core::c_notanumber = new vx_core::Class_notanumber();
      vx_core::c_nothing = new vx_core::Class_nothing();
      vx_core::c_path_test_resources = new vx_core::Class_path_test_resources();
      vx_core::c_quote = new vx_core::Class_quote();
      vx_core::c_true = new vx_core::Class_true();
      vx_core::e_any = new Class_any();
      vx_core::vx_reserve_empty(vx_core::e_any);
      vx_core::t_any = new Class_any();
      vx_core::vx_reserve_type(vx_core::t_any);
      vx_core::e_list = new Class_list();
      vx_core::vx_reserve_empty(vx_core::e_list);
      vx_core::t_list = new Class_list();
      vx_core::vx_reserve_type(vx_core::t_list);
      vx_core::e_map = new Class_map();
      vx_core::vx_reserve_empty(vx_core::e_map);
      vx_core::t_map = new Class_map();
      vx_core::vx_reserve_type(vx_core::t_map);
      vx_core::e_struct = new Class_struct();
      vx_core::vx_reserve_empty(vx_core::e_struct);
      vx_core::t_struct = new Class_struct();
      vx_core::vx_reserve_type(vx_core::t_struct);
      vx_core::e_msg = new Class_msg();
      vx_core::vx_reserve_empty(vx_core::e_msg);
      vx_core::t_msg = new Class_msg();
      vx_core::vx_reserve_type(vx_core::t_msg);
      vx_core::e_msglist = new Class_msglist();
      vx_core::vx_reserve_empty(vx_core::e_msglist);
      vx_core::t_msglist = new Class_msglist();
      vx_core::vx_reserve_type(vx_core::t_msglist);
      vx_core::e_msgblock = new Class_msgblock();
      vx_core::vx_reserve_empty(vx_core::e_msgblock);
      vx_core::t_msgblock = new Class_msgblock();
      vx_core::vx_reserve_type(vx_core::t_msgblock);
      vx_core::e_msgblocklist = new Class_msgblocklist();
      vx_core::vx_reserve_empty(vx_core::e_msgblocklist);
      vx_core::t_msgblocklist = new Class_msgblocklist();
      vx_core::vx_reserve_type(vx_core::t_msgblocklist);
      vx_core::e_boolean = vx_core::c_false;
      vx_core::t_boolean = new Class_boolean();
      vx_core::vx_reserve_type(vx_core::t_boolean);
      vx_core::e_number = new Class_number();
      vx_core::vx_reserve_empty(vx_core::e_number);
      vx_core::t_number = new Class_number();
      vx_core::vx_reserve_type(vx_core::t_number);
      vx_core::e_decimal = new Class_decimal();
      vx_core::vx_reserve_empty(vx_core::e_decimal);
      vx_core::t_decimal = new Class_decimal();
      vx_core::vx_reserve_type(vx_core::t_decimal);
      vx_core::e_float = new Class_float();
      vx_core::vx_reserve_empty(vx_core::e_float);
      vx_core::t_float = new Class_float();
      vx_core::vx_reserve_type(vx_core::t_float);
      vx_core::e_int = new Class_int();
      vx_core::vx_reserve_empty(vx_core::e_int);
      vx_core::t_int = new Class_int();
      vx_core::vx_reserve_type(vx_core::t_int);
      vx_core::e_string = new Class_string();
      vx_core::vx_reserve_empty(vx_core::e_string);
      vx_core::t_string = new Class_string();
      vx_core::vx_reserve_type(vx_core::t_string);
      vx_core::e_func = new Class_func();
      vx_core::vx_reserve_empty(vx_core::e_func);
      vx_core::t_func = new Class_func();
      vx_core::vx_reserve_type(vx_core::t_func);
      vx_core::e_typedef = new Class_typedef();
      vx_core::vx_reserve_empty(vx_core::e_typedef);
      vx_core::t_typedef = new Class_typedef();
      vx_core::vx_reserve_type(vx_core::t_typedef);
      vx_core::e_funcdef = new Class_funcdef();
      vx_core::vx_reserve_empty(vx_core::e_funcdef);
      vx_core::t_funcdef = new Class_funcdef();
      vx_core::vx_reserve_type(vx_core::t_funcdef);
      vx_core::e_any_async_from_func = new Class_any_async_from_func();
      vx_core::vx_reserve_empty(vx_core::e_any_async_from_func);
      vx_core::t_any_async_from_func = new Class_any_async_from_func();
      vx_core::vx_reserve_type(vx_core::t_any_async_from_func);
      vx_core::e_any_from_anylist = new Class_any_from_anylist();
      vx_core::vx_reserve_empty(vx_core::e_any_from_anylist);
      vx_core::t_any_from_anylist = new Class_any_from_anylist();
      vx_core::vx_reserve_type(vx_core::t_any_from_anylist);
      vx_core::e_anylist = new Class_anylist();
      vx_core::vx_reserve_empty(vx_core::e_anylist);
      vx_core::t_anylist = new Class_anylist();
      vx_core::vx_reserve_type(vx_core::t_anylist);
      vx_core::e_anymap = new Class_anymap();
      vx_core::vx_reserve_empty(vx_core::e_anymap);
      vx_core::t_anymap = new Class_anymap();
      vx_core::vx_reserve_type(vx_core::t_anymap);
      vx_core::e_anytype = new Class_anytype();
      vx_core::vx_reserve_empty(vx_core::e_anytype);
      vx_core::t_anytype = new Class_anytype();
      vx_core::vx_reserve_type(vx_core::t_anytype);
      vx_core::e_arg = new Class_arg();
      vx_core::vx_reserve_empty(vx_core::e_arg);
      vx_core::t_arg = new Class_arg();
      vx_core::vx_reserve_type(vx_core::t_arg);
      vx_core::e_arglist = new Class_arglist();
      vx_core::vx_reserve_empty(vx_core::e_arglist);
      vx_core::t_arglist = new Class_arglist();
      vx_core::vx_reserve_type(vx_core::t_arglist);
      vx_core::e_argmap = new Class_argmap();
      vx_core::vx_reserve_empty(vx_core::e_argmap);
      vx_core::t_argmap = new Class_argmap();
      vx_core::vx_reserve_type(vx_core::t_argmap);
      vx_core::e_booleanlist = new Class_booleanlist();
      vx_core::vx_reserve_empty(vx_core::e_booleanlist);
      vx_core::t_booleanlist = new Class_booleanlist();
      vx_core::vx_reserve_type(vx_core::t_booleanlist);
      vx_core::e_collection = new Class_collection();
      vx_core::vx_reserve_empty(vx_core::e_collection);
      vx_core::t_collection = new Class_collection();
      vx_core::vx_reserve_type(vx_core::t_collection);
      vx_core::e_compilelanguages = new Class_compilelanguages();
      vx_core::vx_reserve_empty(vx_core::e_compilelanguages);
      vx_core::t_compilelanguages = new Class_compilelanguages();
      vx_core::vx_reserve_type(vx_core::t_compilelanguages);
      vx_core::e_connect = new Class_connect();
      vx_core::vx_reserve_empty(vx_core::e_connect);
      vx_core::t_connect = new Class_connect();
      vx_core::vx_reserve_type(vx_core::t_connect);
      vx_core::e_connectlist = new Class_connectlist();
      vx_core::vx_reserve_empty(vx_core::e_connectlist);
      vx_core::t_connectlist = new Class_connectlist();
      vx_core::vx_reserve_type(vx_core::t_connectlist);
      vx_core::e_connectmap = new Class_connectmap();
      vx_core::vx_reserve_empty(vx_core::e_connectmap);
      vx_core::t_connectmap = new Class_connectmap();
      vx_core::vx_reserve_type(vx_core::t_connectmap);
      vx_core::e_const = new Class_const();
      vx_core::vx_reserve_empty(vx_core::e_const);
      vx_core::t_const = new Class_const();
      vx_core::vx_reserve_type(vx_core::t_const);
      vx_core::e_constdef = new Class_constdef();
      vx_core::vx_reserve_empty(vx_core::e_constdef);
      vx_core::t_constdef = new Class_constdef();
      vx_core::vx_reserve_type(vx_core::t_constdef);
      vx_core::e_constlist = new Class_constlist();
      vx_core::vx_reserve_empty(vx_core::e_constlist);
      vx_core::t_constlist = new Class_constlist();
      vx_core::vx_reserve_type(vx_core::t_constlist);
      vx_core::e_constmap = new Class_constmap();
      vx_core::vx_reserve_empty(vx_core::e_constmap);
      vx_core::t_constmap = new Class_constmap();
      vx_core::vx_reserve_type(vx_core::t_constmap);
      vx_core::e_context = new Class_context();
      vx_core::vx_reserve_empty(vx_core::e_context);
      vx_core::t_context = new Class_context();
      vx_core::vx_reserve_type(vx_core::t_context);
      vx_core::e_date = new Class_date();
      vx_core::vx_reserve_empty(vx_core::e_date);
      vx_core::t_date = new Class_date();
      vx_core::vx_reserve_type(vx_core::t_date);
      vx_core::e_error = new Class_error();
      vx_core::vx_reserve_empty(vx_core::e_error);
      vx_core::t_error = new Class_error();
      vx_core::vx_reserve_type(vx_core::t_error);
      vx_core::e_funclist = new Class_funclist();
      vx_core::vx_reserve_empty(vx_core::e_funclist);
      vx_core::t_funclist = new Class_funclist();
      vx_core::vx_reserve_type(vx_core::t_funclist);
      vx_core::e_funcmap = new Class_funcmap();
      vx_core::vx_reserve_empty(vx_core::e_funcmap);
      vx_core::t_funcmap = new Class_funcmap();
      vx_core::vx_reserve_type(vx_core::t_funcmap);
      vx_core::e_intlist = new Class_intlist();
      vx_core::vx_reserve_empty(vx_core::e_intlist);
      vx_core::t_intlist = new Class_intlist();
      vx_core::vx_reserve_type(vx_core::t_intlist);
      vx_core::e_intmap = new Class_intmap();
      vx_core::vx_reserve_empty(vx_core::e_intmap);
      vx_core::t_intmap = new Class_intmap();
      vx_core::vx_reserve_type(vx_core::t_intmap);
      vx_core::e_listtype = new Class_listtype();
      vx_core::vx_reserve_empty(vx_core::e_listtype);
      vx_core::t_listtype = new Class_listtype();
      vx_core::vx_reserve_type(vx_core::t_listtype);
      vx_core::e_locale = new Class_locale();
      vx_core::vx_reserve_empty(vx_core::e_locale);
      vx_core::t_locale = new Class_locale();
      vx_core::vx_reserve_type(vx_core::t_locale);
      vx_core::e_maptype = new Class_maptype();
      vx_core::vx_reserve_empty(vx_core::e_maptype);
      vx_core::t_maptype = new Class_maptype();
      vx_core::vx_reserve_type(vx_core::t_maptype);
      vx_core::e_mempool = new Class_mempool();
      vx_core::vx_reserve_empty(vx_core::e_mempool);
      vx_core::t_mempool = new Class_mempool();
      vx_core::vx_reserve_type(vx_core::t_mempool);
      vx_core::e_none = new Class_none();
      vx_core::vx_reserve_empty(vx_core::e_none);
      vx_core::t_none = new Class_none();
      vx_core::vx_reserve_type(vx_core::t_none);
      vx_core::e_notype = new Class_notype();
      vx_core::vx_reserve_empty(vx_core::e_notype);
      vx_core::t_notype = new Class_notype();
      vx_core::vx_reserve_type(vx_core::t_notype);
      vx_core::e_numberlist = new Class_numberlist();
      vx_core::vx_reserve_empty(vx_core::e_numberlist);
      vx_core::t_numberlist = new Class_numberlist();
      vx_core::vx_reserve_type(vx_core::t_numberlist);
      vx_core::e_numbermap = new Class_numbermap();
      vx_core::vx_reserve_empty(vx_core::e_numbermap);
      vx_core::t_numbermap = new Class_numbermap();
      vx_core::vx_reserve_type(vx_core::t_numbermap);
      vx_core::e_package = new Class_package();
      vx_core::vx_reserve_empty(vx_core::e_package);
      vx_core::t_package = new Class_package();
      vx_core::vx_reserve_type(vx_core::t_package);
      vx_core::e_packagemap = new Class_packagemap();
      vx_core::vx_reserve_empty(vx_core::e_packagemap);
      vx_core::t_packagemap = new Class_packagemap();
      vx_core::vx_reserve_type(vx_core::t_packagemap);
      vx_core::e_permission = new Class_permission();
      vx_core::vx_reserve_empty(vx_core::e_permission);
      vx_core::t_permission = new Class_permission();
      vx_core::vx_reserve_type(vx_core::t_permission);
      vx_core::e_permissionlist = new Class_permissionlist();
      vx_core::vx_reserve_empty(vx_core::e_permissionlist);
      vx_core::t_permissionlist = new Class_permissionlist();
      vx_core::vx_reserve_type(vx_core::t_permissionlist);
      vx_core::e_permissionmap = new Class_permissionmap();
      vx_core::vx_reserve_empty(vx_core::e_permissionmap);
      vx_core::t_permissionmap = new Class_permissionmap();
      vx_core::vx_reserve_type(vx_core::t_permissionmap);
      vx_core::e_project = new Class_project();
      vx_core::vx_reserve_empty(vx_core::e_project);
      vx_core::t_project = new Class_project();
      vx_core::vx_reserve_type(vx_core::t_project);
      vx_core::e_security = new Class_security();
      vx_core::vx_reserve_empty(vx_core::e_security);
      vx_core::t_security = new Class_security();
      vx_core::vx_reserve_type(vx_core::t_security);
      vx_core::e_session = new Class_session();
      vx_core::vx_reserve_empty(vx_core::e_session);
      vx_core::t_session = new Class_session();
      vx_core::vx_reserve_type(vx_core::t_session);
      vx_core::e_setting = new Class_setting();
      vx_core::vx_reserve_empty(vx_core::e_setting);
      vx_core::t_setting = new Class_setting();
      vx_core::vx_reserve_type(vx_core::t_setting);
      vx_core::e_state = new Class_state();
      vx_core::vx_reserve_empty(vx_core::e_state);
      vx_core::t_state = new Class_state();
      vx_core::vx_reserve_type(vx_core::t_state);
      vx_core::e_statelistener = new Class_statelistener();
      vx_core::vx_reserve_empty(vx_core::e_statelistener);
      vx_core::t_statelistener = new Class_statelistener();
      vx_core::vx_reserve_type(vx_core::t_statelistener);
      vx_core::e_statelistenermap = new Class_statelistenermap();
      vx_core::vx_reserve_empty(vx_core::e_statelistenermap);
      vx_core::t_statelistenermap = new Class_statelistenermap();
      vx_core::vx_reserve_type(vx_core::t_statelistenermap);
      vx_core::e_stringlist = new Class_stringlist();
      vx_core::vx_reserve_empty(vx_core::e_stringlist);
      vx_core::t_stringlist = new Class_stringlist();
      vx_core::vx_reserve_type(vx_core::t_stringlist);
      vx_core::e_stringlistlist = new Class_stringlistlist();
      vx_core::vx_reserve_empty(vx_core::e_stringlistlist);
      vx_core::t_stringlistlist = new Class_stringlistlist();
      vx_core::vx_reserve_type(vx_core::t_stringlistlist);
      vx_core::e_stringmap = new Class_stringmap();
      vx_core::vx_reserve_empty(vx_core::e_stringmap);
      vx_core::t_stringmap = new Class_stringmap();
      vx_core::vx_reserve_type(vx_core::t_stringmap);
      vx_core::e_stringmutablemap = new Class_stringmutablemap();
      vx_core::vx_reserve_empty(vx_core::e_stringmutablemap);
      vx_core::t_stringmutablemap = new Class_stringmutablemap();
      vx_core::vx_reserve_type(vx_core::t_stringmutablemap);
      vx_core::e_thenelse = new Class_thenelse();
      vx_core::vx_reserve_empty(vx_core::e_thenelse);
      vx_core::t_thenelse = new Class_thenelse();
      vx_core::vx_reserve_type(vx_core::t_thenelse);
      vx_core::e_thenelselist = new Class_thenelselist();
      vx_core::vx_reserve_empty(vx_core::e_thenelselist);
      vx_core::t_thenelselist = new Class_thenelselist();
      vx_core::vx_reserve_type(vx_core::t_thenelselist);
      vx_core::e_translation = new Class_translation();
      vx_core::vx_reserve_empty(vx_core::e_translation);
      vx_core::t_translation = new Class_translation();
      vx_core::vx_reserve_type(vx_core::t_translation);
      vx_core::e_translationlist = new Class_translationlist();
      vx_core::vx_reserve_empty(vx_core::e_translationlist);
      vx_core::t_translationlist = new Class_translationlist();
      vx_core::vx_reserve_type(vx_core::t_translationlist);
      vx_core::e_translationmap = new Class_translationmap();
      vx_core::vx_reserve_empty(vx_core::e_translationmap);
      vx_core::t_translationmap = new Class_translationmap();
      vx_core::vx_reserve_type(vx_core::t_translationmap);
      vx_core::e_type = new Class_type();
      vx_core::vx_reserve_empty(vx_core::e_type);
      vx_core::t_type = new Class_type();
      vx_core::vx_reserve_type(vx_core::t_type);
      vx_core::e_typelist = new Class_typelist();
      vx_core::vx_reserve_empty(vx_core::e_typelist);
      vx_core::t_typelist = new Class_typelist();
      vx_core::vx_reserve_type(vx_core::t_typelist);
      vx_core::e_typemap = new Class_typemap();
      vx_core::vx_reserve_empty(vx_core::e_typemap);
      vx_core::t_typemap = new Class_typemap();
      vx_core::vx_reserve_type(vx_core::t_typemap);
      vx_core::e_user = new Class_user();
      vx_core::vx_reserve_empty(vx_core::e_user);
      vx_core::t_user = new Class_user();
      vx_core::vx_reserve_type(vx_core::t_user);
      vx_core::e_value = new Class_value();
      vx_core::vx_reserve_empty(vx_core::e_value);
      vx_core::t_value = new Class_value();
      vx_core::vx_reserve_type(vx_core::t_value);
      vx_core::e_any_from_any = new vx_core::Class_any_from_any();
      vx_core::vx_reserve_empty(vx_core::e_any_from_any);
      vx_core::t_any_from_any = new vx_core::Class_any_from_any();
      vx_core::vx_reserve_type(vx_core::t_any_from_any);
      vx_core::e_any_from_any_async = new vx_core::Class_any_from_any_async();
      vx_core::vx_reserve_empty(vx_core::e_any_from_any_async);
      vx_core::t_any_from_any_async = new vx_core::Class_any_from_any_async();
      vx_core::vx_reserve_type(vx_core::t_any_from_any_async);
      vx_core::e_any_from_any_context = new vx_core::Class_any_from_any_context();
      vx_core::vx_reserve_empty(vx_core::e_any_from_any_context);
      vx_core::t_any_from_any_context = new vx_core::Class_any_from_any_context();
      vx_core::vx_reserve_type(vx_core::t_any_from_any_context);
      vx_core::e_any_from_any_context_async = new vx_core::Class_any_from_any_context_async();
      vx_core::vx_reserve_empty(vx_core::e_any_from_any_context_async);
      vx_core::t_any_from_any_context_async = new vx_core::Class_any_from_any_context_async();
      vx_core::vx_reserve_type(vx_core::t_any_from_any_context_async);
      vx_core::e_any_from_func = new vx_core::Class_any_from_func();
      vx_core::vx_reserve_empty(vx_core::e_any_from_func);
      vx_core::t_any_from_func = new vx_core::Class_any_from_func();
      vx_core::vx_reserve_type(vx_core::t_any_from_func);
      vx_core::e_any_from_func_async = new vx_core::Class_any_from_func_async();
      vx_core::vx_reserve_empty(vx_core::e_any_from_func_async);
      vx_core::t_any_from_func_async = new vx_core::Class_any_from_func_async();
      vx_core::vx_reserve_type(vx_core::t_any_from_func_async);
      vx_core::e_any_from_key_value = new vx_core::Class_any_from_key_value();
      vx_core::vx_reserve_empty(vx_core::e_any_from_key_value);
      vx_core::t_any_from_key_value = new vx_core::Class_any_from_key_value();
      vx_core::vx_reserve_type(vx_core::t_any_from_key_value);
      vx_core::e_any_from_key_value_async = new vx_core::Class_any_from_key_value_async();
      vx_core::vx_reserve_empty(vx_core::e_any_from_key_value_async);
      vx_core::t_any_from_key_value_async = new vx_core::Class_any_from_key_value_async();
      vx_core::vx_reserve_type(vx_core::t_any_from_key_value_async);
      vx_core::e_any_from_list = new vx_core::Class_any_from_list();
      vx_core::vx_reserve_empty(vx_core::e_any_from_list);
      vx_core::t_any_from_list = new vx_core::Class_any_from_list();
      vx_core::vx_reserve_type(vx_core::t_any_from_list);
      vx_core::e_any_from_list_start_reduce = new vx_core::Class_any_from_list_start_reduce();
      vx_core::vx_reserve_empty(vx_core::e_any_from_list_start_reduce);
      vx_core::t_any_from_list_start_reduce = new vx_core::Class_any_from_list_start_reduce();
      vx_core::vx_reserve_type(vx_core::t_any_from_list_start_reduce);
      vx_core::e_any_from_list_start_reduce_next = new vx_core::Class_any_from_list_start_reduce_next();
      vx_core::vx_reserve_empty(vx_core::e_any_from_list_start_reduce_next);
      vx_core::t_any_from_list_start_reduce_next = new vx_core::Class_any_from_list_start_reduce_next();
      vx_core::vx_reserve_type(vx_core::t_any_from_list_start_reduce_next);
      vx_core::e_any_from_map = new vx_core::Class_any_from_map();
      vx_core::vx_reserve_empty(vx_core::e_any_from_map);
      vx_core::t_any_from_map = new vx_core::Class_any_from_map();
      vx_core::vx_reserve_type(vx_core::t_any_from_map);
      vx_core::e_any_from_none = new vx_core::Class_any_from_none();
      vx_core::vx_reserve_empty(vx_core::e_any_from_none);
      vx_core::t_any_from_none = new vx_core::Class_any_from_none();
      vx_core::vx_reserve_type(vx_core::t_any_from_none);
      vx_core::e_any_from_none_async = new vx_core::Class_any_from_none_async();
      vx_core::vx_reserve_empty(vx_core::e_any_from_none_async);
      vx_core::t_any_from_none_async = new vx_core::Class_any_from_none_async();
      vx_core::vx_reserve_type(vx_core::t_any_from_none_async);
      vx_core::e_any_from_reduce = new vx_core::Class_any_from_reduce();
      vx_core::vx_reserve_empty(vx_core::e_any_from_reduce);
      vx_core::t_any_from_reduce = new vx_core::Class_any_from_reduce();
      vx_core::vx_reserve_type(vx_core::t_any_from_reduce);
      vx_core::e_any_from_reduce_async = new vx_core::Class_any_from_reduce_async();
      vx_core::vx_reserve_empty(vx_core::e_any_from_reduce_async);
      vx_core::t_any_from_reduce_async = new vx_core::Class_any_from_reduce_async();
      vx_core::vx_reserve_type(vx_core::t_any_from_reduce_async);
      vx_core::e_any_from_reduce_next = new vx_core::Class_any_from_reduce_next();
      vx_core::vx_reserve_empty(vx_core::e_any_from_reduce_next);
      vx_core::t_any_from_reduce_next = new vx_core::Class_any_from_reduce_next();
      vx_core::vx_reserve_type(vx_core::t_any_from_reduce_next);
      vx_core::e_any_from_reduce_next_async = new vx_core::Class_any_from_reduce_next_async();
      vx_core::vx_reserve_empty(vx_core::e_any_from_reduce_next_async);
      vx_core::t_any_from_reduce_next_async = new vx_core::Class_any_from_reduce_next_async();
      vx_core::vx_reserve_type(vx_core::t_any_from_reduce_next_async);
      vx_core::e_any_from_struct = new vx_core::Class_any_from_struct();
      vx_core::vx_reserve_empty(vx_core::e_any_from_struct);
      vx_core::t_any_from_struct = new vx_core::Class_any_from_struct();
      vx_core::vx_reserve_type(vx_core::t_any_from_struct);
      vx_core::e_async = new vx_core::Class_async();
      vx_core::vx_reserve_empty(vx_core::e_async);
      vx_core::t_async = new vx_core::Class_async();
      vx_core::vx_reserve_type(vx_core::t_async);
      vx_core::e_boolean_from_any = new vx_core::Class_boolean_from_any();
      vx_core::vx_reserve_empty(vx_core::e_boolean_from_any);
      vx_core::t_boolean_from_any = new vx_core::Class_boolean_from_any();
      vx_core::vx_reserve_type(vx_core::t_boolean_from_any);
      vx_core::e_boolean_from_func = new vx_core::Class_boolean_from_func();
      vx_core::vx_reserve_empty(vx_core::e_boolean_from_func);
      vx_core::t_boolean_from_func = new vx_core::Class_boolean_from_func();
      vx_core::vx_reserve_type(vx_core::t_boolean_from_func);
      vx_core::e_boolean_from_none = new vx_core::Class_boolean_from_none();
      vx_core::vx_reserve_empty(vx_core::e_boolean_from_none);
      vx_core::t_boolean_from_none = new vx_core::Class_boolean_from_none();
      vx_core::vx_reserve_type(vx_core::t_boolean_from_none);
      vx_core::e_empty = new vx_core::Class_empty();
      vx_core::vx_reserve_empty(vx_core::e_empty);
      vx_core::t_empty = new vx_core::Class_empty();
      vx_core::vx_reserve_type(vx_core::t_empty);
      vx_core::e_new = new vx_core::Class_new();
      vx_core::vx_reserve_empty(vx_core::e_new);
      vx_core::t_new = new vx_core::Class_new();
      vx_core::vx_reserve_type(vx_core::t_new);
      vx_core::e_copy = new vx_core::Class_copy();
      vx_core::vx_reserve_empty(vx_core::e_copy);
      vx_core::t_copy = new vx_core::Class_copy();
      vx_core::vx_reserve_type(vx_core::t_copy);
      vx_core::e_is_empty = new vx_core::Class_is_empty();
      vx_core::vx_reserve_empty(vx_core::e_is_empty);
      vx_core::t_is_empty = new vx_core::Class_is_empty();
      vx_core::vx_reserve_type(vx_core::t_is_empty);
      vx_core::e_is_empty_1 = new vx_core::Class_is_empty_1();
      vx_core::vx_reserve_empty(vx_core::e_is_empty_1);
      vx_core::t_is_empty_1 = new vx_core::Class_is_empty_1();
      vx_core::vx_reserve_type(vx_core::t_is_empty_1);
      vx_core::e_not = new vx_core::Class_not();
      vx_core::vx_reserve_empty(vx_core::e_not);
      vx_core::t_not = new vx_core::Class_not();
      vx_core::vx_reserve_type(vx_core::t_not);
      vx_core::e_notempty = new vx_core::Class_notempty();
      vx_core::vx_reserve_empty(vx_core::e_notempty);
      vx_core::t_notempty = new vx_core::Class_notempty();
      vx_core::vx_reserve_type(vx_core::t_notempty);
      vx_core::e_notempty_1 = new vx_core::Class_notempty_1();
      vx_core::vx_reserve_empty(vx_core::e_notempty_1);
      vx_core::t_notempty_1 = new vx_core::Class_notempty_1();
      vx_core::vx_reserve_type(vx_core::t_notempty_1);
      vx_core::e_eq = new vx_core::Class_eq();
      vx_core::vx_reserve_empty(vx_core::e_eq);
      vx_core::t_eq = new vx_core::Class_eq();
      vx_core::vx_reserve_type(vx_core::t_eq);
      vx_core::e_eq_1 = new vx_core::Class_eq_1();
      vx_core::vx_reserve_empty(vx_core::e_eq_1);
      vx_core::t_eq_1 = new vx_core::Class_eq_1();
      vx_core::vx_reserve_type(vx_core::t_eq_1);
      vx_core::e_ne = new vx_core::Class_ne();
      vx_core::vx_reserve_empty(vx_core::e_ne);
      vx_core::t_ne = new vx_core::Class_ne();
      vx_core::vx_reserve_type(vx_core::t_ne);
      vx_core::e_then = new vx_core::Class_then();
      vx_core::vx_reserve_empty(vx_core::e_then);
      vx_core::t_then = new vx_core::Class_then();
      vx_core::vx_reserve_type(vx_core::t_then);
      vx_core::e_else = new vx_core::Class_else();
      vx_core::vx_reserve_empty(vx_core::e_else);
      vx_core::t_else = new vx_core::Class_else();
      vx_core::vx_reserve_type(vx_core::t_else);
      vx_core::e_if = new vx_core::Class_if();
      vx_core::vx_reserve_empty(vx_core::e_if);
      vx_core::t_if = new vx_core::Class_if();
      vx_core::vx_reserve_type(vx_core::t_if);
      vx_core::e_if_1 = new vx_core::Class_if_1();
      vx_core::vx_reserve_empty(vx_core::e_if_1);
      vx_core::t_if_1 = new vx_core::Class_if_1();
      vx_core::vx_reserve_type(vx_core::t_if_1);
      vx_core::e_if_2 = new vx_core::Class_if_2();
      vx_core::vx_reserve_empty(vx_core::e_if_2);
      vx_core::t_if_2 = new vx_core::Class_if_2();
      vx_core::vx_reserve_type(vx_core::t_if_2);
      vx_core::e_case = new vx_core::Class_case();
      vx_core::vx_reserve_empty(vx_core::e_case);
      vx_core::t_case = new vx_core::Class_case();
      vx_core::vx_reserve_type(vx_core::t_case);
      vx_core::e_case_1 = new vx_core::Class_case_1();
      vx_core::vx_reserve_empty(vx_core::e_case_1);
      vx_core::t_case_1 = new vx_core::Class_case_1();
      vx_core::vx_reserve_type(vx_core::t_case_1);
      vx_core::e_switch = new vx_core::Class_switch();
      vx_core::vx_reserve_empty(vx_core::e_switch);
      vx_core::t_switch = new vx_core::Class_switch();
      vx_core::vx_reserve_type(vx_core::t_switch);
      vx_core::e_length = new vx_core::Class_length();
      vx_core::vx_reserve_empty(vx_core::e_length);
      vx_core::t_length = new vx_core::Class_length();
      vx_core::vx_reserve_type(vx_core::t_length);
      vx_core::e_length_1 = new vx_core::Class_length_1();
      vx_core::vx_reserve_empty(vx_core::e_length_1);
      vx_core::t_length_1 = new vx_core::Class_length_1();
      vx_core::vx_reserve_type(vx_core::t_length_1);
      vx_core::e_length_2 = new vx_core::Class_length_2();
      vx_core::vx_reserve_empty(vx_core::e_length_2);
      vx_core::t_length_2 = new vx_core::Class_length_2();
      vx_core::vx_reserve_type(vx_core::t_length_2);
      vx_core::e_and = new vx_core::Class_and();
      vx_core::vx_reserve_empty(vx_core::e_and);
      vx_core::t_and = new vx_core::Class_and();
      vx_core::vx_reserve_type(vx_core::t_and);
      vx_core::e_and_1 = new vx_core::Class_and_1();
      vx_core::vx_reserve_empty(vx_core::e_and_1);
      vx_core::t_and_1 = new vx_core::Class_and_1();
      vx_core::vx_reserve_type(vx_core::t_and_1);
      vx_core::e_or = new vx_core::Class_or();
      vx_core::vx_reserve_empty(vx_core::e_or);
      vx_core::t_or = new vx_core::Class_or();
      vx_core::vx_reserve_type(vx_core::t_or);
      vx_core::e_or_1 = new vx_core::Class_or_1();
      vx_core::vx_reserve_empty(vx_core::e_or_1);
      vx_core::t_or_1 = new vx_core::Class_or_1();
      vx_core::vx_reserve_type(vx_core::t_or_1);
      vx_core::e_let = new vx_core::Class_let();
      vx_core::vx_reserve_empty(vx_core::e_let);
      vx_core::t_let = new vx_core::Class_let();
      vx_core::vx_reserve_type(vx_core::t_let);
      vx_core::e_let_async = new vx_core::Class_let_async();
      vx_core::vx_reserve_empty(vx_core::e_let_async);
      vx_core::t_let_async = new vx_core::Class_let_async();
      vx_core::vx_reserve_type(vx_core::t_let_async);
      vx_core::e_neqeq = new vx_core::Class_neqeq();
      vx_core::vx_reserve_empty(vx_core::e_neqeq);
      vx_core::t_neqeq = new vx_core::Class_neqeq();
      vx_core::vx_reserve_type(vx_core::t_neqeq);
      vx_core::e_multiply_3 = new vx_core::Class_multiply_3();
      vx_core::vx_reserve_empty(vx_core::e_multiply_3);
      vx_core::t_multiply_3 = new vx_core::Class_multiply_3();
      vx_core::vx_reserve_type(vx_core::t_multiply_3);
      vx_core::e_multiply_2 = new vx_core::Class_multiply_2();
      vx_core::vx_reserve_empty(vx_core::e_multiply_2);
      vx_core::t_multiply_2 = new vx_core::Class_multiply_2();
      vx_core::vx_reserve_type(vx_core::t_multiply_2);
      vx_core::e_multiply_1 = new vx_core::Class_multiply_1();
      vx_core::vx_reserve_empty(vx_core::e_multiply_1);
      vx_core::t_multiply_1 = new vx_core::Class_multiply_1();
      vx_core::vx_reserve_type(vx_core::t_multiply_1);
      vx_core::e_multiply = new vx_core::Class_multiply();
      vx_core::vx_reserve_empty(vx_core::e_multiply);
      vx_core::t_multiply = new vx_core::Class_multiply();
      vx_core::vx_reserve_type(vx_core::t_multiply);
      vx_core::e_plus_3 = new vx_core::Class_plus_3();
      vx_core::vx_reserve_empty(vx_core::e_plus_3);
      vx_core::t_plus_3 = new vx_core::Class_plus_3();
      vx_core::vx_reserve_type(vx_core::t_plus_3);
      vx_core::e_plus_2 = new vx_core::Class_plus_2();
      vx_core::vx_reserve_empty(vx_core::e_plus_2);
      vx_core::t_plus_2 = new vx_core::Class_plus_2();
      vx_core::vx_reserve_type(vx_core::t_plus_2);
      vx_core::e_plus_1 = new vx_core::Class_plus_1();
      vx_core::vx_reserve_empty(vx_core::e_plus_1);
      vx_core::t_plus_1 = new vx_core::Class_plus_1();
      vx_core::vx_reserve_type(vx_core::t_plus_1);
      vx_core::e_plus = new vx_core::Class_plus();
      vx_core::vx_reserve_empty(vx_core::e_plus);
      vx_core::t_plus = new vx_core::Class_plus();
      vx_core::vx_reserve_type(vx_core::t_plus);
      vx_core::e_plus1 = new vx_core::Class_plus1();
      vx_core::vx_reserve_empty(vx_core::e_plus1);
      vx_core::t_plus1 = new vx_core::Class_plus1();
      vx_core::vx_reserve_type(vx_core::t_plus1);
      vx_core::e_minus_3 = new vx_core::Class_minus_3();
      vx_core::vx_reserve_empty(vx_core::e_minus_3);
      vx_core::t_minus_3 = new vx_core::Class_minus_3();
      vx_core::vx_reserve_type(vx_core::t_minus_3);
      vx_core::e_minus_2 = new vx_core::Class_minus_2();
      vx_core::vx_reserve_empty(vx_core::e_minus_2);
      vx_core::t_minus_2 = new vx_core::Class_minus_2();
      vx_core::vx_reserve_type(vx_core::t_minus_2);
      vx_core::e_minus_1 = new vx_core::Class_minus_1();
      vx_core::vx_reserve_empty(vx_core::e_minus_1);
      vx_core::t_minus_1 = new vx_core::Class_minus_1();
      vx_core::vx_reserve_type(vx_core::t_minus_1);
      vx_core::e_minus = new vx_core::Class_minus();
      vx_core::vx_reserve_empty(vx_core::e_minus);
      vx_core::t_minus = new vx_core::Class_minus();
      vx_core::vx_reserve_type(vx_core::t_minus);
      vx_core::e_minus1 = new vx_core::Class_minus1();
      vx_core::vx_reserve_empty(vx_core::e_minus1);
      vx_core::t_minus1 = new vx_core::Class_minus1();
      vx_core::vx_reserve_type(vx_core::t_minus1);
      vx_core::e_dotmethod = new vx_core::Class_dotmethod();
      vx_core::vx_reserve_empty(vx_core::e_dotmethod);
      vx_core::t_dotmethod = new vx_core::Class_dotmethod();
      vx_core::vx_reserve_type(vx_core::t_dotmethod);
      vx_core::e_divide = new vx_core::Class_divide();
      vx_core::vx_reserve_empty(vx_core::e_divide);
      vx_core::t_divide = new vx_core::Class_divide();
      vx_core::vx_reserve_type(vx_core::t_divide);
      vx_core::e_lt_1 = new vx_core::Class_lt_1();
      vx_core::vx_reserve_empty(vx_core::e_lt_1);
      vx_core::t_lt_1 = new vx_core::Class_lt_1();
      vx_core::vx_reserve_type(vx_core::t_lt_1);
      vx_core::e_lt = new vx_core::Class_lt();
      vx_core::vx_reserve_empty(vx_core::e_lt);
      vx_core::t_lt = new vx_core::Class_lt();
      vx_core::vx_reserve_type(vx_core::t_lt);
      vx_core::e_chainfirst = new vx_core::Class_chainfirst();
      vx_core::vx_reserve_empty(vx_core::e_chainfirst);
      vx_core::t_chainfirst = new vx_core::Class_chainfirst();
      vx_core::vx_reserve_type(vx_core::t_chainfirst);
      vx_core::e_chainlast = new vx_core::Class_chainlast();
      vx_core::vx_reserve_empty(vx_core::e_chainlast);
      vx_core::t_chainlast = new vx_core::Class_chainlast();
      vx_core::vx_reserve_type(vx_core::t_chainlast);
      vx_core::e_le_1 = new vx_core::Class_le_1();
      vx_core::vx_reserve_empty(vx_core::e_le_1);
      vx_core::t_le_1 = new vx_core::Class_le_1();
      vx_core::vx_reserve_type(vx_core::t_le_1);
      vx_core::e_le = new vx_core::Class_le();
      vx_core::vx_reserve_empty(vx_core::e_le);
      vx_core::t_le = new vx_core::Class_le();
      vx_core::vx_reserve_type(vx_core::t_le);
      vx_core::e_eqeq = new vx_core::Class_eqeq();
      vx_core::vx_reserve_empty(vx_core::e_eqeq);
      vx_core::t_eqeq = new vx_core::Class_eqeq();
      vx_core::vx_reserve_type(vx_core::t_eqeq);
      vx_core::e_gt_1 = new vx_core::Class_gt_1();
      vx_core::vx_reserve_empty(vx_core::e_gt_1);
      vx_core::t_gt_1 = new vx_core::Class_gt_1();
      vx_core::vx_reserve_type(vx_core::t_gt_1);
      vx_core::e_gt = new vx_core::Class_gt();
      vx_core::vx_reserve_empty(vx_core::e_gt);
      vx_core::t_gt = new vx_core::Class_gt();
      vx_core::vx_reserve_type(vx_core::t_gt);
      vx_core::e_ge_1 = new vx_core::Class_ge_1();
      vx_core::vx_reserve_empty(vx_core::e_ge_1);
      vx_core::t_ge_1 = new vx_core::Class_ge_1();
      vx_core::vx_reserve_type(vx_core::t_ge_1);
      vx_core::e_ge = new vx_core::Class_ge();
      vx_core::vx_reserve_empty(vx_core::e_ge);
      vx_core::t_ge = new vx_core::Class_ge();
      vx_core::vx_reserve_type(vx_core::t_ge);
      vx_core::e_allowfuncs_from_security = new vx_core::Class_allowfuncs_from_security();
      vx_core::vx_reserve_empty(vx_core::e_allowfuncs_from_security);
      vx_core::t_allowfuncs_from_security = new vx_core::Class_allowfuncs_from_security();
      vx_core::vx_reserve_type(vx_core::t_allowfuncs_from_security);
      vx_core::e_allowtypenames_from_typedef = new vx_core::Class_allowtypenames_from_typedef();
      vx_core::vx_reserve_empty(vx_core::e_allowtypenames_from_typedef);
      vx_core::t_allowtypenames_from_typedef = new vx_core::Class_allowtypenames_from_typedef();
      vx_core::vx_reserve_type(vx_core::t_allowtypenames_from_typedef);
      vx_core::e_allowtypes_from_typedef = new vx_core::Class_allowtypes_from_typedef();
      vx_core::vx_reserve_empty(vx_core::e_allowtypes_from_typedef);
      vx_core::t_allowtypes_from_typedef = new vx_core::Class_allowtypes_from_typedef();
      vx_core::vx_reserve_type(vx_core::t_allowtypes_from_typedef);
      vx_core::e_any_from_any_key_value = new vx_core::Class_any_from_any_key_value();
      vx_core::vx_reserve_empty(vx_core::e_any_from_any_key_value);
      vx_core::t_any_from_any_key_value = new vx_core::Class_any_from_any_key_value();
      vx_core::vx_reserve_type(vx_core::t_any_from_any_key_value);
      vx_core::e_any_from_int = new vx_core::Class_any_from_int();
      vx_core::vx_reserve_empty(vx_core::e_any_from_int);
      vx_core::t_any_from_int = new vx_core::Class_any_from_int();
      vx_core::vx_reserve_type(vx_core::t_any_from_int);
      vx_core::e_any_from_int_any = new vx_core::Class_any_from_int_any();
      vx_core::vx_reserve_empty(vx_core::e_any_from_int_any);
      vx_core::t_any_from_int_any = new vx_core::Class_any_from_int_any();
      vx_core::vx_reserve_type(vx_core::t_any_from_int_any);
      vx_core::e_any_from_map_start_reduce = new vx_core::Class_any_from_map_start_reduce();
      vx_core::vx_reserve_empty(vx_core::e_any_from_map_start_reduce);
      vx_core::t_any_from_map_start_reduce = new vx_core::Class_any_from_map_start_reduce();
      vx_core::vx_reserve_type(vx_core::t_any_from_map_start_reduce);
      vx_core::e_boolean_permission_from_func = new vx_core::Class_boolean_permission_from_func();
      vx_core::vx_reserve_empty(vx_core::e_boolean_permission_from_func);
      vx_core::t_boolean_permission_from_func = new vx_core::Class_boolean_permission_from_func();
      vx_core::vx_reserve_type(vx_core::t_boolean_permission_from_func);
      vx_core::e_boolean_write_from_map_name_value = new vx_core::Class_boolean_write_from_map_name_value();
      vx_core::vx_reserve_empty(vx_core::e_boolean_write_from_map_name_value);
      vx_core::t_boolean_write_from_map_name_value = new vx_core::Class_boolean_write_from_map_name_value();
      vx_core::vx_reserve_type(vx_core::t_boolean_write_from_map_name_value);
      vx_core::e_compare = new vx_core::Class_compare();
      vx_core::vx_reserve_empty(vx_core::e_compare);
      vx_core::t_compare = new vx_core::Class_compare();
      vx_core::vx_reserve_type(vx_core::t_compare);
      vx_core::e_contains_1 = new vx_core::Class_contains_1();
      vx_core::vx_reserve_empty(vx_core::e_contains_1);
      vx_core::t_contains_1 = new vx_core::Class_contains_1();
      vx_core::vx_reserve_type(vx_core::t_contains_1);
      vx_core::e_contains = new vx_core::Class_contains();
      vx_core::vx_reserve_empty(vx_core::e_contains);
      vx_core::t_contains = new vx_core::Class_contains();
      vx_core::vx_reserve_type(vx_core::t_contains);
      vx_core::e_context_main = new vx_core::Class_context_main();
      vx_core::vx_reserve_empty(vx_core::e_context_main);
      vx_core::t_context_main = new vx_core::Class_context_main();
      vx_core::vx_reserve_type(vx_core::t_context_main);
      vx_core::e_extends_from_any = new vx_core::Class_extends_from_any();
      vx_core::vx_reserve_empty(vx_core::e_extends_from_any);
      vx_core::t_extends_from_any = new vx_core::Class_extends_from_any();
      vx_core::vx_reserve_type(vx_core::t_extends_from_any);
      vx_core::e_extends_from_typedef = new vx_core::Class_extends_from_typedef();
      vx_core::vx_reserve_empty(vx_core::e_extends_from_typedef);
      vx_core::t_extends_from_typedef = new vx_core::Class_extends_from_typedef();
      vx_core::vx_reserve_type(vx_core::t_extends_from_typedef);
      vx_core::e_first_from_list = new vx_core::Class_first_from_list();
      vx_core::vx_reserve_empty(vx_core::e_first_from_list);
      vx_core::t_first_from_list = new vx_core::Class_first_from_list();
      vx_core::vx_reserve_type(vx_core::t_first_from_list);
      vx_core::e_first_from_list_any_from_any = new vx_core::Class_first_from_list_any_from_any();
      vx_core::vx_reserve_empty(vx_core::e_first_from_list_any_from_any);
      vx_core::t_first_from_list_any_from_any = new vx_core::Class_first_from_list_any_from_any();
      vx_core::vx_reserve_type(vx_core::t_first_from_list_any_from_any);
      vx_core::e_float_from_string = new vx_core::Class_float_from_string();
      vx_core::vx_reserve_empty(vx_core::e_float_from_string);
      vx_core::t_float_from_string = new vx_core::Class_float_from_string();
      vx_core::vx_reserve_type(vx_core::t_float_from_string);
      vx_core::e_fn = new vx_core::Class_fn();
      vx_core::vx_reserve_empty(vx_core::e_fn);
      vx_core::t_fn = new vx_core::Class_fn();
      vx_core::vx_reserve_type(vx_core::t_fn);
      vx_core::e_funcdef_from_func = new vx_core::Class_funcdef_from_func();
      vx_core::vx_reserve_empty(vx_core::e_funcdef_from_func);
      vx_core::t_funcdef_from_func = new vx_core::Class_funcdef_from_func();
      vx_core::vx_reserve_type(vx_core::t_funcdef_from_func);
      vx_core::e_funcname_from_funcdef = new vx_core::Class_funcname_from_funcdef();
      vx_core::vx_reserve_empty(vx_core::e_funcname_from_funcdef);
      vx_core::t_funcname_from_funcdef = new vx_core::Class_funcname_from_funcdef();
      vx_core::vx_reserve_type(vx_core::t_funcname_from_funcdef);
      vx_core::e_int_from_func = new vx_core::Class_int_from_func();
      vx_core::vx_reserve_empty(vx_core::e_int_from_func);
      vx_core::t_int_from_func = new vx_core::Class_int_from_func();
      vx_core::vx_reserve_type(vx_core::t_int_from_func);
      vx_core::e_int_from_string = new vx_core::Class_int_from_string();
      vx_core::vx_reserve_empty(vx_core::e_int_from_string);
      vx_core::t_int_from_string = new vx_core::Class_int_from_string();
      vx_core::vx_reserve_type(vx_core::t_int_from_string);
      vx_core::e_is_endswith = new vx_core::Class_is_endswith();
      vx_core::vx_reserve_empty(vx_core::e_is_endswith);
      vx_core::t_is_endswith = new vx_core::Class_is_endswith();
      vx_core::vx_reserve_type(vx_core::t_is_endswith);
      vx_core::e_is_float = new vx_core::Class_is_float();
      vx_core::vx_reserve_empty(vx_core::e_is_float);
      vx_core::t_is_float = new vx_core::Class_is_float();
      vx_core::vx_reserve_type(vx_core::t_is_float);
      vx_core::e_is_func = new vx_core::Class_is_func();
      vx_core::vx_reserve_empty(vx_core::e_is_func);
      vx_core::t_is_func = new vx_core::Class_is_func();
      vx_core::vx_reserve_type(vx_core::t_is_func);
      vx_core::e_is_int = new vx_core::Class_is_int();
      vx_core::vx_reserve_empty(vx_core::e_is_int);
      vx_core::t_is_int = new vx_core::Class_is_int();
      vx_core::vx_reserve_type(vx_core::t_is_int);
      vx_core::e_is_number = new vx_core::Class_is_number();
      vx_core::vx_reserve_empty(vx_core::e_is_number);
      vx_core::t_is_number = new vx_core::Class_is_number();
      vx_core::vx_reserve_type(vx_core::t_is_number);
      vx_core::e_is_pass_from_permission = new vx_core::Class_is_pass_from_permission();
      vx_core::vx_reserve_empty(vx_core::e_is_pass_from_permission);
      vx_core::t_is_pass_from_permission = new vx_core::Class_is_pass_from_permission();
      vx_core::vx_reserve_type(vx_core::t_is_pass_from_permission);
      vx_core::e_last_from_list = new vx_core::Class_last_from_list();
      vx_core::vx_reserve_empty(vx_core::e_last_from_list);
      vx_core::t_last_from_list = new vx_core::Class_last_from_list();
      vx_core::vx_reserve_type(vx_core::t_last_from_list);
      vx_core::e_list_join_from_list_1 = new vx_core::Class_list_join_from_list_1();
      vx_core::vx_reserve_empty(vx_core::e_list_join_from_list_1);
      vx_core::t_list_join_from_list_1 = new vx_core::Class_list_join_from_list_1();
      vx_core::vx_reserve_type(vx_core::t_list_join_from_list_1);
      vx_core::e_list_join_from_list = new vx_core::Class_list_join_from_list();
      vx_core::vx_reserve_empty(vx_core::e_list_join_from_list);
      vx_core::t_list_join_from_list = new vx_core::Class_list_join_from_list();
      vx_core::vx_reserve_type(vx_core::t_list_join_from_list);
      vx_core::e_list_from_list_1 = new vx_core::Class_list_from_list_1();
      vx_core::vx_reserve_empty(vx_core::e_list_from_list_1);
      vx_core::t_list_from_list_1 = new vx_core::Class_list_from_list_1();
      vx_core::vx_reserve_type(vx_core::t_list_from_list_1);
      vx_core::e_list_from_list = new vx_core::Class_list_from_list();
      vx_core::vx_reserve_empty(vx_core::e_list_from_list);
      vx_core::t_list_from_list = new vx_core::Class_list_from_list();
      vx_core::vx_reserve_type(vx_core::t_list_from_list);
      vx_core::e_list_from_list_async = new vx_core::Class_list_from_list_async();
      vx_core::vx_reserve_empty(vx_core::e_list_from_list_async);
      vx_core::t_list_from_list_async = new vx_core::Class_list_from_list_async();
      vx_core::vx_reserve_type(vx_core::t_list_from_list_async);
      vx_core::e_list_from_list_intany = new vx_core::Class_list_from_list_intany();
      vx_core::vx_reserve_empty(vx_core::e_list_from_list_intany);
      vx_core::t_list_from_list_intany = new vx_core::Class_list_from_list_intany();
      vx_core::vx_reserve_type(vx_core::t_list_from_list_intany);
      vx_core::e_list_from_map_1 = new vx_core::Class_list_from_map_1();
      vx_core::vx_reserve_empty(vx_core::e_list_from_map_1);
      vx_core::t_list_from_map_1 = new vx_core::Class_list_from_map_1();
      vx_core::vx_reserve_type(vx_core::t_list_from_map_1);
      vx_core::e_list_from_map = new vx_core::Class_list_from_map();
      vx_core::vx_reserve_empty(vx_core::e_list_from_map);
      vx_core::t_list_from_map = new vx_core::Class_list_from_map();
      vx_core::vx_reserve_type(vx_core::t_list_from_map);
      vx_core::e_list_from_map_async = new vx_core::Class_list_from_map_async();
      vx_core::vx_reserve_empty(vx_core::e_list_from_map_async);
      vx_core::t_list_from_map_async = new vx_core::Class_list_from_map_async();
      vx_core::vx_reserve_type(vx_core::t_list_from_map_async);
      vx_core::e_list_from_type = new vx_core::Class_list_from_type();
      vx_core::vx_reserve_empty(vx_core::e_list_from_type);
      vx_core::t_list_from_type = new vx_core::Class_list_from_type();
      vx_core::vx_reserve_type(vx_core::t_list_from_type);
      vx_core::e_log_1 = new vx_core::Class_log_1();
      vx_core::vx_reserve_empty(vx_core::e_log_1);
      vx_core::t_log_1 = new vx_core::Class_log_1();
      vx_core::vx_reserve_type(vx_core::t_log_1);
      vx_core::e_log = new vx_core::Class_log();
      vx_core::vx_reserve_empty(vx_core::e_log);
      vx_core::t_log = new vx_core::Class_log();
      vx_core::vx_reserve_type(vx_core::t_log);
      vx_core::e_main = new vx_core::Class_main();
      vx_core::vx_reserve_empty(vx_core::e_main);
      vx_core::t_main = new vx_core::Class_main();
      vx_core::vx_reserve_type(vx_core::t_main);
      vx_core::e_map_from_list = new vx_core::Class_map_from_list();
      vx_core::vx_reserve_empty(vx_core::e_map_from_list);
      vx_core::t_map_from_list = new vx_core::Class_map_from_list();
      vx_core::vx_reserve_type(vx_core::t_map_from_list);
      vx_core::e_map_from_map_1 = new vx_core::Class_map_from_map_1();
      vx_core::vx_reserve_empty(vx_core::e_map_from_map_1);
      vx_core::t_map_from_map_1 = new vx_core::Class_map_from_map_1();
      vx_core::vx_reserve_type(vx_core::t_map_from_map_1);
      vx_core::e_map_from_map = new vx_core::Class_map_from_map();
      vx_core::vx_reserve_empty(vx_core::e_map_from_map);
      vx_core::t_map_from_map = new vx_core::Class_map_from_map();
      vx_core::vx_reserve_type(vx_core::t_map_from_map);
      vx_core::e_msg_from_error_2 = new vx_core::Class_msg_from_error_2();
      vx_core::vx_reserve_empty(vx_core::e_msg_from_error_2);
      vx_core::t_msg_from_error_2 = new vx_core::Class_msg_from_error_2();
      vx_core::vx_reserve_type(vx_core::t_msg_from_error_2);
      vx_core::e_msg_from_error_1 = new vx_core::Class_msg_from_error_1();
      vx_core::vx_reserve_empty(vx_core::e_msg_from_error_1);
      vx_core::t_msg_from_error_1 = new vx_core::Class_msg_from_error_1();
      vx_core::vx_reserve_type(vx_core::t_msg_from_error_1);
      vx_core::e_msg_from_error = new vx_core::Class_msg_from_error();
      vx_core::vx_reserve_empty(vx_core::e_msg_from_error);
      vx_core::t_msg_from_error = new vx_core::Class_msg_from_error();
      vx_core::vx_reserve_type(vx_core::t_msg_from_error);
      vx_core::e_msg_from_warning = new vx_core::Class_msg_from_warning();
      vx_core::vx_reserve_empty(vx_core::e_msg_from_warning);
      vx_core::t_msg_from_warning = new vx_core::Class_msg_from_warning();
      vx_core::vx_reserve_type(vx_core::t_msg_from_warning);
      vx_core::e_msgblock_from_msgblock_msg = new vx_core::Class_msgblock_from_msgblock_msg();
      vx_core::vx_reserve_empty(vx_core::e_msgblock_from_msgblock_msg);
      vx_core::t_msgblock_from_msgblock_msg = new vx_core::Class_msgblock_from_msgblock_msg();
      vx_core::vx_reserve_type(vx_core::t_msgblock_from_msgblock_msg);
      vx_core::e_msgblock_from_msgblock_msgblock = new vx_core::Class_msgblock_from_msgblock_msgblock();
      vx_core::vx_reserve_empty(vx_core::e_msgblock_from_msgblock_msgblock);
      vx_core::t_msgblock_from_msgblock_msgblock = new vx_core::Class_msgblock_from_msgblock_msgblock();
      vx_core::vx_reserve_type(vx_core::t_msgblock_from_msgblock_msgblock);
      vx_core::e_name_from_typedef = new vx_core::Class_name_from_typedef();
      vx_core::vx_reserve_empty(vx_core::e_name_from_typedef);
      vx_core::t_name_from_typedef = new vx_core::Class_name_from_typedef();
      vx_core::vx_reserve_type(vx_core::t_name_from_typedef);
      vx_core::e_native = new vx_core::Class_native();
      vx_core::vx_reserve_empty(vx_core::e_native);
      vx_core::t_native = new vx_core::Class_native();
      vx_core::vx_reserve_type(vx_core::t_native);
      vx_core::e_native_from_any = new vx_core::Class_native_from_any();
      vx_core::vx_reserve_empty(vx_core::e_native_from_any);
      vx_core::t_native_from_any = new vx_core::Class_native_from_any();
      vx_core::vx_reserve_type(vx_core::t_native_from_any);
      vx_core::e_new_from_type = new vx_core::Class_new_from_type();
      vx_core::vx_reserve_empty(vx_core::e_new_from_type);
      vx_core::t_new_from_type = new vx_core::Class_new_from_type();
      vx_core::vx_reserve_type(vx_core::t_new_from_type);
      vx_core::e_number_from_func = new vx_core::Class_number_from_func();
      vx_core::vx_reserve_empty(vx_core::e_number_from_func);
      vx_core::t_number_from_func = new vx_core::Class_number_from_func();
      vx_core::vx_reserve_type(vx_core::t_number_from_func);
      vx_core::e_package_global_from_name = new vx_core::Class_package_global_from_name();
      vx_core::vx_reserve_empty(vx_core::e_package_global_from_name);
      vx_core::t_package_global_from_name = new vx_core::Class_package_global_from_name();
      vx_core::vx_reserve_type(vx_core::t_package_global_from_name);
      vx_core::e_packagename_from_typedef = new vx_core::Class_packagename_from_typedef();
      vx_core::vx_reserve_empty(vx_core::e_packagename_from_typedef);
      vx_core::t_packagename_from_typedef = new vx_core::Class_packagename_from_typedef();
      vx_core::vx_reserve_type(vx_core::t_packagename_from_typedef);
      vx_core::e_path_from_context_path = new vx_core::Class_path_from_context_path();
      vx_core::vx_reserve_empty(vx_core::e_path_from_context_path);
      vx_core::t_path_from_context_path = new vx_core::Class_path_from_context_path();
      vx_core::vx_reserve_type(vx_core::t_path_from_context_path);
      vx_core::e_path_from_setting_path = new vx_core::Class_path_from_setting_path();
      vx_core::vx_reserve_empty(vx_core::e_path_from_setting_path);
      vx_core::t_path_from_setting_path = new vx_core::Class_path_from_setting_path();
      vx_core::vx_reserve_type(vx_core::t_path_from_setting_path);
      vx_core::e_permission_from_id_context = new vx_core::Class_permission_from_id_context();
      vx_core::vx_reserve_empty(vx_core::e_permission_from_id_context);
      vx_core::t_permission_from_id_context = new vx_core::Class_permission_from_id_context();
      vx_core::vx_reserve_type(vx_core::t_permission_from_id_context);
      vx_core::e_properties_from_typedef = new vx_core::Class_properties_from_typedef();
      vx_core::vx_reserve_empty(vx_core::e_properties_from_typedef);
      vx_core::t_properties_from_typedef = new vx_core::Class_properties_from_typedef();
      vx_core::vx_reserve_type(vx_core::t_properties_from_typedef);
      vx_core::e_proplast_from_typedef = new vx_core::Class_proplast_from_typedef();
      vx_core::vx_reserve_empty(vx_core::e_proplast_from_typedef);
      vx_core::t_proplast_from_typedef = new vx_core::Class_proplast_from_typedef();
      vx_core::vx_reserve_type(vx_core::t_proplast_from_typedef);
      vx_core::e_resolve_1 = new vx_core::Class_resolve_1();
      vx_core::vx_reserve_empty(vx_core::e_resolve_1);
      vx_core::t_resolve_1 = new vx_core::Class_resolve_1();
      vx_core::vx_reserve_type(vx_core::t_resolve_1);
      vx_core::e_resolve = new vx_core::Class_resolve();
      vx_core::vx_reserve_empty(vx_core::e_resolve);
      vx_core::t_resolve = new vx_core::Class_resolve();
      vx_core::vx_reserve_type(vx_core::t_resolve);
      vx_core::e_resolve_async = new vx_core::Class_resolve_async();
      vx_core::vx_reserve_empty(vx_core::e_resolve_async);
      vx_core::t_resolve_async = new vx_core::Class_resolve_async();
      vx_core::vx_reserve_type(vx_core::t_resolve_async);
      vx_core::e_resolve_first = new vx_core::Class_resolve_first();
      vx_core::vx_reserve_empty(vx_core::e_resolve_first);
      vx_core::t_resolve_first = new vx_core::Class_resolve_first();
      vx_core::vx_reserve_type(vx_core::t_resolve_first);
      vx_core::e_resolve_list = new vx_core::Class_resolve_list();
      vx_core::vx_reserve_empty(vx_core::e_resolve_list);
      vx_core::t_resolve_list = new vx_core::Class_resolve_list();
      vx_core::vx_reserve_type(vx_core::t_resolve_list);
      vx_core::e_security_from_context = new vx_core::Class_security_from_context();
      vx_core::vx_reserve_empty(vx_core::e_security_from_context);
      vx_core::t_security_from_context = new vx_core::Class_security_from_context();
      vx_core::vx_reserve_type(vx_core::t_security_from_context);
      vx_core::e_security_from_user = new vx_core::Class_security_from_user();
      vx_core::vx_reserve_empty(vx_core::e_security_from_user);
      vx_core::t_security_from_user = new vx_core::Class_security_from_user();
      vx_core::vx_reserve_type(vx_core::t_security_from_user);
      vx_core::e_session_from_context = new vx_core::Class_session_from_context();
      vx_core::vx_reserve_empty(vx_core::e_session_from_context);
      vx_core::t_session_from_context = new vx_core::Class_session_from_context();
      vx_core::vx_reserve_type(vx_core::t_session_from_context);
      vx_core::e_setting_from_context = new vx_core::Class_setting_from_context();
      vx_core::vx_reserve_empty(vx_core::e_setting_from_context);
      vx_core::t_setting_from_context = new vx_core::Class_setting_from_context();
      vx_core::vx_reserve_type(vx_core::t_setting_from_context);
      vx_core::e_string_repeat = new vx_core::Class_string_repeat();
      vx_core::vx_reserve_empty(vx_core::e_string_repeat);
      vx_core::t_string_repeat = new vx_core::Class_string_repeat();
      vx_core::vx_reserve_type(vx_core::t_string_repeat);
      vx_core::e_string_from_any = new vx_core::Class_string_from_any();
      vx_core::vx_reserve_empty(vx_core::e_string_from_any);
      vx_core::t_string_from_any = new vx_core::Class_string_from_any();
      vx_core::vx_reserve_type(vx_core::t_string_from_any);
      vx_core::e_string_from_any_indent = new vx_core::Class_string_from_any_indent();
      vx_core::vx_reserve_empty(vx_core::e_string_from_any_indent);
      vx_core::t_string_from_any_indent = new vx_core::Class_string_from_any_indent();
      vx_core::vx_reserve_type(vx_core::t_string_from_any_indent);
      vx_core::e_string_from_func = new vx_core::Class_string_from_func();
      vx_core::vx_reserve_empty(vx_core::e_string_from_func);
      vx_core::t_string_from_func = new vx_core::Class_string_from_func();
      vx_core::vx_reserve_type(vx_core::t_string_from_func);
      vx_core::e_string_from_string_find_replace = new vx_core::Class_string_from_string_find_replace();
      vx_core::vx_reserve_empty(vx_core::e_string_from_string_find_replace);
      vx_core::t_string_from_string_find_replace = new vx_core::Class_string_from_string_find_replace();
      vx_core::vx_reserve_type(vx_core::t_string_from_string_find_replace);
      vx_core::e_stringlist_from_map = new vx_core::Class_stringlist_from_map();
      vx_core::vx_reserve_empty(vx_core::e_stringlist_from_map);
      vx_core::t_stringlist_from_map = new vx_core::Class_stringlist_from_map();
      vx_core::vx_reserve_type(vx_core::t_stringlist_from_map);
      vx_core::e_traits_from_typedef = new vx_core::Class_traits_from_typedef();
      vx_core::vx_reserve_empty(vx_core::e_traits_from_typedef);
      vx_core::t_traits_from_typedef = new vx_core::Class_traits_from_typedef();
      vx_core::vx_reserve_type(vx_core::t_traits_from_typedef);
      vx_core::e_type_from_any = new vx_core::Class_type_from_any();
      vx_core::vx_reserve_empty(vx_core::e_type_from_any);
      vx_core::t_type_from_any = new vx_core::Class_type_from_any();
      vx_core::vx_reserve_type(vx_core::t_type_from_any);
      vx_core::e_typedef_from_any = new vx_core::Class_typedef_from_any();
      vx_core::vx_reserve_empty(vx_core::e_typedef_from_any);
      vx_core::t_typedef_from_any = new vx_core::Class_typedef_from_any();
      vx_core::vx_reserve_type(vx_core::t_typedef_from_any);
      vx_core::e_typedef_from_type = new vx_core::Class_typedef_from_type();
      vx_core::vx_reserve_empty(vx_core::e_typedef_from_type);
      vx_core::t_typedef_from_type = new vx_core::Class_typedef_from_type();
      vx_core::vx_reserve_type(vx_core::t_typedef_from_type);
      vx_core::e_typename_from_any = new vx_core::Class_typename_from_any();
      vx_core::vx_reserve_empty(vx_core::e_typename_from_any);
      vx_core::t_typename_from_any = new vx_core::Class_typename_from_any();
      vx_core::vx_reserve_type(vx_core::t_typename_from_any);
      vx_core::e_typename_from_type = new vx_core::Class_typename_from_type();
      vx_core::vx_reserve_empty(vx_core::e_typename_from_type);
      vx_core::t_typename_from_type = new vx_core::Class_typename_from_type();
      vx_core::vx_reserve_type(vx_core::t_typename_from_type);
      vx_core::e_typename_from_typedef = new vx_core::Class_typename_from_typedef();
      vx_core::vx_reserve_empty(vx_core::e_typename_from_typedef);
      vx_core::t_typename_from_typedef = new vx_core::Class_typename_from_typedef();
      vx_core::vx_reserve_type(vx_core::t_typename_from_typedef);
      vx_core::e_typenames_from_typelist = new vx_core::Class_typenames_from_typelist();
      vx_core::vx_reserve_empty(vx_core::e_typenames_from_typelist);
      vx_core::t_typenames_from_typelist = new vx_core::Class_typenames_from_typelist();
      vx_core::vx_reserve_type(vx_core::t_typenames_from_typelist);
      vx_core::e_user_from_context = new vx_core::Class_user_from_context();
      vx_core::vx_reserve_empty(vx_core::e_user_from_context);
      vx_core::t_user_from_context = new vx_core::Class_user_from_context();
      vx_core::vx_reserve_type(vx_core::t_user_from_context);
      vx_core::Class_false::vx_const_new(vx_core::c_false);
      vx_core::Class_global::vx_const_new(vx_core::c_global);
      vx_core::Class_infinity::vx_const_new(vx_core::c_infinity);
      vx_core::Class_mempool_active::vx_const_new(vx_core::c_mempool_active);
      vx_core::Class_msg_error::vx_const_new(vx_core::c_msg_error);
      vx_core::Class_msg_info::vx_const_new(vx_core::c_msg_info);
      vx_core::Class_msg_severe::vx_const_new(vx_core::c_msg_severe);
      vx_core::Class_msg_warning::vx_const_new(vx_core::c_msg_warning);
      vx_core::Class_neginfinity::vx_const_new(vx_core::c_neginfinity);
      vx_core::Class_newline::vx_const_new(vx_core::c_newline);
      vx_core::Class_notanumber::vx_const_new(vx_core::c_notanumber);
      vx_core::Class_nothing::vx_const_new(vx_core::c_nothing);
      vx_core::Class_path_test_resources::vx_const_new(vx_core::c_path_test_resources);
      vx_core::Class_quote::vx_const_new(vx_core::c_quote);
      vx_core::Class_true::vx_const_new(vx_core::c_true);
      vx_core::vx_Type_mapany maptype;
      vx_core::vx_Type_mapany mapconst;
      vx_core::vx_Type_mapfunc mapfunc;
      vx_core::vx_Type_mapany mapempty;
      maptype["any"] = vx_core::t_any;
      maptype["list"] = vx_core::t_list;
      maptype["map"] = vx_core::t_map;
      maptype["struct"] = vx_core::t_struct;
      maptype["msg"] = vx_core::t_msg;
      maptype["msglist"] = vx_core::t_msglist;
      maptype["msgblock"] = vx_core::t_msgblock;
      maptype["msgblocklist"] = vx_core::t_msgblocklist;
      maptype["boolean"] = vx_core::t_boolean;
      maptype["number"] = vx_core::t_number;
      maptype["decimal"] = vx_core::t_decimal;
      maptype["float"] = vx_core::t_float;
      maptype["int"] = vx_core::t_int;
      maptype["string"] = vx_core::t_string;
      maptype["func"] = vx_core::t_func;
      maptype["typedef"] = vx_core::t_typedef;
      maptype["funcdef"] = vx_core::t_funcdef;
      maptype["any-async<-func"] = vx_core::t_any_async_from_func;
      maptype["any<-anylist"] = vx_core::t_any_from_anylist;
      maptype["anylist"] = vx_core::t_anylist;
      maptype["anymap"] = vx_core::t_anymap;
      maptype["anytype"] = vx_core::t_anytype;
      maptype["arg"] = vx_core::t_arg;
      maptype["arglist"] = vx_core::t_arglist;
      maptype["argmap"] = vx_core::t_argmap;
      maptype["booleanlist"] = vx_core::t_booleanlist;
      maptype["collection"] = vx_core::t_collection;
      maptype["compilelanguages"] = vx_core::t_compilelanguages;
      maptype["connect"] = vx_core::t_connect;
      maptype["connectlist"] = vx_core::t_connectlist;
      maptype["connectmap"] = vx_core::t_connectmap;
      maptype["const"] = vx_core::t_const;
      maptype["constdef"] = vx_core::t_constdef;
      maptype["constlist"] = vx_core::t_constlist;
      maptype["constmap"] = vx_core::t_constmap;
      maptype["context"] = vx_core::t_context;
      maptype["date"] = vx_core::t_date;
      maptype["error"] = vx_core::t_error;
      maptype["funclist"] = vx_core::t_funclist;
      maptype["funcmap"] = vx_core::t_funcmap;
      maptype["intlist"] = vx_core::t_intlist;
      maptype["intmap"] = vx_core::t_intmap;
      maptype["listtype"] = vx_core::t_listtype;
      maptype["locale"] = vx_core::t_locale;
      maptype["maptype"] = vx_core::t_maptype;
      maptype["mempool"] = vx_core::t_mempool;
      maptype["none"] = vx_core::t_none;
      maptype["notype"] = vx_core::t_notype;
      maptype["numberlist"] = vx_core::t_numberlist;
      maptype["numbermap"] = vx_core::t_numbermap;
      maptype["package"] = vx_core::t_package;
      maptype["packagemap"] = vx_core::t_packagemap;
      maptype["permission"] = vx_core::t_permission;
      maptype["permissionlist"] = vx_core::t_permissionlist;
      maptype["permissionmap"] = vx_core::t_permissionmap;
      maptype["project"] = vx_core::t_project;
      maptype["security"] = vx_core::t_security;
      maptype["session"] = vx_core::t_session;
      maptype["setting"] = vx_core::t_setting;
      maptype["state"] = vx_core::t_state;
      maptype["statelistener"] = vx_core::t_statelistener;
      maptype["statelistenermap"] = vx_core::t_statelistenermap;
      maptype["stringlist"] = vx_core::t_stringlist;
      maptype["stringlistlist"] = vx_core::t_stringlistlist;
      maptype["stringmap"] = vx_core::t_stringmap;
      maptype["stringmutablemap"] = vx_core::t_stringmutablemap;
      maptype["thenelse"] = vx_core::t_thenelse;
      maptype["thenelselist"] = vx_core::t_thenelselist;
      maptype["translation"] = vx_core::t_translation;
      maptype["translationlist"] = vx_core::t_translationlist;
      maptype["translationmap"] = vx_core::t_translationmap;
      maptype["type"] = vx_core::t_type;
      maptype["typelist"] = vx_core::t_typelist;
      maptype["typemap"] = vx_core::t_typemap;
      maptype["user"] = vx_core::t_user;
      maptype["value"] = vx_core::t_value;
      mapconst["false"] = vx_core::c_false;
      mapconst["global"] = vx_core::c_global;
      mapconst["infinity"] = vx_core::c_infinity;
      mapconst["mempool-active"] = vx_core::c_mempool_active;
      mapconst["msg-error"] = vx_core::c_msg_error;
      mapconst["msg-info"] = vx_core::c_msg_info;
      mapconst["msg-severe"] = vx_core::c_msg_severe;
      mapconst["msg-warning"] = vx_core::c_msg_warning;
      mapconst["neginfinity"] = vx_core::c_neginfinity;
      mapconst["newline"] = vx_core::c_newline;
      mapconst["notanumber"] = vx_core::c_notanumber;
      mapconst["nothing"] = vx_core::c_nothing;
      mapconst["path-test-resources"] = vx_core::c_path_test_resources;
      mapconst["quote"] = vx_core::c_quote;
      mapconst["true"] = vx_core::c_true;
      mapfunc["any<-any"] = vx_core::t_any_from_any;
      mapfunc["any<-any-async"] = vx_core::t_any_from_any_async;
      mapfunc["any<-any-context"] = vx_core::t_any_from_any_context;
      mapfunc["any<-any-context-async"] = vx_core::t_any_from_any_context_async;
      mapfunc["any<-func"] = vx_core::t_any_from_func;
      mapfunc["any<-func-async"] = vx_core::t_any_from_func_async;
      mapfunc["any<-key-value"] = vx_core::t_any_from_key_value;
      mapfunc["any<-key-value-async"] = vx_core::t_any_from_key_value_async;
      mapfunc["any<-list"] = vx_core::t_any_from_list;
      mapfunc["any<-list-start-reduce"] = vx_core::t_any_from_list_start_reduce;
      mapfunc["any<-list-start-reduce-next"] = vx_core::t_any_from_list_start_reduce_next;
      mapfunc["any<-map"] = vx_core::t_any_from_map;
      mapfunc["any<-none"] = vx_core::t_any_from_none;
      mapfunc["any<-none-async"] = vx_core::t_any_from_none_async;
      mapfunc["any<-reduce"] = vx_core::t_any_from_reduce;
      mapfunc["any<-reduce-async"] = vx_core::t_any_from_reduce_async;
      mapfunc["any<-reduce-next"] = vx_core::t_any_from_reduce_next;
      mapfunc["any<-reduce-next-async"] = vx_core::t_any_from_reduce_next_async;
      mapfunc["any<-struct"] = vx_core::t_any_from_struct;
      mapfunc["async"] = vx_core::t_async;
      mapfunc["boolean<-any"] = vx_core::t_boolean_from_any;
      mapfunc["boolean<-func"] = vx_core::t_boolean_from_func;
      mapfunc["boolean<-none"] = vx_core::t_boolean_from_none;
      mapfunc["empty"] = vx_core::t_empty;
      mapfunc["new"] = vx_core::t_new;
      mapfunc["copy"] = vx_core::t_copy;
      mapfunc["is-empty"] = vx_core::t_is_empty;
      mapfunc["is-empty_1"] = vx_core::t_is_empty_1;
      mapfunc["!"] = vx_core::t_not;
      mapfunc["!-empty"] = vx_core::t_notempty;
      mapfunc["!-empty_1"] = vx_core::t_notempty_1;
      mapfunc["="] = vx_core::t_eq;
      mapfunc["=_1"] = vx_core::t_eq_1;
      mapfunc["!="] = vx_core::t_ne;
      mapfunc["then"] = vx_core::t_then;
      mapfunc["else"] = vx_core::t_else;
      mapfunc["if"] = vx_core::t_if;
      mapfunc["if_1"] = vx_core::t_if_1;
      mapfunc["if_2"] = vx_core::t_if_2;
      mapfunc["case"] = vx_core::t_case;
      mapfunc["case_1"] = vx_core::t_case_1;
      mapfunc["switch"] = vx_core::t_switch;
      mapfunc["length"] = vx_core::t_length;
      mapfunc["length_1"] = vx_core::t_length_1;
      mapfunc["length_2"] = vx_core::t_length_2;
      mapfunc["and"] = vx_core::t_and;
      mapfunc["and_1"] = vx_core::t_and_1;
      mapfunc["or"] = vx_core::t_or;
      mapfunc["or_1"] = vx_core::t_or_1;
      mapfunc["let"] = vx_core::t_let;
      mapfunc["let-async"] = vx_core::t_let_async;
      mapfunc["!=="] = vx_core::t_neqeq;
      mapfunc["*_3"] = vx_core::t_multiply_3;
      mapfunc["*_2"] = vx_core::t_multiply_2;
      mapfunc["*_1"] = vx_core::t_multiply_1;
      mapfunc["*"] = vx_core::t_multiply;
      mapfunc["+_3"] = vx_core::t_plus_3;
      mapfunc["+_2"] = vx_core::t_plus_2;
      mapfunc["+_1"] = vx_core::t_plus_1;
      mapfunc["+"] = vx_core::t_plus;
      mapfunc["+1"] = vx_core::t_plus1;
      mapfunc["-_3"] = vx_core::t_minus_3;
      mapfunc["-_2"] = vx_core::t_minus_2;
      mapfunc["-_1"] = vx_core::t_minus_1;
      mapfunc["-"] = vx_core::t_minus;
      mapfunc["-1"] = vx_core::t_minus1;
      mapfunc["."] = vx_core::t_dotmethod;
      mapfunc["/"] = vx_core::t_divide;
      mapfunc["<_1"] = vx_core::t_lt_1;
      mapfunc["<"] = vx_core::t_lt;
      mapfunc["<-"] = vx_core::t_chainfirst;
      mapfunc["<<-"] = vx_core::t_chainlast;
      mapfunc["<=_1"] = vx_core::t_le_1;
      mapfunc["<="] = vx_core::t_le;
      mapfunc["=="] = vx_core::t_eqeq;
      mapfunc[">_1"] = vx_core::t_gt_1;
      mapfunc[">"] = vx_core::t_gt;
      mapfunc[">=_1"] = vx_core::t_ge_1;
      mapfunc[">="] = vx_core::t_ge;
      mapfunc["allowfuncs<-security"] = vx_core::t_allowfuncs_from_security;
      mapfunc["allowtypenames<-typedef"] = vx_core::t_allowtypenames_from_typedef;
      mapfunc["allowtypes<-typedef"] = vx_core::t_allowtypes_from_typedef;
      mapfunc["any<-any-key-value"] = vx_core::t_any_from_any_key_value;
      mapfunc["any<-int"] = vx_core::t_any_from_int;
      mapfunc["any<-int-any"] = vx_core::t_any_from_int_any;
      mapfunc["any<-map-start-reduce"] = vx_core::t_any_from_map_start_reduce;
      mapfunc["boolean-permission<-func"] = vx_core::t_boolean_permission_from_func;
      mapfunc["boolean-write<-map-name-value"] = vx_core::t_boolean_write_from_map_name_value;
      mapfunc["compare"] = vx_core::t_compare;
      mapfunc["contains_1"] = vx_core::t_contains_1;
      mapfunc["contains"] = vx_core::t_contains;
      mapfunc["context-main"] = vx_core::t_context_main;
      mapfunc["extends<-any"] = vx_core::t_extends_from_any;
      mapfunc["extends<-typedef"] = vx_core::t_extends_from_typedef;
      mapfunc["first<-list"] = vx_core::t_first_from_list;
      mapfunc["first<-list-any<-any"] = vx_core::t_first_from_list_any_from_any;
      mapfunc["float<-string"] = vx_core::t_float_from_string;
      mapfunc["fn"] = vx_core::t_fn;
      mapfunc["funcdef<-func"] = vx_core::t_funcdef_from_func;
      mapfunc["funcname<-funcdef"] = vx_core::t_funcname_from_funcdef;
      mapfunc["int<-func"] = vx_core::t_int_from_func;
      mapfunc["int<-string"] = vx_core::t_int_from_string;
      mapfunc["is-endswith"] = vx_core::t_is_endswith;
      mapfunc["is-float"] = vx_core::t_is_float;
      mapfunc["is-func"] = vx_core::t_is_func;
      mapfunc["is-int"] = vx_core::t_is_int;
      mapfunc["is-number"] = vx_core::t_is_number;
      mapfunc["is-pass<-permission"] = vx_core::t_is_pass_from_permission;
      mapfunc["last<-list"] = vx_core::t_last_from_list;
      mapfunc["list-join<-list_1"] = vx_core::t_list_join_from_list_1;
      mapfunc["list-join<-list"] = vx_core::t_list_join_from_list;
      mapfunc["list<-list_1"] = vx_core::t_list_from_list_1;
      mapfunc["list<-list"] = vx_core::t_list_from_list;
      mapfunc["list<-list-async"] = vx_core::t_list_from_list_async;
      mapfunc["list<-list-intany"] = vx_core::t_list_from_list_intany;
      mapfunc["list<-map_1"] = vx_core::t_list_from_map_1;
      mapfunc["list<-map"] = vx_core::t_list_from_map;
      mapfunc["list<-map-async"] = vx_core::t_list_from_map_async;
      mapfunc["list<-type"] = vx_core::t_list_from_type;
      mapfunc["log_1"] = vx_core::t_log_1;
      mapfunc["log"] = vx_core::t_log;
      mapfunc["main"] = vx_core::t_main;
      mapfunc["map<-list"] = vx_core::t_map_from_list;
      mapfunc["map<-map_1"] = vx_core::t_map_from_map_1;
      mapfunc["map<-map"] = vx_core::t_map_from_map;
      mapfunc["msg<-error_2"] = vx_core::t_msg_from_error_2;
      mapfunc["msg<-error_1"] = vx_core::t_msg_from_error_1;
      mapfunc["msg<-error"] = vx_core::t_msg_from_error;
      mapfunc["msg<-warning"] = vx_core::t_msg_from_warning;
      mapfunc["msgblock<-msgblock-msg"] = vx_core::t_msgblock_from_msgblock_msg;
      mapfunc["msgblock<-msgblock-msgblock"] = vx_core::t_msgblock_from_msgblock_msgblock;
      mapfunc["name<-typedef"] = vx_core::t_name_from_typedef;
      mapfunc["native"] = vx_core::t_native;
      mapfunc["native<-any"] = vx_core::t_native_from_any;
      mapfunc["new<-type"] = vx_core::t_new_from_type;
      mapfunc["number<-func"] = vx_core::t_number_from_func;
      mapfunc["package-global<-name"] = vx_core::t_package_global_from_name;
      mapfunc["packagename<-typedef"] = vx_core::t_packagename_from_typedef;
      mapfunc["path<-context-path"] = vx_core::t_path_from_context_path;
      mapfunc["path<-setting-path"] = vx_core::t_path_from_setting_path;
      mapfunc["permission<-id-context"] = vx_core::t_permission_from_id_context;
      mapfunc["properties<-typedef"] = vx_core::t_properties_from_typedef;
      mapfunc["proplast<-typedef"] = vx_core::t_proplast_from_typedef;
      mapfunc["resolve_1"] = vx_core::t_resolve_1;
      mapfunc["resolve"] = vx_core::t_resolve;
      mapfunc["resolve-async"] = vx_core::t_resolve_async;
      mapfunc["resolve-first"] = vx_core::t_resolve_first;
      mapfunc["resolve-list"] = vx_core::t_resolve_list;
      mapfunc["security<-context"] = vx_core::t_security_from_context;
      mapfunc["security<-user"] = vx_core::t_security_from_user;
      mapfunc["session<-context"] = vx_core::t_session_from_context;
      mapfunc["setting<-context"] = vx_core::t_setting_from_context;
      mapfunc["string-repeat"] = vx_core::t_string_repeat;
      mapfunc["string<-any"] = vx_core::t_string_from_any;
      mapfunc["string<-any-indent"] = vx_core::t_string_from_any_indent;
      mapfunc["string<-func"] = vx_core::t_string_from_func;
      mapfunc["string<-string-find-replace"] = vx_core::t_string_from_string_find_replace;
      mapfunc["stringlist<-map"] = vx_core::t_stringlist_from_map;
      mapfunc["traits<-typedef"] = vx_core::t_traits_from_typedef;
      mapfunc["type<-any"] = vx_core::t_type_from_any;
      mapfunc["typedef<-any"] = vx_core::t_typedef_from_any;
      mapfunc["typedef<-type"] = vx_core::t_typedef_from_type;
      mapfunc["typename<-any"] = vx_core::t_typename_from_any;
      mapfunc["typename<-type"] = vx_core::t_typename_from_type;
      mapfunc["typename<-typedef"] = vx_core::t_typename_from_typedef;
      mapfunc["typenames<-typelist"] = vx_core::t_typenames_from_typelist;
      mapfunc["user<-context"] = vx_core::t_user_from_context;
      vx_core::vx_global_package_set("vx/core", maptype, mapconst, mapfunc);
	   }
  // }

}
