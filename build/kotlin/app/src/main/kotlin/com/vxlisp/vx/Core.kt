package com.vxlisp.vx

import java.util.concurrent.CompletableFuture

object vx_core {

  interface Type_replfunc {
    fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any
  }

  interface Type_replfunc_async {
    fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any>
  }

  val emptylistany : List<vx_core.Type_any> = ArrayList<vx_core.Type_any>()

  val emptymapany : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

  fun <T> immutablelist(
    listany : List<T>) : List<T> {
    return listany.toList()
  }

  fun <T> immutablemap(
    mapany : Map<String, T>) : Map<String, T> {
    return LinkedHashMap<String, T>(mapany)
  }

  open class Class_base {
    internal var vx_iref : Int = 0
    internal var vx_p_constdef : vx_core.Type_constdef? = null
    internal var vxmsgblock : vx_core.Type_msgblock? = null
    fun vx_constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef
      val constdef : vx_core.Type_constdef? = this.vx_p_constdef
      if (constdef == null) {
        output = vx_core.e_constdef
      } else {
        output = constdef
      }
      return output
    }
    fun vx_dispose() : List<Type_any> {
      this.vx_iref = 0
      this.vxmsgblock = null
      return vx_core.emptylistany
    }
    fun vx_msgblock() : vx_core.Type_msgblock {
      var output : vx_core.Type_msgblock
      val msgblock : vx_core.Type_msgblock? = this.vxmsgblock
      if (msgblock == null) {
        output = vx_core.e_msgblock
      } else {
        output = msgblock
      }
      return output
    }
    fun vx_release() : Boolean {
      var output : Boolean = false
      if (this.vx_iref < 0) {
      } else if (this.vx_iref == 0) {
        this.vx_iref = -1
        output = true
      } else {
        this.vx_iref -= 1
      }
      return output
    }
    fun vx_reserve() : Unit {
      this.vx_iref += 1
    }
  }

/*
  class KeyValue<T> {
    var key : String = ""
    var value : T = null
  }
*/

  fun constdef_new(
    pkgname : String,
    name : String,
    typ : vx_core.Type_any) : vx_core.Type_constdef {
    var output : vx_core.Class_constdef = vx_core.Class_constdef()
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname)
    output.vx_p_name = vx_core.vx_new_string(name)
    output.vx_p_type = typ
    return output
  }

  fun funcdef_new(
    pkgname : String,
    name : String,
    idx : Int,
    async : Boolean,
    typ : vx_core.Type_any) : vx_core.Type_funcdef {
    var output : vx_core.Class_funcdef = vx_core.Class_funcdef()
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname)
    output.vx_p_name = vx_core.vx_new_string(name)
    output.vx_p_idx = vx_core.vx_new_int(idx)
    output.vx_p_async = vx_core.vx_new_boolean(async)
    output.vx_p_type = typ
    return output
  }

  fun arrayany_from_anylist(
    list : vx_core.Type_anylist) : Array<vx_core.Type_any> {
    val listany : List<vx_core.Type_any> = list.vx_list()
    val output : Array<vx_core.Type_any> = listany.toTypedArray()
    return output
  }

  //@SafeVarargs
  fun <T> arraylist_from_array(
    vararg items : T) : List<T> {
    var output : List<T> = items.asList()
    output = vx_core.immutablelist(output)
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> arraylist_from_arraylist(
    generic_any_1 : T,
    listval : List<U>) : List<T> {
    val list : MutableList<T> = ArrayList<T>()
    for (value : vx_core.Type_any in listval) {
      val t_val : T = vx_core.f_any_from_any(generic_any_1, value)
      list.add(t_val)
    }
    val output = vx_core.immutablelist(list)
    return output
  }

  fun <T, U> arraylist_from_arraylist_fn(
    listval : List<U>,
    fn_any_from_any : (U) -> T) : List<T> {
    val list : MutableList<T> = ArrayList<T>()
    for (value_u : U in listval) {
      val t_val : T = fn_any_from_any(value_u)
      list.add(t_val)
    }
    val output = vx_core.immutablelist(list)
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> arraylist_from_linkedhashmap(
    generic_any_1 : T,
    mapval : Map<String, U>) : List<T> {
    val list : MutableList<T> = ArrayList<T>()
    val keys : Set<String> = mapval.keys
    for (key : String in keys) {
      val u_val : U? = mapval.get(key)
      if (u_val != null) {
        val t_val : T = vx_core.f_any_from_any(generic_any_1, u_val)
        list.add(t_val)
      }
    }
    val output = vx_core.immutablelist(list)
    return output
  }

  fun <T, U> arraylist_from_linkedhashmap_fn(
    mapval : Map<String, U>,
    fn_any_from_key_value : (String, U) -> T) : List<T> {
    val list : MutableList<T> = ArrayList<T>()
    val keys : Set<String> = mapval.keys
    for (key : String in keys) {
      val u_val : U? = mapval.get(key)
      if (u_val != null) {
        val t_val : T = fn_any_from_key_value(key, u_val)
        list.add(t_val)
      }
    }
    val output = vx_core.immutablelist(list)
    return output
  }

  fun <T> async_new_completed(
    value : T) : CompletableFuture<T> {
    val output : CompletableFuture<T> = CompletableFuture.completedFuture(value)
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> async_from_async(
    generic_any_1 : T,
    future : CompletableFuture<U>) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply({value : U ->
      val output_1 : T = vx_core.f_any_from_any(generic_any_1, value)
      output_1
    })
    return output
  }

  fun <T, U> async_from_async_fn(
    future : CompletableFuture<U>,
    fn : (U) -> T) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply(fn)
    return output
  }

  fun <T> map_from_list_fn(
    listval : List<T>,
    fn_any_from_any : (T) -> vx_core.Type_string) : Map<String, T> {
    var map : MutableMap<String, T> = LinkedHashMap<String, T>()
    for (value : T in listval) {
      val valkey : vx_core.Type_string = fn_any_from_any(value)
      val key : String = valkey.vx_string()
      map.put(key, value)
    }
    val output = vx_core.immutablemap<T>(map)
    return output
  }

  // vx_any_from_func(generic_any_1, func, args...)
  fun <T : vx_core.Type_any> vx_any_from_func(
    generic_any_1 : T,
    func : vx_core.Type_replfunc,
    vararg args : vx_core.Type_any) : T {
    val anylist : vx_core.Type_anylist = vx_core.vx_new_anylist(*args)
    val value : vx_core.Type_any = func.vx_repl(anylist)
    val output : T = vx_core.f_any_from_any(generic_any_1, value)
    return output
  }

  // vx_any_from_list_start_reduce(any-1, list-2, any-1, any<-reduce)
  fun <T : vx_core.Type_any, N : vx_core.Type_list> vx_any_from_list_start_reduce(
    generic_any_1 : T,
    list : N,
    valstart : T,
    fn_reduce : vx_core.Func_any_from_reduce) : T {
    var output : T = valstart
    val listval : List<vx_core.Type_any> = list.vx_list()
    for (item : vx_core.Type_any in listval) {
      output = fn_reduce.vx_any_from_reduce(
        generic_any_1, output, item
      )
    }
    return output
  }

  // vx_any_from_list_start_reduce_next(any-1, list-2, any-1, any<-reduce-next)
  fun <T : vx_core.Type_any, N : vx_core.Type_list> vx_any_from_list_start_reduce_next(
    generic_any_1 : T,
    list : N,
    valstart : T,
    fn_reduce_next : vx_core.Func_any_from_reduce_next) : T {
    var output : T = valstart
    val listval : List<vx_core.Type_any> = list.vx_list()
    var current : vx_core.Type_any = vx_core.e_any
    var first : Boolean = true
    for (next : vx_core.Type_any in listval) {
      if (first) {
        first = false
      } else {
        output = fn_reduce_next.vx_any_from_reduce_next(generic_any_1, output, current, next)
      }
      current = next
    }
    return output
  }

  // vx_any_from_map(generic_any_1, map, string)
  fun <T : vx_core.Type_any> vx_any_from_map(
    generic_any_1 : T,
    valuemap : vx_core.Type_map,
    key : vx_core.Type_string) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    var skey : String = key.vx_string()
    if (skey.startsWith(":")) {
      skey = skey.substring(1);
    }
    val value : vx_core.Type_any = valuemap.vx_map().getOrDefault(
      skey, output
    )
    output = vx_core.f_any_from_any(
      generic_any_1,
      value
    )
    return output
  }

  // vx_any_from_map_start_reduce(any-1, map-2, any-1, any<-any-key-value)
  fun <T : vx_core.Type_any, N : vx_core.Type_map> vx_any_from_map_start_reduce(
    generic_any_1 : T,
    map : N,
    start : T,
    fn_reduce : vx_core.Func_any_from_any_key_value) : T {
    var output : T = start
    val mapval : Map<String, vx_core.Type_any> = map.vx_map()
    val keys : Set<String> = mapval.keys
    for (skey : String in keys) {
      val key : vx_core.Type_string = vx_core.vx_new_string(skey)
      val value : vx_core.Type_any? = mapval.get(skey)
      if (value != null) {
        output = fn_reduce.vx_any_from_any_key_value(
          generic_any_1, output, key, value
        )
      }
    }
    return output
  }

  // vx_any_first_from_list_fn(generic_any_1, list, fn_any)
  fun <T : vx_core.Type_any> vx_any_first_from_list_fn(
    generic_any_1 : T,
    list : vx_core.Type_list,
    fn_any : (vx_core.Type_any) -> T) : T {
    val empty : T = vx_core.f_empty(generic_any_1)
    var output : T = empty
    val listany : List<vx_core.Type_any> = list.vx_list()
    for (any : vx_core.Type_any in listany) {
      val tany : T = vx_core.f_any_from_any(generic_any_1, any)
      val value : T = fn_any(tany)
      if (value != empty) {
        output = value
        break
      }
    }
    return output
  }

  fun <T> vx_async_new_from_value(
    value : T) : CompletableFuture<T>  {
    val output : CompletableFuture<T> = CompletableFuture.completedFuture(
      value
    )
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_async_from_async(
    generic_any_1 : T,
    future : CompletableFuture<U>) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply({value ->
      val output_1 : T = vx_core.f_any_from_any(generic_any_1, value)
      output_1
    })
    return output
  }

  fun <T, U> vx_async_from_async_fn(
    future : CompletableFuture<U>,
    fn : (U) -> T) : CompletableFuture<T> {
    val output : CompletableFuture<T> = future.thenApply(fn)
    return output
  }

  fun <T> vx_async_arraylist_from_arraylist_async(
    list_future_t : List<CompletableFuture<T>>) : CompletableFuture<List<T>> {
    val array_future_t : Array<CompletableFuture<*>> = list_future_t.toTypedArray()
    val future_void : CompletableFuture<Void> = CompletableFuture.allOf(
      *array_future_t
    )
    val output : CompletableFuture<List<T>> = future_void.thenApply {
      _ ->
      val list : List<T> = list_future_t.map {
        future_t : CompletableFuture<T> ->
        val output_2 : T = future_t.get()
        output_2
      }
      val output_1 : List<T> = vx_core.immutablelist<T>(list)
      output_1
    }
    return output
  }

  // vx_boolean_from_string_ends(string, string)
  fun vx_boolean_from_string_ends(
    text : String,
    ends : String) : Boolean {
    return text.endsWith(ends)
  }

  // vx_boolean_from_string_find(string, string)
  fun vx_boolean_from_string_find(
    text : String,
    find : String
  ) : Boolean {
    return text.contains(find)
  }

  // vx_boolean_from_string_starts(string, string)
  fun vx_boolean_from_string_starts(
    text : String,
    starts : String) : Boolean {
    return text.startsWith(starts)
  }

  // vx_boolean_write_from_map_name_value(map, string, any)
  fun vx_boolean_write_from_map_name_value(
    valuemap : vx_core.Type_map,
    name : vx_core.Type_string,
    value : vx_core.Type_any) : vx_core.Type_boolean {
    val output : vx_core.Type_boolean = valuemap.vx_set(name, value)
    return output
  }

  // vx_compare(any, any)
  fun vx_compare(
    val1 : vx_core.Type_any,
    val2 : vx_core.Type_any) : vx_core.Type_int {
    var intresult : Int = 0
    if ((val1 is vx_core.Type_number) && (val2 is vx_core.Type_number)) {
      val num1 = val1 as vx_core.Type_number
      val num2 = val2 as vx_core.Type_number
      val float1 : Float = vx_core.vx_new(vx_core.t_float, num1).vx_float()
      val float2 : Float = vx_core.vx_new(vx_core.t_float, num2).vx_float()
      if (float1 < float2) {
        intresult = -1
      } else if (float1 > float2) {
        intresult = 1
      }
    } else {
      val stringval1 : String = vx_core.f_string_from_any(val1).vx_string()
      val stringval2 : String = vx_core.f_string_from_any(val2).vx_string()
      val compare : Int = stringval1.compareTo(stringval2)
      if (compare > 0) {
        intresult = 1
      } else if (compare < 0) {
        intresult = -1
      }
    }
    val output : vx_core.Type_int = vx_core.vx_new_int(intresult)
    return output
  }

  // vx_contains(list-1, any)
  fun <T : vx_core.Type_list> vx_contains_1(
    values : T,
    find : vx_core.Type_any) : vx_core.Type_boolean {
    var booleanresult : Boolean = false
    val listvalues : List<vx_core.Type_any> = values.vx_list()
    for (item : vx_core.Type_any in listvalues) {
      val iseq : vx_core.Type_boolean = vx_core.f_eq(
        item, find
      )
      if (iseq.vx_boolean()) {
        booleanresult = true
        break
      }
    }
    val output : vx_core.Type_boolean = vx_core.vx_new_boolean(
      booleanresult
    )
    return output
  }

  // vx_copy(generic_any_1, args...)
  fun <T : vx_core.Type_any> vx_copy(
    copyval : T,
    vararg vals : Any) : T {
    val value : vx_core.Type_any = copyval.vx_copy(*vals)
    val output : T = vx_core.f_any_from_any(copyval, value)
    return output
  }

  // vx_empty(generic_any_1)
  fun <T : vx_core.Type_any> vx_empty(
    type : T) : T {
    @Suppress("UNCHECKED_CAST")
    val output : T = type.vx_empty() as T
    return output
  }

  // vx_eqeq(any, any)
  fun vx_eqeq(
    val1 : vx_core.Type_any,
    val2 : vx_core.Type_any) : Boolean {
    var output : Boolean = false
    if (val1 == val2) {
      output = true
    } else if (val1.vx_msgblock() != vx_core.e_msgblock) {
    } else if (val2.vx_msgblock() != vx_core.e_msgblock) {
    } else {
      val type1 : vx_core.Type_any = val1.vx_type()
      val type2 : vx_core.Type_any = val2.vx_type()
      if (type1 != type2) {
      } else if (type1 == vx_core.t_int) {
        val valint1 : vx_core.Type_int = val1 as vx_core.Type_int
        val valint2 : vx_core.Type_int = val1 as vx_core.Type_int
        if (valint1.vx_int() == valint2.vx_int()) {
          output = true
        }
      } else if (type1 == vx_core.t_float) {
        val valfloat1 : vx_core.Type_float = val1 as vx_core.Type_float
        val valfloat2 : vx_core.Type_float = val2 as vx_core.Type_float
        if (valfloat1.vx_float() == valfloat2.vx_float()) {
          output = true
        }
      } else if (type1 == vx_core.t_decimal) {
        val valdecimal1 : vx_core.Type_decimal = val1 as vx_core.Type_decimal
        val valdecimal2 : vx_core.Type_decimal = val2 as vx_core.Type_decimal
        if (valdecimal1.vx_string() == valdecimal2.vx_string()) {
          output = true
        }
      } else if (type1 == vx_core.t_string) {
        val valstring1 : vx_core.Type_string = val1 as vx_core.Type_string
        val valstring2 : vx_core.Type_string = val2 as vx_core.Type_string
        if (valstring1.vx_string() == valstring2.vx_string()) {
          output = true
        }
      }
    }
    return output
  }

  // vx_float_from_number(number)
  fun vx_float_from_number(
    num : vx_core.Type_number) : Float {
    var output : Float = 0f
    val type : vx_core.Type_any = num.vx_type()
    if (type == vx_core.t_float) {
      val floatval : vx_core.Type_float = vx_core.f_any_from_any(vx_core.t_float, num)
      output = floatval.vx_float()
    } else if (type == vx_core.t_int) {
      val intval : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, num)
      output = intval.vx_int().toFloat()
    } else if (type == vx_core.t_decimal) {
      val decval : vx_core.Type_decimal = vx_core.f_any_from_any(vx_core.t_decimal, num)
      output = decval.vx_float()
    }
    return output
  }

  // vx_float_from_string(string)
  fun vx_float_from_string(
    text : String) : Float {
    var output : Float = 0f
    try {
      output = text.toFloat()
    } catch (ex : Exception) {
    }    
    return output
  }

  // vx_global_package_set(string, map<any>, map<any>, map<func>)
  fun vx_global_package_set(
    pkgname : String,
    maptype : Map<String, vx_core.Type_any>,
    mapconst : Map<String, vx_core.Type_any>,
    mapfunc : Map<String, vx_core.Type_func>) : Unit {
    val typemap : vx_core.Class_typemap = vx_core.Class_typemap()
    typemap.vx_p_map = vx_core.immutablemap(maptype)
    val constmap : vx_core.Class_constmap = vx_core.Class_constmap()
    constmap.vx_p_map = vx_core.immutablemap(mapconst)
    val funcmap : vx_core.Class_funcmap = vx_core.Class_funcmap()
    funcmap.vx_p_map = vx_core.immutablemap(mapfunc)
    val global : vx_core.Class_project = vx_core.c_global as vx_core.Class_project
    var typepackagemap : vx_core.Type_packagemap? = global.vx_p_packagemap
    var packagemap : vx_core.Class_packagemap = vx_core.Class_packagemap()
    if (typepackagemap == null) {
      global.vx_p_packagemap = packagemap
    } else {
      packagemap = typepackagemap as vx_core.Class_packagemap
    }
    val mappackage : MutableMap<String, vx_core.Type_package> = LinkedHashMap<String, vx_core.Type_package>(
      packagemap.vx_p_map
    )
    val pkg : vx_core.Class_package = vx_core.Class_package()
    pkg.vx_p_constmap = constmap
    pkg.vx_p_typemap = typemap
    pkg.vx_p_funcmap = funcmap
    mappackage.put(pkgname, pkg)
    packagemap.vx_p_map = vx_core.immutablemap<vx_core.Type_package>(mappackage)
  }

  fun <T : vx_core.Type_any> vx_if_2(
    generic_any_1 : T,
    thenelselist : vx_core.Type_thenelselist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    val fn_any : vx_core.Func_any_from_func = vx_core.vx_any_first_from_list_fn(
      vx_core.t_any_from_func,
      thenelselist,
      {any : vx_core.Type_any ->
        var fnany : vx_core.Func_any_from_func = vx_core.e_any_from_func
        if (any is vx_core.Type_thenelse) {
          val thenelse : vx_core.Type_thenelse = any as vx_core.Type_thenelse
          val code : vx_core.Type_string = thenelse.code()
          val scode : String = code.vx_string()
          if (scode.equals(":then")) {
            val fn_cond : vx_core.Func_boolean_from_func = thenelse.fn_cond()
            val cond : vx_core.Type_boolean = fn_cond.vx_boolean_from_func()
            if (cond.vx_boolean() == true) {
              fnany = thenelse.fn_any()
            }
          } else if (scode.equals(":else")) {
            fnany = thenelse.fn_any()
          }
        }
        fnany
      }
    )
    if (fn_any != vx_core.e_any_from_func) {
      output = fn_any.vx_any_from_func(generic_any_1)
    }
    return output
  }

  // vx_int_from_string(string)
  fun vx_int_from_string(
    text : String) : Int {
    var output : Int = 0
    try {
      output = text.toInt()
    } catch (ex : Exception) {
    }    
    return output
  }

  // vx_int_from_string_find(string, string)
  fun vx_int_from_string_find(
    text : String,
    find : String) : Int {
    return text.indexOf(find)
  }

  // vx_int_from_string_findlast(string, string)
  fun vx_int_from_string_findlast(
    text : String,
    findlast : String
  ) : Int {
    return text.lastIndexOf(findlast)
  }

  // vx_is_float(string)
  fun vx_is_float(
    text : String) : Boolean {
    var output : Boolean = false
    try {
      text.toFloat()
      output = true
    } catch (ex : Exception) {
    }    
    return output
  }

  // vx_is_float(any)
  fun vx_is_float(
    value : vx_core.Type_any) : Boolean {
    var output : Boolean = false
    if (value is vx_core.Type_number) {
      output = true
    } else if (value is vx_core.Type_string) {
      val valuestring : vx_core.Type_string = value as vx_core.Type_string
      output = vx_core.vx_is_float(valuestring.vx_string())
    }
    return output
  }

  // vx_is_int(string)
  fun vx_is_int(
    text : String) : Boolean {
    var output : Boolean = false
    if (text == "notanumber") {
      output = true
    } else if (text == "infinity") {
      output = true
    } else if (text == "neginfinity") {
      output = true
    } else {
      try {
        Integer.parseInt(text)
        output = true
      } catch (ex : Exception) {
      }
    }
    return output
  }

  // vx_is_int(any)
  fun vx_is_int(
    value : vx_core.Type_any) : Boolean {
    var result : Boolean = false
    if (value == vx_core.c_infinity) {
      result = true
    } else if (value == vx_core.c_neginfinity) {
      result = true
    } else if (value == vx_core.c_notanumber) {
      result = true
    } else if (value is vx_core.Type_int) {
      result = true
    } else if (value is vx_core.Type_float) {
      val valfloat : vx_core.Type_float = value as vx_core.Type_float
      val floatval : Float = valfloat.vx_float()
      if (floatval == floatval.toInt().toFloat()) {
        result = true
      }
    } else if (value is vx_core.Type_decimal) {
      val valdec : vx_core.Type_decimal = value as vx_core.Type_decimal
      val strval : String = valdec.vx_string()
      try {
        val floatval : Float = strval.toFloat()
        if (floatval == floatval.toInt().toFloat()) {
          result = true
        }
      } catch (ex : Exception) {
      }
    } else if (value is vx_core.Type_string) {
      val valstr : vx_core.Type_string = value as vx_core.Type_string
      val strval : String = valstr.vx_string()
      result = vx_is_int(strval)
    }
    return result
  }

  // vx_log(object...)
  fun vx_log(
    vararg values : Any) : Unit {
    for (value : Any in values) {
      var text : String = ""
      if (value is vx_core.Type_string) {
        val valstring : vx_core.Type_string = value as vx_core.Type_string
        text = valstring.vx_string()
      } else if (value is vx_core.Type_any) {
        val valany : vx_core.Type_any = value as vx_core.Type_any
        text = vx_core.vx_string_from_any(valany)
      } else if (value is Array<*>) {
        val items : Array<Any> = value as Array<Any>
        text = "(array"
        for (item : Any in items) {
          if (item is vx_core.Type_string) {
            val valstring : vx_core.Type_string = item as vx_core.Type_string
            text += "\n " + valstring.vx_string()
          } else if (item is vx_core.Type_any) {
            val valany : vx_core.Type_any = item as vx_core.Type_any
            text += "\n " + vx_core.vx_string_from_any(valany)
          } else {
            text += "\n " + item.toString()
          }
        }
        text += "\n)"
      } else if (value is List<*>) {
        val items : List<Any> = value as List<Any>
        text = "(list"
        for (item : Any in items) {
          if (item is vx_core.Type_string) {
            val valstring : vx_core.Type_string = item as vx_core.Type_string
            text += "\n " + valstring.vx_string()
          } else if (item is vx_core.Type_any) {
            val valany : vx_core.Type_any = item as vx_core.Type_any
            text += "\n " + vx_core.vx_string_from_any(valany)
          } else {
            text += "\n " + item.toString()
          }
        }
        text += "\n)"
      } else {
        text = value.toString()
      }
      println(text)
    }
  }

  // vx_msg_error
  fun vx_msg_error(
    text : String) : Type_msg {
    val output : Class_msg = Class_msg()
    output.vx_p_text = vx_core.vx_new_string(text)
    output.vx_p_severity = vx_core.c_msg_severe
    return output
  }

  // vx_msg_from_error
  fun vx_msg_from_error(
    text : String) : vx_core.Type_msg {
    var output : Class_msg = Class_msg()
    output.vx_p_text = vx_core.vx_new_string(text)
    output.vx_p_severity = vx_core.c_msg_severe
    return output
  }

  // vx_msg_from_error
  fun vx_msg_from_error(
    path : String,
    code : String,
    detail : vx_core.Type_any) : vx_core.Type_msg {
    var output : Class_msg = Class_msg()
    output.vx_p_path = vx_core.vx_new_string(path)
    output.vx_p_code = vx_core.vx_new_string(code)
    output.vx_p_detail = detail
    output.vx_p_severity = vx_core.c_msg_severe
    return output
  }

  // vx_msg_from_exception
  fun vx_msg_from_exception(
    text : String,
    err : Exception) : Type_msg {
    val output : Class_msg = Class_msg()
    output.vx_p_text = vx_core.vx_new_string(text)
    output.vx_p_severity = vx_core.c_msg_severe
    output.err = err
    vx_core.vx_log(output)
    return output
  }

  // vx_msgblock_from_copy_arrayval(msgblock, any...)
  fun vx_msgblock_from_copy_arrayval(
    copy : vx_core.Type_any,
    vararg vals : Any) : vx_core.Type_msgblock {
    var output : vx_core.Type_msgblock = vx_core.e_msgblock
    val copymsgblock : vx_core.Type_msgblock = copy.vx_msgblock()
    if (copymsgblock != vx_core.e_msgblock) {
      output = copymsgblock
    }
    return output
  }

  // vx_new(generic_any_1, args...)
  fun <T : vx_core.Type_any> vx_new(
    generic_any_1 : T,
    vararg vals : Any) : T {
    val value : vx_core.Type_any = generic_any_1.vx_new(*vals)
    val output : T = vx_core.f_any_from_any(generic_any_1, value)
    return output
  }

  // vx_new_anylist(Array<any>)
  fun vx_new_anylist(
    vararg anys : vx_core.Type_any) : vx_core.Type_anylist {
    val listany : List<vx_core.Type_any> = anys.asList()
    return vx_new_anylist(listany)
  }

  fun vx_new_anylist(
    listany : List<vx_core.Type_any>) : vx_core.Type_anylist {
    val output : vx_core.Class_anylist = vx_core.Class_anylist()
    output.vx_p_list = immutablelist(listany)
    return output
  }

  // vx_new_list(T, List<any>)
  fun <T : vx_core.Type_list> vx_new_list(
    generic_list_1 : T,
    listval : List<vx_core.Type_any>) : T {
    val anylist : vx_core.Type_any = generic_list_1.vx_new(listval)
    val output : T = vx_core.f_any_from_any(generic_list_1, anylist)
    return output
  }

  // vx_type(generic_any_1)
  fun <T : vx_core.Type_any> vx_type(
    type : T) : T {
    @Suppress("UNCHECKED_CAST")
    val output : T = type.vx_type() as T
    return output
  }

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_1(
    generic_list_1 : X,
    values : Y,
    fn_any_from_any : vx_core.Func_any_from_any) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    val list_value : List<vx_core.Type_any> = values.vx_list()
    val fn : (vx_core.Type_any) -> vx_core.Type_any = {
      value : vx_core.Type_any ->
      val output_1 : vx_core.Type_any = fn_any_from_any.vx_any_from_any(
        vx_core.t_any, value
      )
      output_1
    }
    val list_result : List<vx_core.Type_any> = vx_core.arraylist_from_arraylist_fn<vx_core.Type_any, vx_core.Type_any>(
      list_value, fn
    )
    output = vx_core.f_any_from_any(
      generic_list_1,
      generic_list_1.vx_new(list_result)
    )
    return output
  }

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_async(
    generic_list_1 : X,
    values : Y,
    fn_any_from_any_async : vx_core.Func_any_from_any_async) : CompletableFuture<X> {
    val fn_future_from_any : (vx_core.Type_any) -> CompletableFuture<vx_core.Type_any> = {
      value : vx_core.Type_any ->
      val future_any : CompletableFuture<vx_core.Type_any> = fn_any_from_any_async.vx_any_from_any_async(
       vx_core.t_any, value
      )
      future_any
    }
    val fn_any_from_list : (List<vx_core.Type_any>) -> X = {
      list_result : List<vx_core.Type_any> ->
      val anylist : vx_core.Type_any = generic_list_1.vx_new(
        *list_result.toTypedArray()
      )
      val work : X = vx_core.f_any_from_any(
        generic_list_1,
        anylist
      )
      work
    }
    val list_value : List<vx_core.Type_any> = values.vx_list()
    val list_async_result : List<CompletableFuture<vx_core.Type_any>> = vx_core.arraylist_from_arraylist_fn(
      list_value, fn_future_from_any
    )
    val async_list_result : CompletableFuture<List<vx_core.Type_any>> = vx_core.vx_async_arraylist_from_arraylist_async(
      list_async_result
    )
    val output : CompletableFuture<X> = vx_core.vx_async_from_async_fn(
      async_list_result, fn_any_from_list
    )
    return output
  }

  // vx_list_from_list_intany(generic_list_1, list-2, any<-int-any)
  fun <T : vx_core.Type_list, U : vx_core.Type_list> vx_list_from_list_intany(
    generic_list_1 : T,
    valuelist : U,
    fn_any_from_int_any : vx_core.Func_any_from_int_any) : T {
    var output : T = vx_core.f_empty(generic_list_1)
    val listany : List<vx_core.Type_any> = valuelist.vx_list()
    if (listany.size > 0) {
      val listout : MutableList<vx_core.Type_any> = ArrayList<vx_core.Type_any>()
      var i : Int = 0
      for (value in listany) {
        i += 1
        val vali : vx_core.Type_int = vx_core.vx_new_int(i)
        val outval : vx_core.Type_any = fn_any_from_int_any.vx_any_from_int_any(
          vx_core.t_any, vali, value
        )
        listout.add(outval)
      }
      output = vx_core.vx_new_list(
        generic_list_1,
        listout
      )
    }
    return output
  }

  fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map_1(
    generic_list_1 : X,
    valuemap : O,
    fn_any_from_key_value : vx_core.Func_any_from_key_value) : X {
    val map_value : Map<String, vx_core.Type_any> = valuemap.vx_map()
    val fn_key_value : (String, vx_core.Type_any) -> vx_core.Type_any = {
      key : String, value : vx_core.Type_any ->
      val valkey : vx_core.Type_string = vx_core.vx_new_string(
        key
      )
      val output_1 : vx_core.Type_any = fn_any_from_key_value.vx_any_from_key_value(
        vx_core.t_any, valkey, value
      )
      output_1
    }
    val listresult : List<vx_core.Type_any> = vx_core.arraylist_from_linkedhashmap_fn(
      map_value, fn_key_value
    )
    val anylist : vx_core.Type_any = generic_list_1.vx_new(
      listresult
    )
    val output : X = vx_core.f_any_from_any(
      generic_list_1,
      anylist
    )
    return output
  }

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_join_from_list_1(
    generic_list_1 : X,
    values : Y,
    fn_any_from_any : vx_core.Func_any_from_any) : X {
    val list_value : List<vx_core.Type_any> = values.vx_list()
    val list_result : MutableList<vx_core.Type_any> = ArrayList<vx_core.Type_any>()
    for (value : vx_core.Type_any in list_value) {
      val listoflist : vx_core.Type_any = fn_any_from_any.vx_any_from_any(
        generic_list_1, value
      )
      if (listoflist is vx_core.Type_list) {
        val vallist : vx_core.Type_list = listoflist as vx_core.Type_list
        val listval : List<vx_core.Type_any> = vallist.vx_list()
        list_result.addAll(listval)
      }
    }
    val output : X = vx_core.f_any_from_any(
      generic_list_1,
      generic_list_1.vx_new(list_result)
    )
    return output
  }

  fun <N : vx_core.Type_map, Y : vx_core.Type_list> vx_map_from_list(
    generic_map_1 : N,
    vallist : Y,
    fn_any_from_any : vx_core.Func_any_from_any) : N {
    val listval : List<vx_core.Type_any> = vallist.vx_list()
    val fn_string_from_any : (vx_core.Type_any) -> vx_core.Type_string = {
      value : vx_core.Type_any ->
      val output_string : vx_core.Type_string = fn_any_from_any.vx_any_from_any(
        vx_core.t_string, value
      )
      output_string
    }
    val mapresult : Map<String, vx_core.Type_any> = vx_core.vx_map_from_list_fn(
      listval, fn_string_from_any
    )
    val mapval : vx_core.Type_map = generic_map_1.vx_new_from_map(
      mapresult
    )
    val output = vx_core.f_any_from_any(
      generic_map_1,
      mapval
    )
    return output
  }

  // vx_map_from_list_fn(generic_map, list, fn_any_from_key_value)
  fun <T> vx_map_from_list_fn(
    listval : List<T>,
    fn_any_from_any : (T) -> vx_core.Type_string) : Map<String, T> {
    val map : MutableMap<String, T> = LinkedHashMap<String, T>()
    for (value : T in listval) {
      val valkey : vx_core.Type_string = fn_any_from_any(
        value
      )
      val key : String = valkey.vx_string()
      map.put(key, value)
    }
    val output : Map<String, T> = vx_core.immutablemap<T>(map)
    return output
  }

  // vx_map_from_map_fn(generic_map, map, fn_any_from_key_value)
  fun <T : vx_core.Type_map> vx_map_from_map_fn(
    generic_map_1 : T,
    valuemap : vx_core.Type_map,
    fn_any_from_key_value : vx_core.Func_any_from_key_value) : T {
    var output : T = vx_core.f_empty(generic_map_1)
    val mapvalue : Map<String, vx_core.Type_any> = valuemap.vx_map()
    if (mapvalue.size > 0) {
      val typedef : vx_core.Type_typedef = vx_core.f_typedef_from_any(
        generic_map_1
      )
      val allowtypes : vx_core.Type_typelist = vx_core.f_allowtypes_from_typedef(
        typedef
      )
      val lallowtypes : List<vx_core.Type_any> = allowtypes.vx_list()
      val keys : Set<String> = mapvalue.keys
      val mapnew : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      for (key : String in keys) {
        val value : vx_core.Type_any? = mapvalue.get(key)
        if (value != null) {
          val stringkey : vx_core.Type_string = vx_core.vx_new_string(key)
          val chgvalue : vx_core.Type_any = fn_any_from_key_value.vx_any_from_key_value(
            vx_core.t_any, stringkey, value
          )
          val chgtype : vx_core.Type_any = chgvalue.vx_type()
          if (lallowtypes.contains(chgtype)) {
            mapnew.put(key, chgvalue)
          }
        }
      }
      output = vx_core.vx_new_map(
        generic_map_1, mapnew
      )
    }
    return output;
  }

  fun vx_new_boolean(
    isval : Boolean) : Type_boolean {
    var output : Type_boolean = vx_core.c_false
    if (isval) {
      output = vx_core.c_true
    }
    return output
  }

  fun vx_new_decimal(
    text : String) : vx_core.Type_decimal {
    var output : vx_core.Type_decimal
    if (text.equals("0") || text.equals("0.0")) {
      output = vx_core.e_decimal
    } else {
      val work : vx_core.Class_decimal = vx_core.Class_decimal()
      work.vxdecimal = text
      output = work
    }
    return output
  }

  fun vx_new_float(
    fval : Float) : Type_float {
    var output : Class_float = vx_core.Class_float()
    output.vxfloat = fval
    return output
  }

  fun vx_new_int(
    ival : Int) : Type_int {
    var output : Type_int
    if (ival == 0) {
      output = vx_core.e_int
    } else {
      val work : vx_core.Class_int = vx_core.Class_int()
      work.vxint = ival
      output = work
    }
    return output
  }

  // vx_new_map(T, Map<string, any>)
  fun <T : vx_core.Type_map> vx_new_map(
    generic_map_1 : T,
    mapval : Map<String, vx_core.Type_any>) : T {
    val anymap : vx_core.Type_any = generic_map_1.vx_new_from_map(mapval)
    val output : T = vx_core.f_any_from_any(
      generic_map_1, anymap
    )
    return output
  }

  fun vx_new_string(
    text : String) : Type_string {
    var output : Type_string
    if (text.equals("")) {
      output = vx_core.e_string
    } else {
      val work : Class_string = vx_core.Class_string()
      work.vxstring = text
      output = work
    }
    return output
  }

  fun vx_string_from_any(
    value : vx_core.Type_any) : String {
    return vx_string_from_any_indent(value, 0, false)
  }

  fun vx_string_from_any_indent(
    value : vx_core.Type_any,
    indent : Int,
    linefeed : Boolean) : String {
    val indenttext : String = " ".repeat(indent)
    var output : String = ""
    if (indent > 50) {
      output = "Error: Max Depth Exceeded"
    } else if (value == null) {
      output = "null"
    } else if (value == value.vx_type()) {
      if (value is vx_core.Type_func) {
        val valuefunc : vx_core.Type_func = value as vx_core.Type_func
        val funcdef : vx_core.Type_funcdef = valuefunc.vx_funcdef()
        output = funcdef.pkgname().vx_string() + "/" + funcdef.name().vx_string()
      } else {
        val typedef : vx_core.Type_typedef = value.vx_typedef()
        output = typedef.pkgname().vx_string() + "/" + typedef.name().vx_string()
      }
    } else if (value is vx_core.Type_boolean) {
      val valbool : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, value)
      if (valbool.vx_boolean() == true) {
        output = "true"
      } else {
        output = "false"
      }
    } else if (value is vx_core.Type_decimal) {
      val valdec : vx_core.Type_decimal = vx_core.f_any_from_any(vx_core.t_decimal, value)
      output = valdec.vx_string()
    } else if (value is vx_core.Type_float) {
      val valfloat : vx_core.Type_float = vx_core.f_any_from_any(vx_core.t_float, value)
      output = valfloat.vx_float().toString()
      if (output.endsWith(".0")) {
        output = output.substring(0, output.length - 2)
      }
    } else if (value is vx_core.Type_int) {
      if (value == vx_core.c_notanumber) {
        output = "notanumber"
      } else if (value == vx_core.c_infinity) {
        output = "infinity"
      } else if (value == vx_core.c_neginfinity) {
        output = "neginfinity"
      } else {
        val valint : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, value)
        output = Integer.toString(valint.vx_int())
      }
    } else if (value is vx_core.Type_string) {
      val valstring : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, value)
      var sval : String = valstring.vx_string()
      if (sval.indexOf("\"") < 0) {
        sval = "\"" + sval + "\""
      } else {
        sval = "`" + sval + "`"
      }
      if (valstring.vx_msgblock() != vx_core.e_msgblock) {
        var msgtext : String = vx_core.vx_string_from_any_indent(
          valstring.vx_msgblock(), indent, linefeed
        )
        output  = "\n" + indenttext + "(string"
        output += "\n" + indenttext + " " + sval
        output += "\n" + indenttext + " " + msgtext + ")"
      } else {
        output = sval
      }
    } else if (value.vx_constdef() != vx_core.e_constdef) {
      val constdef : vx_core.Type_constdef = value.vx_constdef()
      val constpkg : String = constdef.pkgname().vx_string()
      val constname : String = constdef.name().vx_string()
      if (constpkg.equals("vx/core")) {
        output = constname
      } else {
        output = constpkg + "/" + constname
      }
    } else if (value is vx_core.Type_list) {
      val vallist : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, value)
      val typedef : vx_core.Type_typedef = vallist.vx_typedef()
      val typedefname : vx_core.Type_string = typedef.name()
      var indentint : Int = indent
      indentint += 1
      val listval : List<vx_core.Type_any> = vallist.vx_list()
      for (valsub : vx_core.Type_any in listval) {
        val valtext : String = vx_core.vx_string_from_any_indent(valsub, indentint, linefeed)
        output += "\n " + indenttext + valtext
      }
      if (vallist.vx_msgblock() != vx_core.e_msgblock) {
        val msgtext : String = vx_core.vx_string_from_any_indent(vallist.vx_msgblock(), indentint, linefeed)
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext
      }
      output = "(" + typedefname.vx_string() + output + ")"
    } else if (value is vx_core.Type_map) {
      val valmap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, value)
      val typedef : vx_core.Type_typedef = valmap.vx_typedef()
      val typedefname : vx_core.Type_string = typedef.name()
      var indentint : Int = indent
      indentint += 2
      val mapval : Map<String, vx_core.Type_any> = valmap.vx_map()
      val keys : Set<String> = mapval.keys
      for (skey : String in keys) {
        var key : String = skey
        var valsub : vx_core.Type_any = mapval.getOrDefault(
          key, vx_core.e_any
        )
        if (!key.startsWith(":")) {
          key = ":" + key
        }
        var strval : String = vx_core.vx_string_from_any_indent(
          valsub, indentint, linefeed
        )
        if (strval.contains("\n")) {
          strval = "\n  " + indenttext + strval
        } else {
          strval = " " + strval
        }
        output += "\n" + indenttext + " " + key + strval
      }
      if (valmap.vx_msgblock() != vx_core.e_msgblock) {
        val msgtext : String = vx_core.vx_string_from_any_indent(
          valmap.vx_msgblock(), indentint, linefeed
        )
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext
      }
      output = "(" + typedefname.vx_string() + output + ")"
    } else if (value is vx_core.Type_struct) {
      val valstruct : vx_core.Type_struct = vx_core.f_any_from_any(
        vx_core.t_struct, value
      )
      val typedef : vx_core.Type_typedef = valstruct.vx_typedef()
      val typedefname : vx_core.Type_string = typedef.name()
      var indentint2 : Int = indent
      indentint2 += 2
      val mapval2 : Map<String, vx_core.Type_any> = valstruct.vx_map()
      val keys2 : Set<String> = mapval2.keys
      for (skey : String in keys2) {
        var key : String = skey
        val valsub2 : vx_core.Type_any = mapval2.getOrDefault(
          key, vx_core.e_any
        )
        if (!vx_core.f_is_empty_1(valsub2).vx_boolean()) {
          if (!key.startsWith(":")) {
            key = ":" + key
          }
          var strval2 : String = vx_core.vx_string_from_any_indent(
            valsub2, indentint2, linefeed
          )
          if (strval2.contains("\n")) {
            strval2 = "\n  " + indenttext + strval2
          } else {
            strval2 = " " + strval2
          }
          output += "\n" + indenttext + " " + key + strval2
        }
      }
      if (valstruct.vx_msgblock() != vx_core.e_msgblock) {
        val msgtext2 : String = vx_core.vx_string_from_any_indent(
          valstruct.vx_msgblock(), indentint2, linefeed
        )
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext2
      }
      output = "(" + typedefname.vx_string() + output + ")"
    } else if (value is vx_core.Type_func) {
      val valfunc : vx_core.Type_func = vx_core.f_any_from_any(
        vx_core.t_func, value
      )
      val funcdef : vx_core.Type_funcdef = valfunc.vx_funcdef()
      val funcdefname : vx_core.Type_string = vx_core.f_funcname_from_funcdef(
        funcdef
      )
      output = funcdefname.vx_string()
      if (valfunc.vx_msgblock() != vx_core.e_msgblock) {
        val msgtext : String = vx_core.vx_string_from_any_indent(
          valfunc.vx_msgblock(), indent, linefeed
        )
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext
      }
      output = "(" + output + ")"
    }
    return output
  }

  fun vx_string_from_any_indent(
    value : vx_core.Type_any,
    indent : vx_core.Type_int,
    linefeed : vx_core.Type_boolean) : vx_core.Type_string {
    val soutput : String = vx_core.vx_string_from_any_indent(
      value,
      indent.vx_int(),
      linefeed.vx_boolean())
    val output : vx_core.Type_string = vx_core.vx_new_string(soutput)
    return output
  }

  // vx_string_from_string_find_replace(string, string, string)
  fun vx_string_from_string_find_replace(
    text : String,
    find : String,
    replace : String) : String {
    val output : String = text.replace(find, replace)
    return output
  }

  // vx_string_from_string_find_replace(string, string, string)
  fun vx_string_from_string_find_replace(
    text : vx_core.Type_string,
    find : vx_core.Type_string,
    replace : vx_core.Type_string) : vx_core.Type_string {
    val stext : String = vx_core.vx_string_from_string_find_replace(
      text.vx_string(), find.vx_string(), replace.vx_string()
    )
    val output : vx_core.Type_string = vx_core.vx_new_string(stext)
    return output
  }

  fun vx_string_from_string_start_end(
    text : String,
    start : Int,
    endarg : Int) : String {
    var output : String = ""
    var maxlen : Int = text.length
    var end : Int = endarg
    if (end < 0) {
     end += maxlen
    }
    if (start < 1) {
    } else if (start > end) {
    } else if (start > maxlen) {
    } else {
      if (end >= maxlen) {
        end = maxlen
      }
      output = text.substring(start - 1, end)
    }
    return output
  }

  fun vx_string_repeat(
    text : String,
    repeat : Int) : String {
    val output : String = text.repeat(repeat)
    return output
  }

  fun vx_string_repeat(
    text : vx_core.Type_string,
    repeat : vx_core.Type_int) : vx_core.Type_string {
    val stext : String = vx_core.vx_string_repeat(text.vx_string(), repeat.vx_int())
    val output : vx_core.Type_string = vx_core.vx_new_string(stext)
    return output
  }

  fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_switch(
    generic_any_1 : T,
    value : U,
    thenelselist : vx_core.Type_thenelselist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    var fn_any : vx_core.Func_any_from_func = vx_core.e_any_from_func
    val listthenelse : List<vx_core.Type_thenelse> = thenelselist.vx_listthenelse()
    for (thenelse : vx_core.Type_thenelse in listthenelse) {
      val code : vx_core.Type_string = thenelse.code()
      when (code.vx_string()) {
        ":case" -> {
          val casevalue : vx_core.Type_any = thenelse.value()
          val iseq : vx_core.Type_boolean = vx_core.f_eq(casevalue, value)
          if (iseq.vx_boolean()) {
            fn_any = thenelse.fn_any()
          }
        }
        ":casemany" -> {
          val values : vx_core.Type_list = thenelse.values()
          val iscontain : vx_core.Type_boolean = vx_core.f_contains_1(values, value)
          if (iscontain.vx_boolean()) {
            fn_any = thenelse.fn_any()
          }
        }
        ":else" -> {
          fn_any = thenelse.fn_any()
        }
      }
      if (fn_any != vx_core.e_any_from_func) {
        break
      }
    }
    if (fn_any != vx_core.e_any_from_func) {
      output = fn_any.vx_any_from_func(generic_any_1)
    }
    return output
  }

  fun typedef_new(
    pkgname : String,
    name : String,
    extend : String,
    traits : vx_core.Type_typelist,
    allowtypes : vx_core.Type_typelist,
    disallowtypes : vx_core.Type_typelist,
    allowfuncs : vx_core.Type_funclist,
    disallowfuncs : vx_core.Type_funclist,
    allowvalues : vx_core.Type_anylist,
    disallowvalues : vx_core.Type_anylist,
    properties : vx_core.Type_argmap) : vx_core.Type_typedef {
    val output : vx_core.Class_typedef = vx_core.Class_typedef()
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname)
    output.vx_p_name = vx_core.vx_new_string(name)
    output.vx_p_extend = vx_core.vx_new_string(extend)
    output.vx_p_traits = traits
    output.vx_p_allowtypes = allowtypes
    output.vx_p_disallowtypes = disallowtypes
    output.vx_p_allowfuncs = disallowfuncs
    output.vx_p_disallowfuncs = disallowfuncs
    output.vx_p_allowvalues = disallowvalues
    output.vx_p_disallowvalues = disallowvalues
    output.vx_p_properties = properties
    return output
  }

  fun vx_anylist_from_arraystring(
    vararg arraystring : String) : vx_core.Type_anylist {
    val listany : MutableList<Any> = ArrayList<Any>()
    for (svalue : String in arraystring) {
      val value : vx_core.Type_string = vx_core.vx_new_string(svalue)
      listany.add(value)
    }
    val arrayany : Array<Any> = listany.toTypedArray()
    val output : vx_core.Type_anylist = vx_core.vx_new(
      vx_core.t_anylist,
      *arrayany)
    return output
  }

  // Warning!: Blocking
  fun <T : vx_core.Type_any> vx_sync_from_async(
    generic_any_1 : T,
    future : CompletableFuture<T>) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    try {
      output = future.get()
    } catch (ex : Exception) {
      val msg : vx_core.Type_msg = vx_core.vx_msg_from_exception(
        "sync<-async", ex
      )
      val value : vx_core.Type_any = generic_any_1.vx_new(
        msg
      )
      output = vx_core.f_any_from_any(
        generic_any_1, value
      )
    }
    return output
  }

  interface Type_any {
    fun vx_new(vararg vals : Any) : vx_core.Type_any
    fun vx_copy(vararg vals : Any) : vx_core.Type_any
    fun vx_empty() : vx_core.Type_any
    fun vx_type() : vx_core.Type_any
    fun vx_typedef() : vx_core.Type_typedef
    fun vx_constdef() : vx_core.Type_constdef
    fun vx_dispose() : List<vx_core.Type_any>
    fun vx_msgblock() : vx_core.Type_msgblock
    fun vx_release() : Boolean
    fun vx_reserve() : Unit
  }

  class Class_any : vx_core.Class_base, Type_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.vx_copy(vx_core.e_any, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any = this
      var ischanged : Boolean = false
      var value : vx_core.Class_any = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_any = vx_core.Class_any()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "any", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_any : vx_core.Type_any = vx_core.Class_any()
  val t_any : vx_core.Type_any = vx_core.Class_any()

  interface Type_any_async_from_func : vx_core.Type_any {
  }

  class Class_any_async_from_func : vx_core.Class_base, Type_any_async_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any_async_from_func = vx_core.vx_copy(vx_core.e_any_async_from_func, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any_async_from_func = this
      var ischanged : Boolean = false
      var value : vx_core.Class_any_async_from_func = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_any_async_from_func = vx_core.Class_any_async_from_func()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_async_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_async_from_func
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "any-async<-func", // name
        ":func", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_any_async_from_func : vx_core.Type_any_async_from_func = vx_core.Class_any_async_from_func()
  val t_any_async_from_func : vx_core.Type_any_async_from_func = vx_core.Class_any_async_from_func()

  interface Type_any_from_anylist : vx_core.Type_list {
    fun vx_listany_from_any() : List<vx_core.Func_any_from_any>
    fun vx_any_from_any(index : vx_core.Type_int) : vx_core.Func_any_from_any
  }

  class Class_any_from_anylist : vx_core.Class_base, Type_any_from_anylist {
    constructor() {}

    var vx_p_list : List<vx_core.Func_any_from_any> = vx_core.immutablelist(
      ArrayList<vx_core.Func_any_from_any>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_any_from_any(index : vx_core.Type_int) : vx_core.Func_any_from_any {
      var output : vx_core.Func_any_from_any = vx_core.e_any_from_any
      var list : vx_core.Class_any_from_anylist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Func_any_from_any> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listany_from_any() : List<vx_core.Func_any_from_any> {
      var output : List<vx_core.Func_any_from_any> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Func_any_from_any = this.vx_any_from_any(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any_from_anylist = vx_core.vx_copy(vx_core.e_any_from_anylist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_any_from_anylist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_any_from_anylist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Func_any_from_any> = ArrayList<vx_core.Func_any_from_any>(value.vx_listany_from_any())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_any_from_anylist) {
          var multi : vx_core.Type_any_from_anylist = valsub as vx_core.Type_any_from_anylist
          ischanged = true
          listval.addAll(multi.vx_listany_from_any())
        } else if (valsub is vx_core.Func_any_from_any) {
          var allowsub : vx_core.Func_any_from_any = valsub as vx_core.Func_any_from_any
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Func_any_from_any) {
              var valitem : vx_core.Func_any_from_any = item as vx_core.Func_any_from_any
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/any<-anylist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/any<-anylist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_any_from_anylist = vx_core.Class_any_from_anylist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_anylist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_anylist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "any<-anylist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_any_from_anylist : vx_core.Type_any_from_anylist = vx_core.Class_any_from_anylist()
  val t_any_from_anylist : vx_core.Type_any_from_anylist = vx_core.Class_any_from_anylist()

  interface Type_anylist : vx_core.Type_list {
  }

  class Class_anylist : vx_core.Class_base, Type_anylist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_any> = vx_core.immutablelist(
      ArrayList<vx_core.Type_any>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var list : vx_core.Class_anylist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_any> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_anylist = vx_core.vx_copy(vx_core.e_anylist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_anylist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_anylist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_any> = ArrayList<vx_core.Type_any>(value.vx_list())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_anylist) {
          var multi : vx_core.Type_anylist = valsub as vx_core.Type_anylist
          ischanged = true
          listval.addAll(multi.vx_list())
        } else if (valsub is vx_core.Type_any) {
          var allowsub : vx_core.Type_any = valsub as vx_core.Type_any
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_any) {
              var valitem : vx_core.Type_any = item as vx_core.Type_any
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/anylist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/anylist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_anylist = vx_core.Class_anylist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_anylist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_anylist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "anylist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_anylist : vx_core.Type_anylist = vx_core.Class_anylist()
  val t_anylist : vx_core.Type_anylist = vx_core.Class_anylist()

  interface Type_anymap : vx_core.Type_map {
  }

  class Class_anymap : vx_core.Class_base, Type_anymap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_any) {
        var castval : vx_core.Type_any = value as vx_core.Type_any
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
        if (castval == vx_core.e_any) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Class_anymap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_any> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_any)
      return output
    }

    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_anymap = vx_core.Class_anymap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_any) {
          var castval : vx_core.Type_any = value as vx_core.Type_any
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/anymap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_anymap = vx_core.vx_copy(vx_core.e_anymap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_anymap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_anymap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(value.vx_map())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/anymap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_any = vx_core.e_any
          if (false) {
          } else if (valsub is vx_core.Type_any) {
            var valallowed : vx_core.Type_any = valsub as vx_core.Type_any
            valany = valallowed
          } else if (valsub is vx_core.Type_any) {
            valany = valsub as vx_core.Type_any
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/anymap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_anymap = vx_core.Class_anymap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_anymap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_anymap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "anymap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_anymap : vx_core.Type_anymap = vx_core.Class_anymap()
  val t_anymap : vx_core.Type_anymap = vx_core.Class_anymap()

  interface Type_anytype : vx_core.Type_any {
  }

  class Class_anytype : vx_core.Class_base, Type_anytype {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_anytype = vx_core.vx_copy(vx_core.e_anytype, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_anytype = this
      var ischanged : Boolean = false
      var value : vx_core.Class_anytype = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_anytype = vx_core.Class_anytype()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_anytype
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_anytype
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "anytype", // name
        ":type", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_anytype : vx_core.Type_anytype = vx_core.Class_anytype()
  val t_anytype : vx_core.Type_anytype = vx_core.Class_anytype()

  interface Type_arg : vx_core.Type_struct {
    fun name() : vx_core.Type_string
    fun argtype() : vx_core.Type_any
    fun fn_any() : vx_core.Func_any_from_func
    fun doc() : vx_core.Type_string
  }

  class Class_arg : vx_core.Class_base, Type_arg {
    constructor() {}

    var vx_p_name : vx_core.Type_string? = null

    override fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_name
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_argtype : vx_core.Type_any? = null

    override fun argtype() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var testnull : vx_core.Type_any? = vx_p_argtype
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_fn_any : vx_core.Func_any_from_func? = null

    override fun fn_any() : vx_core.Func_any_from_func {
      var output : vx_core.Func_any_from_func = vx_core.e_any_from_func
      var testnull : vx_core.Func_any_from_func? = vx_p_fn_any
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_doc : vx_core.Type_string? = null

    override fun doc() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_doc
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":name")) {
        output = this.name()
      } else if ((skey==":argtype")) {
        output = this.argtype()
      } else if ((skey==":fn-any")) {
        output = this.fn_any()
      } else if ((skey==":doc")) {
        output = this.doc()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":name", this.name())
      map.put(":argtype", this.argtype())
      map.put(":fn-any", this.fn_any())
      map.put(":doc", this.doc())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_arg = vx_core.vx_copy(vx_core.e_arg, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_arg = this
      var ischanged : Boolean = false
      var value : vx_core.Class_arg = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_argtype : vx_core.Type_any = value.argtype()
      var vx_p_fn_any : vx_core.Func_any_from_func = value.fn_any()
      var vx_p_doc : vx_core.Type_string = value.doc()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":name")
      validkeys.add(":argtype")
      validkeys.add(":fn-any")
      validkeys.add(":doc")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":argtype")) {
            if (valsub == vx_p_argtype) {
            } else if (valsub is vx_core.Type_any) {
              var valargtype : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_argtype = valargtype
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("argtype"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":fn-any")) {
            if (valsub == vx_p_fn_any) {
            } else if (valsub is vx_core.Func_any_from_func) {
              var valfn_any : vx_core.Func_any_from_func = valsub as vx_core.Func_any_from_func
              ischanged = true
              vx_p_fn_any = valfn_any
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("fn-any"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":doc")) {
            if (valsub == vx_p_doc) {
            } else if (valsub is vx_core.Type_string) {
              var valdoc : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_doc = valdoc
            } else if (valsub is String) {
              ischanged = true
              vx_p_doc = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("doc"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/arg", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_arg = vx_core.Class_arg()
        work.vx_p_name = vx_p_name
        work.vx_p_argtype = vx_p_argtype
        work.vx_p_fn_any = vx_p_fn_any
        work.vx_p_doc = vx_p_doc
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_arg
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_arg
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "arg", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_arg : vx_core.Type_arg = vx_core.Class_arg()
  val t_arg : vx_core.Type_arg = vx_core.Class_arg()

  interface Type_arglist : vx_core.Type_list {
    fun vx_listarg() : List<vx_core.Type_arg>
    fun vx_arg(index : vx_core.Type_int) : vx_core.Type_arg
  }

  class Class_arglist : vx_core.Class_base, Type_arglist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_arg> = vx_core.immutablelist(
      ArrayList<vx_core.Type_arg>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_arg(index : vx_core.Type_int) : vx_core.Type_arg {
      var output : vx_core.Type_arg = vx_core.e_arg
      var list : vx_core.Class_arglist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_arg> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listarg() : List<vx_core.Type_arg> {
      var output : List<vx_core.Type_arg> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_arg = this.vx_arg(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_arglist = vx_core.vx_copy(vx_core.e_arglist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_arglist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_arglist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_arg> = ArrayList<vx_core.Type_arg>(value.vx_listarg())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_arglist) {
          var multi : vx_core.Type_arglist = valsub as vx_core.Type_arglist
          ischanged = true
          listval.addAll(multi.vx_listarg())
        } else if (valsub is vx_core.Type_arg) {
          var allowsub : vx_core.Type_arg = valsub as vx_core.Type_arg
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is vx_core.Type_arg) {
          ischanged = true
          listval.add(valsub as vx_core.Type_arg)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_arg) {
              var valitem : vx_core.Type_arg = item as vx_core.Type_arg
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/arglist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/arglist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_arglist = vx_core.Class_arglist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_arglist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_arglist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "arglist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_arg), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_arglist : vx_core.Type_arglist = vx_core.Class_arglist()
  val t_arglist : vx_core.Type_arglist = vx_core.Class_arglist()

  interface Type_argmap : vx_core.Type_map {
    fun vx_maparg() : Map<String, vx_core.Type_arg>
    fun vx_arg(key : vx_core.Type_string) : vx_core.Type_arg
  }

  class Class_argmap : vx_core.Class_base, Type_argmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_arg> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_arg>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_arg) {
        var castval : vx_core.Type_arg = value as vx_core.Type_arg
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_arg> = LinkedHashMap<String, vx_core.Type_arg>(this.vx_p_map)
        if (castval == vx_core.e_arg) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_arg(key : vx_core.Type_string) : vx_core.Type_arg {
      var output : vx_core.Type_arg = vx_core.e_arg
      var map : vx_core.Class_argmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_arg> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_arg)
      return output
    }

    override fun vx_maparg() : Map<String, vx_core.Type_arg> {
      var output : Map<String, vx_core.Type_arg> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_arg(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_argmap = vx_core.Class_argmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_arg> = LinkedHashMap<String, vx_core.Type_arg>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_arg) {
          var castval : vx_core.Type_arg = value as vx_core.Type_arg
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/argmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_argmap = vx_core.vx_copy(vx_core.e_argmap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_argmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_argmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_arg> = LinkedHashMap<String, vx_core.Type_arg>(value.vx_maparg())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/argmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_arg = vx_core.e_arg
          if (false) {
          } else if (valsub is vx_core.Type_arg) {
            var valallowed : vx_core.Type_arg = valsub as vx_core.Type_arg
            valany = valallowed
          } else if (valsub is vx_core.Type_arg) {
            valany = valsub as vx_core.Type_arg
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/argmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_argmap = vx_core.Class_argmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_argmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_argmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "argmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_arg), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_argmap : vx_core.Type_argmap = vx_core.Class_argmap()
  val t_argmap : vx_core.Type_argmap = vx_core.Class_argmap()

  interface Type_boolean : vx_core.Type_any {
    fun vx_boolean() : Boolean
  }

  class Class_boolean : vx_core.Class_base, Type_boolean {
    constructor() {}

    internal var vxboolean : Boolean = false
    
    // :implements
    override fun vx_boolean() : Boolean {
      return vxboolean;
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_boolean = vx_core.vx_copy(vx_core.e_boolean, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_boolean = this
      var ischanged : Boolean = false
      var value : vx_core.Class_boolean = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var booleanval : Boolean = value.vx_boolean()
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_boolean) {
          var valboolean : vx_core.Type_boolean = valsub as vx_core.Type_boolean
          booleanval = booleanval || valboolean.vx_boolean()
        } else if (valsub is Boolean) {
          var issubval : Boolean = valsub as Boolean
          booleanval = booleanval || issubval
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_boolean = vx_core.Class_boolean()
        work.vxboolean = booleanval
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      } else if (booleanval) {
        output = vx_core.c_true
      } else {
        output = vx_core.c_false
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "boolean", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val t_boolean : vx_core.Type_boolean = vx_core.Class_boolean()

  interface Type_booleanlist : vx_core.Type_list {
    fun vx_listboolean() : List<vx_core.Type_boolean>
    fun vx_boolean(index : vx_core.Type_int) : vx_core.Type_boolean
  }

  class Class_booleanlist : vx_core.Class_base, Type_booleanlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_boolean> = vx_core.immutablelist(
      ArrayList<vx_core.Type_boolean>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_boolean(index : vx_core.Type_int) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.e_boolean
      var list : vx_core.Class_booleanlist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_boolean> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listboolean() : List<vx_core.Type_boolean> {
      var output : List<vx_core.Type_boolean> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_boolean = this.vx_boolean(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_booleanlist = vx_core.vx_copy(vx_core.e_booleanlist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_booleanlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_booleanlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_boolean> = ArrayList<vx_core.Type_boolean>(value.vx_listboolean())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_booleanlist) {
          var multi : vx_core.Type_booleanlist = valsub as vx_core.Type_booleanlist
          ischanged = true
          listval.addAll(multi.vx_listboolean())
        } else if (valsub is vx_core.Type_boolean) {
          var allowsub : vx_core.Type_boolean = valsub as vx_core.Type_boolean
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is Boolean) {
          ischanged = true
          listval.add(vx_core.vx_new(vx_core.t_boolean, valsub))
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_boolean) {
              var valitem : vx_core.Type_boolean = item as vx_core.Type_boolean
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/booleanlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/booleanlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_booleanlist = vx_core.Class_booleanlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_booleanlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_booleanlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "booleanlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_boolean), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_booleanlist : vx_core.Type_booleanlist = vx_core.Class_booleanlist()
  val t_booleanlist : vx_core.Type_booleanlist = vx_core.Class_booleanlist()

  interface Type_collection : vx_core.Type_any {
  }

  class Class_collection : vx_core.Class_base, Type_collection {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_collection = vx_core.vx_copy(vx_core.e_collection, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_collection = this
      var ischanged : Boolean = false
      var value : vx_core.Class_collection = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_collection = vx_core.Class_collection()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_collection
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_collection
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "collection", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_list, vx_core.t_map), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_collection : vx_core.Type_collection = vx_core.Class_collection()
  val t_collection : vx_core.Type_collection = vx_core.Class_collection()

  interface Type_compilelanguages : vx_core.Type_any {
  }

  class Class_compilelanguages : vx_core.Class_base, Type_compilelanguages {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_compilelanguages = vx_core.vx_copy(vx_core.e_compilelanguages, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_compilelanguages = this
      var ischanged : Boolean = false
      var value : vx_core.Class_compilelanguages = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_compilelanguages = vx_core.Class_compilelanguages()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_compilelanguages
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_compilelanguages
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "compilelanguages", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_compilelanguages : vx_core.Type_compilelanguages = vx_core.Class_compilelanguages()
  val t_compilelanguages : vx_core.Type_compilelanguages = vx_core.Class_compilelanguages()

  interface Type_connect : vx_core.Type_any {
  }

  class Class_connect : vx_core.Class_base, Type_connect {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_connect = vx_core.vx_copy(vx_core.e_connect, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_connect = this
      var ischanged : Boolean = false
      var value : vx_core.Class_connect = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_connect = vx_core.Class_connect()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_connect
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_connect
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "connect", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_connect : vx_core.Type_connect = vx_core.Class_connect()
  val t_connect : vx_core.Type_connect = vx_core.Class_connect()

  interface Type_connectlist : vx_core.Type_list {
    fun vx_listconnect() : List<vx_core.Type_connect>
    fun vx_connect(index : vx_core.Type_int) : vx_core.Type_connect
  }

  class Class_connectlist : vx_core.Class_base, Type_connectlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_connect> = vx_core.immutablelist(
      ArrayList<vx_core.Type_connect>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_connect(index : vx_core.Type_int) : vx_core.Type_connect {
      var output : vx_core.Type_connect = vx_core.e_connect
      var list : vx_core.Class_connectlist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_connect> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listconnect() : List<vx_core.Type_connect> {
      var output : List<vx_core.Type_connect> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_connect = this.vx_connect(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_connectlist = vx_core.vx_copy(vx_core.e_connectlist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_connectlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_connectlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_connect> = ArrayList<vx_core.Type_connect>(value.vx_listconnect())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_connectlist) {
          var multi : vx_core.Type_connectlist = valsub as vx_core.Type_connectlist
          ischanged = true
          listval.addAll(multi.vx_listconnect())
        } else if (valsub is vx_core.Type_connect) {
          var allowsub : vx_core.Type_connect = valsub as vx_core.Type_connect
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is vx_core.Type_connect) {
          ischanged = true
          listval.add(valsub as vx_core.Type_connect)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_connect) {
              var valitem : vx_core.Type_connect = item as vx_core.Type_connect
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/connectlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/connectlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_connectlist = vx_core.Class_connectlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_connectlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_connectlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "connectlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_connect), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_connectlist : vx_core.Type_connectlist = vx_core.Class_connectlist()
  val t_connectlist : vx_core.Type_connectlist = vx_core.Class_connectlist()

  interface Type_connectmap : vx_core.Type_map {
    fun vx_mapconnect() : Map<String, vx_core.Type_connect>
    fun vx_connect(key : vx_core.Type_string) : vx_core.Type_connect
  }

  class Class_connectmap : vx_core.Class_base, Type_connectmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_connect> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_connect>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_connect) {
        var castval : vx_core.Type_connect = value as vx_core.Type_connect
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_connect> = LinkedHashMap<String, vx_core.Type_connect>(this.vx_p_map)
        if (castval == vx_core.e_connect) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_connect(key : vx_core.Type_string) : vx_core.Type_connect {
      var output : vx_core.Type_connect = vx_core.e_connect
      var map : vx_core.Class_connectmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_connect> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_connect)
      return output
    }

    override fun vx_mapconnect() : Map<String, vx_core.Type_connect> {
      var output : Map<String, vx_core.Type_connect> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_connect(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_connectmap = vx_core.Class_connectmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_connect> = LinkedHashMap<String, vx_core.Type_connect>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_connect) {
          var castval : vx_core.Type_connect = value as vx_core.Type_connect
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/connectmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_connectmap = vx_core.vx_copy(vx_core.e_connectmap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_connectmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_connectmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_connect> = LinkedHashMap<String, vx_core.Type_connect>(value.vx_mapconnect())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/connectmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_connect = vx_core.e_connect
          if (false) {
          } else if (valsub is vx_core.Type_connect) {
            var valallowed : vx_core.Type_connect = valsub as vx_core.Type_connect
            valany = valallowed
          } else if (valsub is vx_core.Type_connect) {
            valany = valsub as vx_core.Type_connect
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/connectmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_connectmap = vx_core.Class_connectmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_connectmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_connectmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "connectmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_connect), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_connectmap : vx_core.Type_connectmap = vx_core.Class_connectmap()
  val t_connectmap : vx_core.Type_connectmap = vx_core.Class_connectmap()

  interface Type_const : vx_core.Type_any {
  }

  class Class_const : vx_core.Class_base, Type_const {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_const = vx_core.vx_copy(vx_core.e_const, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_const = this
      var ischanged : Boolean = false
      var value : vx_core.Class_const = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_const = vx_core.Class_const()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_const
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_const
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "const", // name
        ":const", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_const : vx_core.Type_const = vx_core.Class_const()
  val t_const : vx_core.Type_const = vx_core.Class_const()

  interface Type_constdef : vx_core.Type_struct {
    fun pkgname() : vx_core.Type_string
    fun name() : vx_core.Type_string
    fun type() : vx_core.Type_any
  }

  class Class_constdef : vx_core.Class_base, Type_constdef {
    constructor() {}

    var vx_p_pkgname : vx_core.Type_string? = null

    override fun pkgname() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_pkgname
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_name : vx_core.Type_string? = null

    override fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_name
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_type : vx_core.Type_any? = null

    override fun type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var testnull : vx_core.Type_any? = vx_p_type
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":pkgname")) {
        output = this.pkgname()
      } else if ((skey==":name")) {
        output = this.name()
      } else if ((skey==":type")) {
        output = this.type()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":pkgname", this.pkgname())
      map.put(":name", this.name())
      map.put(":type", this.type())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_constdef = vx_core.vx_copy(vx_core.e_constdef, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_constdef = this
      var ischanged : Boolean = false
      var value : vx_core.Class_constdef = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pkgname : vx_core.Type_string = value.pkgname()
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_type : vx_core.Type_any = value.type()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":pkgname")
      validkeys.add(":name")
      validkeys.add(":type")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":pkgname")) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub is vx_core.Type_string) {
              var valpkgname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_pkgname = valpkgname
            } else if (valsub is String) {
              ischanged = true
              vx_p_pkgname = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pkgname"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":type")) {
            if (valsub == vx_p_type) {
            } else if (valsub is vx_core.Type_any) {
              var valtype : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_type = valtype
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("type"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/constdef", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_constdef = vx_core.Class_constdef()
        work.vx_p_pkgname = vx_p_pkgname
        work.vx_p_name = vx_p_name
        work.vx_p_type = vx_p_type
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_constdef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_constdef
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "constdef", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_constdef : vx_core.Type_constdef = vx_core.Class_constdef()
  val t_constdef : vx_core.Type_constdef = vx_core.Class_constdef()

  interface Type_constlist : vx_core.Type_list {
  }

  class Class_constlist : vx_core.Class_base, Type_constlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_any> = vx_core.immutablelist(
      ArrayList<vx_core.Type_any>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var list : vx_core.Class_constlist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_any> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_constlist = vx_core.vx_copy(vx_core.e_constlist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_constlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_constlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_any> = ArrayList<vx_core.Type_any>(value.vx_list())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_constlist) {
          var multi : vx_core.Type_constlist = valsub as vx_core.Type_constlist
          ischanged = true
          listval.addAll(multi.vx_list())
        } else if (valsub is vx_core.Type_any) {
          var allowsub : vx_core.Type_any = valsub as vx_core.Type_any
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_any) {
              var valitem : vx_core.Type_any = item as vx_core.Type_any
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/constlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/constlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_constlist = vx_core.Class_constlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_constlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_constlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "constlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_constlist : vx_core.Type_constlist = vx_core.Class_constlist()
  val t_constlist : vx_core.Type_constlist = vx_core.Class_constlist()

  interface Type_constmap : vx_core.Type_map {
  }

  class Class_constmap : vx_core.Class_base, Type_constmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_any) {
        var castval : vx_core.Type_any = value as vx_core.Type_any
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
        if (castval == vx_core.e_any) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Class_constmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_any> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_any)
      return output
    }

    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_constmap = vx_core.Class_constmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_any) {
          var castval : vx_core.Type_any = value as vx_core.Type_any
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/constmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_constmap = vx_core.vx_copy(vx_core.e_constmap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_constmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_constmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(value.vx_map())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/constmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_any = vx_core.e_any
          if (false) {
          } else if (valsub is vx_core.Type_any) {
            var valallowed : vx_core.Type_any = valsub as vx_core.Type_any
            valany = valallowed
          } else if (valsub is vx_core.Type_any) {
            valany = valsub as vx_core.Type_any
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/constmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_constmap = vx_core.Class_constmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_constmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_constmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "constmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_constmap : vx_core.Type_constmap = vx_core.Class_constmap()
  val t_constmap : vx_core.Type_constmap = vx_core.Class_constmap()

  interface Type_context : vx_core.Type_struct {
    fun code() : vx_core.Type_string
    fun session() : vx_core.Type_session
    fun setting() : vx_core.Type_setting
    fun state() : vx_core.Type_state
  }

  class Class_context : vx_core.Class_base, Type_context {
    constructor() {}

    var vx_p_code : vx_core.Type_string? = null

    override fun code() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_code
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_session : vx_core.Type_session? = null

    override fun session() : vx_core.Type_session {
      var output : vx_core.Type_session = vx_core.e_session
      var testnull : vx_core.Type_session? = vx_p_session
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_setting : vx_core.Type_setting? = null

    override fun setting() : vx_core.Type_setting {
      var output : vx_core.Type_setting = vx_core.e_setting
      var testnull : vx_core.Type_setting? = vx_p_setting
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_state : vx_core.Type_state? = null

    override fun state() : vx_core.Type_state {
      var output : vx_core.Type_state = vx_core.e_state
      var testnull : vx_core.Type_state? = vx_p_state
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":code")) {
        output = this.code()
      } else if ((skey==":session")) {
        output = this.session()
      } else if ((skey==":setting")) {
        output = this.setting()
      } else if ((skey==":state")) {
        output = this.state()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":code", this.code())
      map.put(":session", this.session())
      map.put(":setting", this.setting())
      map.put(":state", this.state())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_context = vx_core.vx_copy(vx_core.e_context, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_context = this
      var ischanged : Boolean = false
      var value : vx_core.Class_context = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_code : vx_core.Type_string = value.code()
      var vx_p_session : vx_core.Type_session = value.session()
      var vx_p_setting : vx_core.Type_setting = value.setting()
      var vx_p_state : vx_core.Type_state = value.state()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":code")
      validkeys.add(":session")
      validkeys.add(":setting")
      validkeys.add(":state")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":code")) {
            if (valsub == vx_p_code) {
            } else if (valsub is vx_core.Type_string) {
              var valcode : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_code = valcode
            } else if (valsub is String) {
              ischanged = true
              vx_p_code = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("code"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":session")) {
            if (valsub == vx_p_session) {
            } else if (valsub is vx_core.Type_session) {
              var valsession : vx_core.Type_session = valsub as vx_core.Type_session
              ischanged = true
              vx_p_session = valsession
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("session"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":setting")) {
            if (valsub == vx_p_setting) {
            } else if (valsub is vx_core.Type_setting) {
              var valsetting : vx_core.Type_setting = valsub as vx_core.Type_setting
              ischanged = true
              vx_p_setting = valsetting
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("setting"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":state")) {
            if (valsub == vx_p_state) {
            } else if (valsub is vx_core.Type_state) {
              var valstate : vx_core.Type_state = valsub as vx_core.Type_state
              ischanged = true
              vx_p_state = valstate
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("state"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/context", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_context = vx_core.Class_context()
        work.vx_p_code = vx_p_code
        work.vx_p_session = vx_p_session
        work.vx_p_setting = vx_p_setting
        work.vx_p_state = vx_p_state
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_context
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "context", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_context : vx_core.Type_context = vx_core.Class_context()
  val t_context : vx_core.Type_context = vx_core.Class_context()

  interface Type_date : vx_core.Type_any {
  }

  class Class_date : vx_core.Class_base, Type_date {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_date = vx_core.vx_copy(vx_core.e_date, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_date = this
      var ischanged : Boolean = false
      var value : vx_core.Class_date = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_date = vx_core.Class_date()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_date
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_date
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "date", // name
        ":string", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_date : vx_core.Type_date = vx_core.Class_date()
  val t_date : vx_core.Type_date = vx_core.Class_date()

  interface Type_decimal : vx_core.Type_number {
    fun vx_float() : Float
    fun vx_string() : String
  }

  class Class_decimal : vx_core.Class_base, Type_decimal {
    constructor() {}

    internal var vxdecimal : String = "0.0"
    
    // :implements
    override fun vx_float() : Float {
      return vxdecimal.toFloat()
    }
    
    // :implements
    override fun vx_string() : String {
      return vxdecimal
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_decimal = vx_core.vx_copy(vx_core.e_decimal, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_decimal = this
      var ischanged : Boolean = false
      var value : vx_core.Class_decimal = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var sval : String = value.vx_string()
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_string) {
          var valstring : vx_core.Type_string = valsub as vx_core.Type_string
          ischanged = true
          sval = valstring.vx_string()
        } else if (valsub is String) {
          var svalsub : String = valsub as String
          ischanged = true
          sval = svalsub
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_decimal = vx_core.Class_decimal()
        work.vxdecimal = sval
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_decimal
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_decimal
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "decimal", // name
        "", // extends
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_decimal : vx_core.Type_decimal = vx_core.Class_decimal()
  val t_decimal : vx_core.Type_decimal = vx_core.Class_decimal()

  interface Type_error : vx_core.Type_any {
  }

  class Class_error : vx_core.Class_base, Type_error {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_error = vx_core.vx_copy(vx_core.e_error, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_error = this
      var ischanged : Boolean = false
      var value : vx_core.Class_error = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_error = vx_core.Class_error()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_error
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_error
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "error", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_error : vx_core.Type_error = vx_core.Class_error()
  val t_error : vx_core.Type_error = vx_core.Class_error()

  interface Type_float : vx_core.Type_number {
    fun vx_float() : Float
  }

  class Class_float : vx_core.Class_base, Type_float {
    constructor() {}

    internal var vxfloat : Float = 0f
    
    // :implements
    override fun vx_float() : Float {
      return vxfloat
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_float = vx_core.vx_copy(vx_core.e_float, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_float = this
      var ischanged : Boolean = false
      var value : vx_core.Class_float = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var floatval : Float = value.vx_float()
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_decimal) {
          var valdecimal : vx_core.Type_decimal = valsub as vx_core.Type_decimal
          ischanged = true
          floatval += valdecimal.vx_float()
        } else if (valsub is vx_core.Type_float) {
          var valfloat : vx_core.Type_float = valsub as vx_core.Type_float
          ischanged = true
          floatval += valfloat.vx_float()
        } else if (valsub is vx_core.Type_int) {
          var valint : vx_core.Type_int = valsub as vx_core.Type_int
          ischanged = true
          floatval += valint.vx_int()
        } else if (valsub is vx_core.Type_string) {
          var valstring : vx_core.Type_string = valsub as vx_core.Type_string
          ischanged = true
          floatval += valstring.vx_string().toFloat()
        } else if (valsub is Float) {
          var fval : Float = valsub as Float
          ischanged = true
          floatval += fval
        } else if (valsub is Int) {
          var ival : Int = valsub as Int
          ischanged = true
          floatval += ival
        } else if (valsub is String) {
          var sval : String = valsub as String
          ischanged = true
          floatval += sval.toFloat()
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_float = vx_core.Class_float()
        work.vxfloat = floatval
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_float
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_float
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "float", // name
        "", // extends
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_float : vx_core.Type_float = vx_core.Class_float()
  val t_float : vx_core.Type_float = vx_core.Class_float()

  interface Type_func : vx_core.Type_any {
    fun vx_funcdef() : vx_core.Type_funcdef
  }

  class Class_func : vx_core.Class_base, Type_func {
    constructor() {}

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.e_funcdef
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_func = vx_core.vx_copy(vx_core.e_func, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_func = this
      var ischanged : Boolean = false
      var value : vx_core.Class_func = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_func = vx_core.Class_func()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_func
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "func", // name
        ":func", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_func : vx_core.Type_func = vx_core.Class_func()
  val t_func : vx_core.Type_func = vx_core.Class_func()

  interface Type_funcdef : vx_core.Type_struct {
    fun pkgname() : vx_core.Type_string
    fun name() : vx_core.Type_string
    fun idx() : vx_core.Type_int
    fun type() : vx_core.Type_any
    fun async() : vx_core.Type_boolean
  }

  class Class_funcdef : vx_core.Class_base, Type_funcdef {
    constructor() {}

    var vx_p_pkgname : vx_core.Type_string? = null

    override fun pkgname() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_pkgname
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_name : vx_core.Type_string? = null

    override fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_name
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_idx : vx_core.Type_int? = null

    override fun idx() : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      var testnull : vx_core.Type_int? = vx_p_idx
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_type : vx_core.Type_any? = null

    override fun type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var testnull : vx_core.Type_any? = vx_p_type
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_async : vx_core.Type_boolean? = null

    override fun async() : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.e_boolean
      var testnull : vx_core.Type_boolean? = vx_p_async
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":pkgname")) {
        output = this.pkgname()
      } else if ((skey==":name")) {
        output = this.name()
      } else if ((skey==":idx")) {
        output = this.idx()
      } else if ((skey==":type")) {
        output = this.type()
      } else if ((skey==":async")) {
        output = this.async()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":pkgname", this.pkgname())
      map.put(":name", this.name())
      map.put(":idx", this.idx())
      map.put(":type", this.type())
      map.put(":async", this.async())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_funcdef = vx_core.vx_copy(vx_core.e_funcdef, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_funcdef = this
      var ischanged : Boolean = false
      var value : vx_core.Class_funcdef = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pkgname : vx_core.Type_string = value.pkgname()
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_idx : vx_core.Type_int = value.idx()
      var vx_p_type : vx_core.Type_any = value.type()
      var vx_p_async : vx_core.Type_boolean = value.async()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":pkgname")
      validkeys.add(":name")
      validkeys.add(":idx")
      validkeys.add(":type")
      validkeys.add(":async")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":pkgname")) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub is vx_core.Type_string) {
              var valpkgname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_pkgname = valpkgname
            } else if (valsub is String) {
              ischanged = true
              vx_p_pkgname = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pkgname"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":idx")) {
            if (valsub == vx_p_idx) {
            } else if (valsub is vx_core.Type_int) {
              var validx : vx_core.Type_int = valsub as vx_core.Type_int
              ischanged = true
              vx_p_idx = validx
            } else if (valsub is Int) {
              ischanged = true
              vx_p_idx = vx_core.vx_new(vx_core.t_int, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("idx"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":type")) {
            if (valsub == vx_p_type) {
            } else if (valsub is vx_core.Type_any) {
              var valtype : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_type = valtype
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("type"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":async")) {
            if (valsub == vx_p_async) {
            } else if (valsub is vx_core.Type_boolean) {
              var valasync : vx_core.Type_boolean = valsub as vx_core.Type_boolean
              ischanged = true
              vx_p_async = valasync
            } else if (valsub is Boolean) {
              ischanged = true
              vx_p_async = vx_core.vx_new(vx_core.t_boolean, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("async"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/funcdef", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_funcdef = vx_core.Class_funcdef()
        work.vx_p_pkgname = vx_p_pkgname
        work.vx_p_name = vx_p_name
        work.vx_p_idx = vx_p_idx
        work.vx_p_type = vx_p_type
        work.vx_p_async = vx_p_async
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funcdef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funcdef
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "funcdef", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_funcdef : vx_core.Type_funcdef = vx_core.Class_funcdef()
  val t_funcdef : vx_core.Type_funcdef = vx_core.Class_funcdef()

  interface Type_funclist : vx_core.Type_list {
    fun vx_listfunc() : List<vx_core.Type_func>
    fun vx_func(index : vx_core.Type_int) : vx_core.Type_func
  }

  class Class_funclist : vx_core.Class_base, Type_funclist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_func> = vx_core.immutablelist(
      ArrayList<vx_core.Type_func>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_func(index : vx_core.Type_int) : vx_core.Type_func {
      var output : vx_core.Type_func = vx_core.e_func
      var list : vx_core.Class_funclist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_func> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listfunc() : List<vx_core.Type_func> {
      var output : List<vx_core.Type_func> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_func = this.vx_func(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_funclist = vx_core.vx_copy(vx_core.e_funclist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_funclist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_funclist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_func> = ArrayList<vx_core.Type_func>(value.vx_listfunc())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_funclist) {
          var multi : vx_core.Type_funclist = valsub as vx_core.Type_funclist
          ischanged = true
          listval.addAll(multi.vx_listfunc())
        } else if (valsub is vx_core.Type_func) {
          var allowsub : vx_core.Type_func = valsub as vx_core.Type_func
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is vx_core.Type_func) {
          ischanged = true
          listval.add(valsub as vx_core.Type_func)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_func) {
              var valitem : vx_core.Type_func = item as vx_core.Type_func
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/funclist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/funclist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_funclist = vx_core.Class_funclist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funclist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funclist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "funclist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_func), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_funclist : vx_core.Type_funclist = vx_core.Class_funclist()
  val t_funclist : vx_core.Type_funclist = vx_core.Class_funclist()

  interface Type_funcmap : vx_core.Type_map {
    fun vx_mapfunc() : Map<String, vx_core.Type_func>
    fun vx_func(key : vx_core.Type_string) : vx_core.Type_func
  }

  class Class_funcmap : vx_core.Class_base, Type_funcmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_func> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_func>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_func) {
        var castval : vx_core.Type_func = value as vx_core.Type_func
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_func> = LinkedHashMap<String, vx_core.Type_func>(this.vx_p_map)
        if (castval == vx_core.e_func) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_func(key : vx_core.Type_string) : vx_core.Type_func {
      var output : vx_core.Type_func = vx_core.e_func
      var map : vx_core.Class_funcmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_func> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_func)
      return output
    }

    override fun vx_mapfunc() : Map<String, vx_core.Type_func> {
      var output : Map<String, vx_core.Type_func> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_func(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_funcmap = vx_core.Class_funcmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_func> = LinkedHashMap<String, vx_core.Type_func>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_func) {
          var castval : vx_core.Type_func = value as vx_core.Type_func
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/funcmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_funcmap = vx_core.vx_copy(vx_core.e_funcmap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_funcmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_funcmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_func> = LinkedHashMap<String, vx_core.Type_func>(value.vx_mapfunc())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/funcmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_func = vx_core.e_func
          if (false) {
          } else if (valsub is vx_core.Type_func) {
            var valallowed : vx_core.Type_func = valsub as vx_core.Type_func
            valany = valallowed
          } else if (valsub is vx_core.Type_func) {
            valany = valsub as vx_core.Type_func
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/funcmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_funcmap = vx_core.Class_funcmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funcmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funcmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "funcmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_func), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_funcmap : vx_core.Type_funcmap = vx_core.Class_funcmap()
  val t_funcmap : vx_core.Type_funcmap = vx_core.Class_funcmap()

  interface Type_int : vx_core.Type_number {
    fun vx_int() : Int
  }

  class Class_int : vx_core.Class_base, Type_int {
    constructor() {}

    internal var vxint : Int = 0
    
    // :implements
    override fun vx_int() : Int {
      return vxint
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_int = vx_core.vx_copy(vx_core.e_int, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_int = this
      var ischanged : Boolean = false
      var value : vx_core.Class_int = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var intval : Int = value.vx_int()
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_int) {
          var valint : vx_core.Type_int = valsub as vx_core.Type_int
          ischanged = true
          intval += valint.vx_int()
        } else if (valsub is Int) {
          var ival : Int = valsub as Int
          ischanged = true
          intval += ival
        } else if (valsub is String) {
          var sval : String = valsub as String
          ischanged = true
          intval += sval.toInt()
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_int = vx_core.Class_int()
        work.vxint = intval
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_int
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_int
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "int", // name
        "", // extends
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_int : vx_core.Type_int = vx_core.Class_int()
  val t_int : vx_core.Type_int = vx_core.Class_int()

  interface Type_intlist : vx_core.Type_list {
    fun vx_listint() : List<vx_core.Type_int>
    fun vx_int(index : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_intlist : vx_core.Class_base, Type_intlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_int> = vx_core.immutablelist(
      ArrayList<vx_core.Type_int>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_int(index : vx_core.Type_int) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      var list : vx_core.Class_intlist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_int> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listint() : List<vx_core.Type_int> {
      var output : List<vx_core.Type_int> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_int = this.vx_int(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_intlist = vx_core.vx_copy(vx_core.e_intlist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_intlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_intlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_int> = ArrayList<vx_core.Type_int>(value.vx_listint())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_intlist) {
          var multi : vx_core.Type_intlist = valsub as vx_core.Type_intlist
          ischanged = true
          listval.addAll(multi.vx_listint())
        } else if (valsub is vx_core.Type_int) {
          var allowsub : vx_core.Type_int = valsub as vx_core.Type_int
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is Int) {
          ischanged = true
          listval.add(vx_core.vx_new(vx_core.t_int, valsub))
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_int) {
              var valitem : vx_core.Type_int = item as vx_core.Type_int
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/intlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/intlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_intlist = vx_core.Class_intlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_intlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_intlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "intlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_int), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_intlist : vx_core.Type_intlist = vx_core.Class_intlist()
  val t_intlist : vx_core.Type_intlist = vx_core.Class_intlist()

  interface Type_intmap : vx_core.Type_map {
    fun vx_mapint() : Map<String, vx_core.Type_int>
    fun vx_int(key : vx_core.Type_string) : vx_core.Type_int
  }

  class Class_intmap : vx_core.Class_base, Type_intmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_int> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_int>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_int) {
        var castval : vx_core.Type_int = value as vx_core.Type_int
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_int> = LinkedHashMap<String, vx_core.Type_int>(this.vx_p_map)
        if (castval == vx_core.e_int) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_int(key : vx_core.Type_string) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      var map : vx_core.Class_intmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_int> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_int)
      return output
    }

    override fun vx_mapint() : Map<String, vx_core.Type_int> {
      var output : Map<String, vx_core.Type_int> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_int(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_intmap = vx_core.Class_intmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_int> = LinkedHashMap<String, vx_core.Type_int>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_int) {
          var castval : vx_core.Type_int = value as vx_core.Type_int
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/intmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_intmap = vx_core.vx_copy(vx_core.e_intmap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_intmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_intmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_int> = LinkedHashMap<String, vx_core.Type_int>(value.vx_mapint())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/intmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_int = vx_core.e_int
          if (false) {
          } else if (valsub is vx_core.Type_int) {
            var valallowed : vx_core.Type_int = valsub as vx_core.Type_int
            valany = valallowed
          } else if (valsub is Int) {
            valany = vx_core.vx_new(vx_core.t_int, valsub)
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/intmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_intmap = vx_core.Class_intmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_intmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_intmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "intmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_int), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_intmap : vx_core.Type_intmap = vx_core.Class_intmap()
  val t_intmap : vx_core.Type_intmap = vx_core.Class_intmap()

  interface Type_list : vx_core.Type_any {
    fun vx_list() : List<vx_core.Type_any>
    fun vx_any(index : vx_core.Type_int) : vx_core.Type_any
  }

  class Class_list : vx_core.Class_base, Type_list {
    constructor() {}

    var vx_p_list : List<vx_core.Type_any> = vx_core.immutablelist(
      ArrayList<vx_core.Type_any>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var list : vx_core.Class_list = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_any> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_list = vx_core.vx_copy(vx_core.e_list, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_list = this
      var ischanged : Boolean = false
      var value : vx_core.Class_list = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_any> = ArrayList<vx_core.Type_any>(value.vx_list())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_list) {
          var multi : vx_core.Type_list = valsub as vx_core.Type_list
          ischanged = true
          listval.addAll(multi.vx_list())
        } else if (valsub is vx_core.Type_any) {
          var allowsub : vx_core.Type_any = valsub as vx_core.Type_any
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_any) {
              var valitem : vx_core.Type_any = item as vx_core.Type_any
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/list", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/list", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_list = vx_core.Class_list()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "list", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_list : vx_core.Type_list = vx_core.Class_list()
  val t_list : vx_core.Type_list = vx_core.Class_list()

  interface Type_listtype : vx_core.Type_any {
  }

  class Class_listtype : vx_core.Class_base, Type_listtype {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_listtype = vx_core.vx_copy(vx_core.e_listtype, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_listtype = this
      var ischanged : Boolean = false
      var value : vx_core.Class_listtype = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_listtype = vx_core.Class_listtype()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_listtype
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_listtype
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "listtype", // name
        ":type", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_listtype : vx_core.Type_listtype = vx_core.Class_listtype()
  val t_listtype : vx_core.Type_listtype = vx_core.Class_listtype()

  interface Type_locale : vx_core.Type_struct {
  }

  class Class_locale : vx_core.Class_base, Type_locale {
    constructor() {}

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_locale = vx_core.vx_copy(vx_core.e_locale, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_locale = this
      var ischanged : Boolean = false
      var value : vx_core.Class_locale = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_locale = vx_core.Class_locale()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_locale
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_locale
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "locale", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_locale : vx_core.Type_locale = vx_core.Class_locale()
  val t_locale : vx_core.Type_locale = vx_core.Class_locale()

  interface Type_map : vx_core.Type_any {
    fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map
    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any
    fun vx_map() : Map<String, vx_core.Type_any>
    fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_map : vx_core.Class_base, Type_map {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_any) {
        var castval : vx_core.Type_any = value as vx_core.Type_any
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
        if (castval == vx_core.e_any) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Class_map = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_any> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_any)
      return output
    }

    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_map = vx_core.Class_map()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_any) {
          var castval : vx_core.Type_any = value as vx_core.Type_any
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/map", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_map = vx_core.vx_copy(vx_core.e_map, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_map = this
      var ischanged : Boolean = false
      var value : vx_core.Class_map = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(value.vx_map())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/map", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_any = vx_core.e_any
          if (false) {
          } else if (valsub is vx_core.Type_any) {
            var valallowed : vx_core.Type_any = valsub as vx_core.Type_any
            valany = valallowed
          } else if (valsub is vx_core.Type_any) {
            valany = valsub as vx_core.Type_any
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/map", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_map = vx_core.Class_map()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_map
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "map", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_map : vx_core.Type_map = vx_core.Class_map()
  val t_map : vx_core.Type_map = vx_core.Class_map()

  interface Type_maptype : vx_core.Type_any {
  }

  class Class_maptype : vx_core.Class_base, Type_maptype {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_maptype = vx_core.vx_copy(vx_core.e_maptype, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_maptype = this
      var ischanged : Boolean = false
      var value : vx_core.Class_maptype = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_maptype = vx_core.Class_maptype()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_maptype
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_maptype
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "maptype", // name
        ":type", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_maptype : vx_core.Type_maptype = vx_core.Class_maptype()
  val t_maptype : vx_core.Type_maptype = vx_core.Class_maptype()

  interface Type_mempool : vx_core.Type_struct {
    fun valuepool() : vx_core.Type_value
  }

  class Class_mempool : vx_core.Class_base, Type_mempool {
    constructor() {}

    var vx_p_valuepool : vx_core.Type_value? = null

    override fun valuepool() : vx_core.Type_value {
      var output : vx_core.Type_value = vx_core.e_value
      var testnull : vx_core.Type_value? = vx_p_valuepool
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":valuepool")) {
        output = this.valuepool()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":valuepool", this.valuepool())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_mempool = vx_core.vx_copy(vx_core.e_mempool, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_mempool = this
      var ischanged : Boolean = false
      var value : vx_core.Class_mempool = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_valuepool : vx_core.Type_value = value.valuepool()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":valuepool")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/mempool", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/mempool", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":valuepool")) {
            if (valsub == vx_p_valuepool) {
            } else if (valsub is vx_core.Type_value) {
              var valvaluepool : vx_core.Type_value = valsub as vx_core.Type_value
              ischanged = true
              vx_p_valuepool = valvaluepool
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("valuepool"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/mempool", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/mempool", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_mempool = vx_core.Class_mempool()
        work.vx_p_valuepool = vx_p_valuepool
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_mempool
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_mempool
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "mempool", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_mempool : vx_core.Type_mempool = vx_core.Class_mempool()
  val t_mempool : vx_core.Type_mempool = vx_core.Class_mempool()

  interface Type_msg : vx_core.Type_struct {
    fun code() : vx_core.Type_string
    fun detail() : vx_core.Type_any
    fun path() : vx_core.Type_string
    fun severity() : vx_core.Type_int
    fun text() : vx_core.Type_string
  }

  class Class_msg : vx_core.Class_base, Type_msg {
    constructor() {}

    var err : Exception? = null

    var vx_p_code : vx_core.Type_string? = null

    override fun code() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_code
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_detail : vx_core.Type_any? = null

    override fun detail() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var testnull : vx_core.Type_any? = vx_p_detail
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_path : vx_core.Type_string? = null

    override fun path() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_path
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_severity : vx_core.Type_int? = null

    override fun severity() : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      var testnull : vx_core.Type_int? = vx_p_severity
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_text : vx_core.Type_string? = null

    override fun text() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_text
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":code")) {
        output = this.code()
      } else if ((skey==":detail")) {
        output = this.detail()
      } else if ((skey==":path")) {
        output = this.path()
      } else if ((skey==":severity")) {
        output = this.severity()
      } else if ((skey==":text")) {
        output = this.text()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":code", this.code())
      map.put(":detail", this.detail())
      map.put(":path", this.path())
      map.put(":severity", this.severity())
      map.put(":text", this.text())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msg = vx_core.vx_copy(vx_core.e_msg, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msg = this
      var ischanged : Boolean = false
      var value : vx_core.Class_msg = this
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_code : vx_core.Type_string = value.code()
      var vx_p_detail : vx_core.Type_any = value.detail()
      var vx_p_path : vx_core.Type_string = value.path()
      var vx_p_severity : vx_core.Type_int = value.severity()
      var vx_p_text : vx_core.Type_string = value.text()
      var key : String = ""
      for (valsub : Any in vals) {
        if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstr.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          }
        } else {
          if (false) {
          } else if ((key==":code")) {
            if (valsub == vx_p_code) {
            } else if (valsub is vx_core.Type_string) {
              var valcode : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_code = valcode
            } else if (valsub is String) {
              ischanged = true
              vx_p_code = vx_core.vx_new(vx_core.t_string, valsub)
            }
          } else if ((key==":detail")) {
            if (valsub == vx_p_detail) {
            } else if (valsub is vx_core.Type_any) {
              var valdetail : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_detail = valdetail
            }
          } else if ((key==":path")) {
            if (valsub == vx_p_path) {
            } else if (valsub is vx_core.Type_string) {
              var valpath : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_path = valpath
            } else if (valsub is String) {
              ischanged = true
              vx_p_path = vx_core.vx_new(vx_core.t_string, valsub)
            }
          } else if ((key==":severity")) {
            if (valsub == vx_p_severity) {
            } else if (valsub is vx_core.Type_int) {
              var valseverity : vx_core.Type_int = valsub as vx_core.Type_int
              ischanged = true
              vx_p_severity = valseverity
            } else if (valsub is Int) {
              ischanged = true
              vx_p_severity = vx_core.vx_new(vx_core.t_int, valsub)
            }
          } else if ((key==":text")) {
            if (valsub == vx_p_text) {
            } else if (valsub is vx_core.Type_string) {
              var valtext : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_text = valtext
            } else if (valsub is String) {
              ischanged = true
              vx_p_text = vx_core.vx_new(vx_core.t_string, valsub)
            }
          }
          key = ""
        }
      }
      if (ischanged) {
        var work : vx_core.Class_msg = vx_core.Class_msg()
        work.vx_p_code = vx_p_code
        work.vx_p_detail = vx_p_detail
        work.vx_p_path = vx_p_path
        work.vx_p_severity = vx_p_severity
        work.vx_p_text = vx_p_text
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "msg", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_msg : vx_core.Type_msg = vx_core.Class_msg()
  val t_msg : vx_core.Type_msg = vx_core.Class_msg()

  interface Type_msgblock : vx_core.Type_struct {
    fun msgs() : vx_core.Type_msglist
    fun msgblocks() : vx_core.Type_msgblocklist
  }

  class Class_msgblock : vx_core.Class_base, Type_msgblock {
    constructor() {}

    var vx_p_msgs : vx_core.Type_msglist? = null

    override fun msgs() : vx_core.Type_msglist {
      var output : vx_core.Type_msglist = vx_core.e_msglist
      var testnull : vx_core.Type_msglist? = vx_p_msgs
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_msgblocks : vx_core.Type_msgblocklist? = null

    override fun msgblocks() : vx_core.Type_msgblocklist {
      var output : vx_core.Type_msgblocklist = vx_core.e_msgblocklist
      var testnull : vx_core.Type_msgblocklist? = vx_p_msgblocks
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":msgs")) {
        output = this.msgs()
      } else if ((skey==":msgblocks")) {
        output = this.msgblocks()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":msgs", this.msgs())
      map.put(":msgblocks", this.msgblocks())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msgblock = vx_core.vx_copy(vx_core.e_msgblock, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msgblock = this
      var ischanged : Boolean = false
      var value : vx_core.Class_msgblock = this
      var msgblock : vx_core.Type_msgblock = this
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_msgs : vx_core.Type_msglist = value.msgs()
      var vx_p_msgblocks : vx_core.Type_msgblocklist = value.msgblocks()
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          if (valsub != vx_core.e_msgblock) {
            vx_p_msgblocks = vx_core.vx_copy(vx_p_msgblocks, valsub)
            ischanged = true
          }
        } else if (valsub is vx_core.Type_msgblocklist) {
          if (valsub != vx_core.e_msgblocklist) {
            vx_p_msgblocks = vx_core.vx_copy(vx_p_msgblocks, valsub)
            ischanged = true
          }
        } else if (valsub is vx_core.Type_msg) {
          if (valsub != vx_core.e_msg) {
            vx_p_msgs = vx_core.vx_copy(vx_p_msgs, valsub)
            ischanged = true
          }
        } else if (valsub is vx_core.Type_msglist) {
          if (valsub != vx_core.e_msglist) {
            vx_p_msgs = vx_core.vx_copy(vx_p_msgs, valsub)
            ischanged = true
          }
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstr.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          }
        } else {
          if (false) {
          } else if ((key==":msgs")) {
            if (valsub == vx_p_msgs) {
            } else if (valsub is vx_core.Type_msglist) {
              var valmsgs : vx_core.Type_msglist = valsub as vx_core.Type_msglist
              ischanged = true
              vx_p_msgs = valmsgs
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("msgs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/msgblock", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":msgblocks")) {
            if (valsub == vx_p_msgblocks) {
            } else if (valsub is vx_core.Type_msgblocklist) {
              var valmsgblocks : vx_core.Type_msgblocklist = valsub as vx_core.Type_msgblocklist
              ischanged = true
              vx_p_msgblocks = valmsgblocks
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("msgblocks"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/msgblock", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
          key = ""
        }
      }
      if (ischanged) {
        if ((vx_p_msgs.vx_list().size == 0) && (vx_p_msgblocks.vx_list().size == 1)) {
          output = vx_p_msgblocks.vx_listmsgblock().get(0)
        } else {
          var work : vx_core.Class_msgblock = vx_core.Class_msgblock()
          work.vx_p_msgs = vx_p_msgs
          work.vx_p_msgblocks = vx_p_msgblocks
          output = work
        }
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msgblock
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msgblock
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "msgblock", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_msgblock : vx_core.Type_msgblock = vx_core.Class_msgblock()
  val t_msgblock : vx_core.Type_msgblock = vx_core.Class_msgblock()

  interface Type_msgblocklist : vx_core.Type_list {
    fun vx_listmsgblock() : List<vx_core.Type_msgblock>
    fun vx_msgblock(index : vx_core.Type_int) : vx_core.Type_msgblock
  }

  class Class_msgblocklist : vx_core.Class_base, Type_msgblocklist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_msgblock> = vx_core.immutablelist(
      ArrayList<vx_core.Type_msgblock>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_msgblock(index : vx_core.Type_int) : vx_core.Type_msgblock {
      var output : vx_core.Type_msgblock = vx_core.e_msgblock
      var list : vx_core.Class_msgblocklist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_msgblock> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listmsgblock() : List<vx_core.Type_msgblock> {
      var output : List<vx_core.Type_msgblock> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_msgblock = this.vx_msgblock(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msgblocklist = vx_core.vx_copy(vx_core.e_msgblocklist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msgblocklist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_msgblocklist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_msgblock> = ArrayList<vx_core.Type_msgblock>(value.vx_listmsgblock())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msgblocklist) {
          var multi : vx_core.Type_msgblocklist = valsub as vx_core.Type_msgblocklist
          ischanged = true
          listval.addAll(multi.vx_listmsgblock())
        } else if (valsub is vx_core.Type_msgblock) {
          ischanged = true
          listval.add(valsub as vx_core.Type_msgblock)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_msgblock) {
              var valitem : vx_core.Type_msgblock = item as vx_core.Type_msgblock
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/msgblocklist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/msgblocklist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_msgblocklist = vx_core.Class_msgblocklist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msgblocklist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msgblocklist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "msgblocklist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_msgblock), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_msgblocklist : vx_core.Type_msgblocklist = vx_core.Class_msgblocklist()
  val t_msgblocklist : vx_core.Type_msgblocklist = vx_core.Class_msgblocklist()

  interface Type_msglist : vx_core.Type_list {
    fun vx_listmsg() : List<vx_core.Type_msg>
    fun vx_msg(index : vx_core.Type_int) : vx_core.Type_msg
  }

  class Class_msglist : vx_core.Class_base, Type_msglist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_msg> = vx_core.immutablelist(
      ArrayList<vx_core.Type_msg>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_msg(index : vx_core.Type_int) : vx_core.Type_msg {
      var output : vx_core.Type_msg = vx_core.e_msg
      var list : vx_core.Class_msglist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_msg> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listmsg() : List<vx_core.Type_msg> {
      var output : List<vx_core.Type_msg> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_msg = this.vx_msg(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msglist = vx_core.vx_copy(vx_core.e_msglist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_msglist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_msglist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_msg> = ArrayList<vx_core.Type_msg>(value.vx_listmsg())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msglist) {
          var multi : vx_core.Type_msglist = valsub as vx_core.Type_msglist
          ischanged = true
          listval.addAll(multi.vx_listmsg())
        } else if (valsub is vx_core.Type_msg) {
          ischanged = true
          listval.add(valsub as vx_core.Type_msg)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_msg) {
              var valitem : vx_core.Type_msg = item as vx_core.Type_msg
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/msglist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/msglist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_msglist = vx_core.Class_msglist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msglist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msglist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "msglist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_msg), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_msglist : vx_core.Type_msglist = vx_core.Class_msglist()
  val t_msglist : vx_core.Type_msglist = vx_core.Class_msglist()

  interface Type_none : vx_core.Type_any {
  }

  class Class_none : vx_core.Class_base, Type_none {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_none = vx_core.vx_copy(vx_core.e_none, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_none = this
      var ischanged : Boolean = false
      var value : vx_core.Class_none = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_none = vx_core.Class_none()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_none
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_none
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "none", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_none : vx_core.Type_none = vx_core.Class_none()
  val t_none : vx_core.Type_none = vx_core.Class_none()

  interface Type_notype : vx_core.Type_any {
  }

  class Class_notype : vx_core.Class_base, Type_notype {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_notype = vx_core.vx_copy(vx_core.e_notype, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_notype = this
      var ischanged : Boolean = false
      var value : vx_core.Class_notype = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_notype = vx_core.Class_notype()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_notype
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_notype
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "notype", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_notype : vx_core.Type_notype = vx_core.Class_notype()
  val t_notype : vx_core.Type_notype = vx_core.Class_notype()

  interface Type_number : vx_core.Type_any {
  }

  class Class_number : vx_core.Class_base, Type_number {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_number = vx_core.vx_copy(vx_core.e_number, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_number = this
      var ischanged : Boolean = false
      var value : vx_core.Class_number = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_number = vx_core.Class_number()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_number
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_number
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "number", // name
        "", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_number : vx_core.Type_number = vx_core.Class_number()
  val t_number : vx_core.Type_number = vx_core.Class_number()

  interface Type_numberlist : vx_core.Type_list {
    fun vx_listnumber() : List<vx_core.Type_number>
    fun vx_number(index : vx_core.Type_int) : vx_core.Type_number
  }

  class Class_numberlist : vx_core.Class_base, Type_numberlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_number> = vx_core.immutablelist(
      ArrayList<vx_core.Type_number>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_number(index : vx_core.Type_int) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.e_number
      var list : vx_core.Class_numberlist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_number> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listnumber() : List<vx_core.Type_number> {
      var output : List<vx_core.Type_number> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_number = this.vx_number(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_numberlist = vx_core.vx_copy(vx_core.e_numberlist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_numberlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_numberlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_number> = ArrayList<vx_core.Type_number>(value.vx_listnumber())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_numberlist) {
          var multi : vx_core.Type_numberlist = valsub as vx_core.Type_numberlist
          ischanged = true
          listval.addAll(multi.vx_listnumber())
        } else if (valsub is vx_core.Type_number) {
          var allowsub : vx_core.Type_number = valsub as vx_core.Type_number
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is vx_core.Type_number) {
          ischanged = true
          listval.add(valsub as vx_core.Type_number)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_number) {
              var valitem : vx_core.Type_number = item as vx_core.Type_number
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/numberlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/numberlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_numberlist = vx_core.Class_numberlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_numberlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_numberlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "numberlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_numberlist : vx_core.Type_numberlist = vx_core.Class_numberlist()
  val t_numberlist : vx_core.Type_numberlist = vx_core.Class_numberlist()

  interface Type_numbermap : vx_core.Type_map {
    fun vx_mapnumber() : Map<String, vx_core.Type_number>
    fun vx_number(key : vx_core.Type_string) : vx_core.Type_number
  }

  class Class_numbermap : vx_core.Class_base, Type_numbermap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_number> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_number>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_number) {
        var castval : vx_core.Type_number = value as vx_core.Type_number
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_number> = LinkedHashMap<String, vx_core.Type_number>(this.vx_p_map)
        if (castval == vx_core.e_number) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_number(key : vx_core.Type_string) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.e_number
      var map : vx_core.Class_numbermap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_number> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_number)
      return output
    }

    override fun vx_mapnumber() : Map<String, vx_core.Type_number> {
      var output : Map<String, vx_core.Type_number> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_number(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_numbermap = vx_core.Class_numbermap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_number> = LinkedHashMap<String, vx_core.Type_number>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_number) {
          var castval : vx_core.Type_number = value as vx_core.Type_number
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/numbermap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_numbermap = vx_core.vx_copy(vx_core.e_numbermap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_numbermap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_numbermap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_number> = LinkedHashMap<String, vx_core.Type_number>(value.vx_mapnumber())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/numbermap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_number = vx_core.e_number
          if (false) {
          } else if (valsub is vx_core.Type_number) {
            var valallowed : vx_core.Type_number = valsub as vx_core.Type_number
            valany = valallowed
          } else if (valsub is vx_core.Type_number) {
            valany = valsub as vx_core.Type_number
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/numbermap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_numbermap = vx_core.Class_numbermap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_numbermap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_numbermap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "numbermap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_numbermap : vx_core.Type_numbermap = vx_core.Class_numbermap()
  val t_numbermap : vx_core.Type_numbermap = vx_core.Class_numbermap()

  interface Type_package : vx_core.Type_struct {
    fun pkgname() : vx_core.Type_string
    fun constmap() : vx_core.Type_constmap
    fun funcmap() : vx_core.Type_funcmap
    fun typemap() : vx_core.Type_typemap
    fun emptymap() : vx_core.Type_map
  }

  class Class_package : vx_core.Class_base, Type_package {
    constructor() {}

    var vx_p_pkgname : vx_core.Type_string? = null

    override fun pkgname() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_pkgname
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_constmap : vx_core.Type_constmap? = null

    override fun constmap() : vx_core.Type_constmap {
      var output : vx_core.Type_constmap = vx_core.e_constmap
      var testnull : vx_core.Type_constmap? = vx_p_constmap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_funcmap : vx_core.Type_funcmap? = null

    override fun funcmap() : vx_core.Type_funcmap {
      var output : vx_core.Type_funcmap = vx_core.e_funcmap
      var testnull : vx_core.Type_funcmap? = vx_p_funcmap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_typemap : vx_core.Type_typemap? = null

    override fun typemap() : vx_core.Type_typemap {
      var output : vx_core.Type_typemap = vx_core.e_typemap
      var testnull : vx_core.Type_typemap? = vx_p_typemap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_emptymap : vx_core.Type_map? = null

    override fun emptymap() : vx_core.Type_map {
      var output : vx_core.Type_map = vx_core.e_map
      var testnull : vx_core.Type_map? = vx_p_emptymap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":pkgname")) {
        output = this.pkgname()
      } else if ((skey==":constmap")) {
        output = this.constmap()
      } else if ((skey==":funcmap")) {
        output = this.funcmap()
      } else if ((skey==":typemap")) {
        output = this.typemap()
      } else if ((skey==":emptymap")) {
        output = this.emptymap()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":pkgname", this.pkgname())
      map.put(":constmap", this.constmap())
      map.put(":funcmap", this.funcmap())
      map.put(":typemap", this.typemap())
      map.put(":emptymap", this.emptymap())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_package = vx_core.vx_copy(vx_core.e_package, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_package = this
      var ischanged : Boolean = false
      var value : vx_core.Class_package = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pkgname : vx_core.Type_string = value.pkgname()
      var vx_p_constmap : vx_core.Type_constmap = value.constmap()
      var vx_p_funcmap : vx_core.Type_funcmap = value.funcmap()
      var vx_p_typemap : vx_core.Type_typemap = value.typemap()
      var vx_p_emptymap : vx_core.Type_map = value.emptymap()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":pkgname")
      validkeys.add(":constmap")
      validkeys.add(":funcmap")
      validkeys.add(":typemap")
      validkeys.add(":emptymap")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":pkgname")) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub is vx_core.Type_string) {
              var valpkgname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_pkgname = valpkgname
            } else if (valsub is String) {
              ischanged = true
              vx_p_pkgname = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pkgname"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":constmap")) {
            if (valsub == vx_p_constmap) {
            } else if (valsub is vx_core.Type_constmap) {
              var valconstmap : vx_core.Type_constmap = valsub as vx_core.Type_constmap
              ischanged = true
              vx_p_constmap = valconstmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("constmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":funcmap")) {
            if (valsub == vx_p_funcmap) {
            } else if (valsub is vx_core.Type_funcmap) {
              var valfuncmap : vx_core.Type_funcmap = valsub as vx_core.Type_funcmap
              ischanged = true
              vx_p_funcmap = valfuncmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("funcmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":typemap")) {
            if (valsub == vx_p_typemap) {
            } else if (valsub is vx_core.Type_typemap) {
              var valtypemap : vx_core.Type_typemap = valsub as vx_core.Type_typemap
              ischanged = true
              vx_p_typemap = valtypemap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("typemap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":emptymap")) {
            if (valsub == vx_p_emptymap) {
            } else if (valsub is vx_core.Type_map) {
              var valemptymap : vx_core.Type_map = valsub as vx_core.Type_map
              ischanged = true
              vx_p_emptymap = valemptymap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("emptymap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/package", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_package = vx_core.Class_package()
        work.vx_p_pkgname = vx_p_pkgname
        work.vx_p_constmap = vx_p_constmap
        work.vx_p_funcmap = vx_p_funcmap
        work.vx_p_typemap = vx_p_typemap
        work.vx_p_emptymap = vx_p_emptymap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_package
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_package
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "package", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_package : vx_core.Type_package = vx_core.Class_package()
  val t_package : vx_core.Type_package = vx_core.Class_package()

  interface Type_packagemap : vx_core.Type_map {
    fun vx_mappackage() : Map<String, vx_core.Type_package>
    fun vx_package(key : vx_core.Type_string) : vx_core.Type_package
  }

  class Class_packagemap : vx_core.Class_base, Type_packagemap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_package> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_package>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_package) {
        var castval : vx_core.Type_package = value as vx_core.Type_package
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_package> = LinkedHashMap<String, vx_core.Type_package>(this.vx_p_map)
        if (castval == vx_core.e_package) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_package(key : vx_core.Type_string) : vx_core.Type_package {
      var output : vx_core.Type_package = vx_core.e_package
      var map : vx_core.Class_packagemap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_package> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_package)
      return output
    }

    override fun vx_mappackage() : Map<String, vx_core.Type_package> {
      var output : Map<String, vx_core.Type_package> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_package(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_packagemap = vx_core.Class_packagemap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_package> = LinkedHashMap<String, vx_core.Type_package>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_package) {
          var castval : vx_core.Type_package = value as vx_core.Type_package
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/packagemap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_packagemap = vx_core.vx_copy(vx_core.e_packagemap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_packagemap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_packagemap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_package> = LinkedHashMap<String, vx_core.Type_package>(value.vx_mappackage())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/packagemap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_package = vx_core.e_package
          if (false) {
          } else if (valsub is vx_core.Type_package) {
            var valallowed : vx_core.Type_package = valsub as vx_core.Type_package
            valany = valallowed
          } else if (valsub is vx_core.Type_package) {
            valany = valsub as vx_core.Type_package
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/packagemap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_packagemap = vx_core.Class_packagemap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_packagemap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_packagemap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "packagemap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_package), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_packagemap : vx_core.Type_packagemap = vx_core.Class_packagemap()
  val t_packagemap : vx_core.Type_packagemap = vx_core.Class_packagemap()

  interface Type_permission : vx_core.Type_struct {
    fun id() : vx_core.Type_string
  }

  class Class_permission : vx_core.Class_base, Type_permission {
    constructor() {}

    var vx_p_id : vx_core.Type_string? = null

    override fun id() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_id
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":id")) {
        output = this.id()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":id", this.id())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_permission = vx_core.vx_copy(vx_core.e_permission, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_permission = this
      var ischanged : Boolean = false
      var value : vx_core.Class_permission = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_id : vx_core.Type_string = value.id()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":id")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/permission", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/permission", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":id")) {
            if (valsub == vx_p_id) {
            } else if (valsub is vx_core.Type_string) {
              var valid : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_id = valid
            } else if (valsub is String) {
              ischanged = true
              vx_p_id = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("id"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/permission", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/permission", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_permission = vx_core.Class_permission()
        work.vx_p_id = vx_p_id
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_permission
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_permission
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "permission", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_permission : vx_core.Type_permission = vx_core.Class_permission()
  val t_permission : vx_core.Type_permission = vx_core.Class_permission()

  interface Type_permissionlist : vx_core.Type_list {
    fun vx_listpermission() : List<vx_core.Type_permission>
    fun vx_permission(index : vx_core.Type_int) : vx_core.Type_permission
  }

  class Class_permissionlist : vx_core.Class_base, Type_permissionlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_permission> = vx_core.immutablelist(
      ArrayList<vx_core.Type_permission>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_permission(index : vx_core.Type_int) : vx_core.Type_permission {
      var output : vx_core.Type_permission = vx_core.e_permission
      var list : vx_core.Class_permissionlist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_permission> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listpermission() : List<vx_core.Type_permission> {
      var output : List<vx_core.Type_permission> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_permission = this.vx_permission(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_permissionlist = vx_core.vx_copy(vx_core.e_permissionlist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_permissionlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_permissionlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_permission> = ArrayList<vx_core.Type_permission>(value.vx_listpermission())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_permissionlist) {
          var multi : vx_core.Type_permissionlist = valsub as vx_core.Type_permissionlist
          ischanged = true
          listval.addAll(multi.vx_listpermission())
        } else if (valsub is vx_core.Type_permission) {
          var allowsub : vx_core.Type_permission = valsub as vx_core.Type_permission
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is vx_core.Type_permission) {
          ischanged = true
          listval.add(valsub as vx_core.Type_permission)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_permission) {
              var valitem : vx_core.Type_permission = item as vx_core.Type_permission
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/permissionlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/permissionlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_permissionlist = vx_core.Class_permissionlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_permissionlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_permissionlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "permissionlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_permission), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_permissionlist : vx_core.Type_permissionlist = vx_core.Class_permissionlist()
  val t_permissionlist : vx_core.Type_permissionlist = vx_core.Class_permissionlist()

  interface Type_permissionmap : vx_core.Type_map {
    fun vx_mappermission() : Map<String, vx_core.Type_permission>
    fun vx_permission(key : vx_core.Type_string) : vx_core.Type_permission
  }

  class Class_permissionmap : vx_core.Class_base, Type_permissionmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_permission> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_permission>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_permission) {
        var castval : vx_core.Type_permission = value as vx_core.Type_permission
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_permission> = LinkedHashMap<String, vx_core.Type_permission>(this.vx_p_map)
        if (castval == vx_core.e_permission) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_permission(key : vx_core.Type_string) : vx_core.Type_permission {
      var output : vx_core.Type_permission = vx_core.e_permission
      var map : vx_core.Class_permissionmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_permission> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_permission)
      return output
    }

    override fun vx_mappermission() : Map<String, vx_core.Type_permission> {
      var output : Map<String, vx_core.Type_permission> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_permission(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_permissionmap = vx_core.Class_permissionmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_permission> = LinkedHashMap<String, vx_core.Type_permission>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_permission) {
          var castval : vx_core.Type_permission = value as vx_core.Type_permission
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/permissionmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_permissionmap = vx_core.vx_copy(vx_core.e_permissionmap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_permissionmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_permissionmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_permission> = LinkedHashMap<String, vx_core.Type_permission>(value.vx_mappermission())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/permissionmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_permission = vx_core.e_permission
          if (false) {
          } else if (valsub is vx_core.Type_permission) {
            var valallowed : vx_core.Type_permission = valsub as vx_core.Type_permission
            valany = valallowed
          } else if (valsub is vx_core.Type_permission) {
            valany = valsub as vx_core.Type_permission
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/permissionmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_permissionmap = vx_core.Class_permissionmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_permissionmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_permissionmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "permissionmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_permission), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_permissionmap : vx_core.Type_permissionmap = vx_core.Class_permissionmap()
  val t_permissionmap : vx_core.Type_permissionmap = vx_core.Class_permissionmap()

  interface Type_project : vx_core.Type_struct {
    fun packagemap() : vx_core.Type_packagemap
  }

  class Class_project : vx_core.Class_base, Type_project {
    constructor() {}

    var vx_p_packagemap : vx_core.Type_packagemap? = null

    override fun packagemap() : vx_core.Type_packagemap {
      var output : vx_core.Type_packagemap = vx_core.e_packagemap
      var testnull : vx_core.Type_packagemap? = vx_p_packagemap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":packagemap")) {
        output = this.packagemap()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":packagemap", this.packagemap())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_project = vx_core.vx_copy(vx_core.e_project, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_project = this
      var ischanged : Boolean = false
      var value : vx_core.Class_project = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_packagemap : vx_core.Type_packagemap = value.packagemap()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":packagemap")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/project", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/project", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":packagemap")) {
            if (valsub == vx_p_packagemap) {
            } else if (valsub is vx_core.Type_packagemap) {
              var valpackagemap : vx_core.Type_packagemap = valsub as vx_core.Type_packagemap
              ischanged = true
              vx_p_packagemap = valpackagemap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("packagemap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/project", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/project", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_project = vx_core.Class_project()
        work.vx_p_packagemap = vx_p_packagemap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_project
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_project
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "project", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_project : vx_core.Type_project = vx_core.Class_project()
  val t_project : vx_core.Type_project = vx_core.Class_project()

  interface Type_security : vx_core.Type_struct {
    fun allowfuncs() : vx_core.Type_funclist
    fun permissions() : vx_core.Type_permissionlist
    fun permissionmap() : vx_core.Type_permissionmap
  }

  class Class_security : vx_core.Class_base, Type_security {
    constructor() {}

    var vx_p_allowfuncs : vx_core.Type_funclist? = null

    override fun allowfuncs() : vx_core.Type_funclist {
      var output : vx_core.Type_funclist = vx_core.e_funclist
      var testnull : vx_core.Type_funclist? = vx_p_allowfuncs
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_permissions : vx_core.Type_permissionlist? = null

    override fun permissions() : vx_core.Type_permissionlist {
      var output : vx_core.Type_permissionlist = vx_core.e_permissionlist
      var testnull : vx_core.Type_permissionlist? = vx_p_permissions
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_permissionmap : vx_core.Type_permissionmap? = null

    override fun permissionmap() : vx_core.Type_permissionmap {
      var output : vx_core.Type_permissionmap = vx_core.e_permissionmap
      var testnull : vx_core.Type_permissionmap? = vx_p_permissionmap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":allowfuncs")) {
        output = this.allowfuncs()
      } else if ((skey==":permissions")) {
        output = this.permissions()
      } else if ((skey==":permissionmap")) {
        output = this.permissionmap()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":allowfuncs", this.allowfuncs())
      map.put(":permissions", this.permissions())
      map.put(":permissionmap", this.permissionmap())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_security = vx_core.vx_copy(vx_core.e_security, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_security = this
      var ischanged : Boolean = false
      var value : vx_core.Class_security = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_allowfuncs : vx_core.Type_funclist = value.allowfuncs()
      var vx_p_permissions : vx_core.Type_permissionlist = value.permissions()
      var vx_p_permissionmap : vx_core.Type_permissionmap = value.permissionmap()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":allowfuncs")
      validkeys.add(":permissions")
      validkeys.add(":permissionmap")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":allowfuncs")) {
            if (valsub == vx_p_allowfuncs) {
            } else if (valsub is vx_core.Type_funclist) {
              var valallowfuncs : vx_core.Type_funclist = valsub as vx_core.Type_funclist
              ischanged = true
              vx_p_allowfuncs = valallowfuncs
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("allowfuncs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":permissions")) {
            if (valsub == vx_p_permissions) {
            } else if (valsub is vx_core.Type_permissionlist) {
              var valpermissions : vx_core.Type_permissionlist = valsub as vx_core.Type_permissionlist
              ischanged = true
              vx_p_permissions = valpermissions
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("permissions"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":permissionmap")) {
            if (valsub == vx_p_permissionmap) {
            } else if (valsub is vx_core.Type_permissionmap) {
              var valpermissionmap : vx_core.Type_permissionmap = valsub as vx_core.Type_permissionmap
              ischanged = true
              vx_p_permissionmap = valpermissionmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("permissionmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/security", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_security = vx_core.Class_security()
        work.vx_p_allowfuncs = vx_p_allowfuncs
        work.vx_p_permissions = vx_p_permissions
        work.vx_p_permissionmap = vx_p_permissionmap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_security
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_security
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "security", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_security : vx_core.Type_security = vx_core.Class_security()
  val t_security : vx_core.Type_security = vx_core.Class_security()

  interface Type_session : vx_core.Type_struct {
    fun user() : vx_core.Type_user
    fun connectlist() : vx_core.Type_connectlist
    fun connectmap() : vx_core.Type_connectmap
    fun locale() : vx_core.Type_locale
    fun translation() : vx_core.Type_translation
    fun translationmap() : vx_core.Type_translationmap
  }

  class Class_session : vx_core.Class_base, Type_session {
    constructor() {}

    var vx_p_user : vx_core.Type_user? = null

    override fun user() : vx_core.Type_user {
      var output : vx_core.Type_user = vx_core.e_user
      var testnull : vx_core.Type_user? = vx_p_user
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_connectlist : vx_core.Type_connectlist? = null

    override fun connectlist() : vx_core.Type_connectlist {
      var output : vx_core.Type_connectlist = vx_core.e_connectlist
      var testnull : vx_core.Type_connectlist? = vx_p_connectlist
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_connectmap : vx_core.Type_connectmap? = null

    override fun connectmap() : vx_core.Type_connectmap {
      var output : vx_core.Type_connectmap = vx_core.e_connectmap
      var testnull : vx_core.Type_connectmap? = vx_p_connectmap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_locale : vx_core.Type_locale? = null

    override fun locale() : vx_core.Type_locale {
      var output : vx_core.Type_locale = vx_core.e_locale
      var testnull : vx_core.Type_locale? = vx_p_locale
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_translation : vx_core.Type_translation? = null

    override fun translation() : vx_core.Type_translation {
      var output : vx_core.Type_translation = vx_core.e_translation
      var testnull : vx_core.Type_translation? = vx_p_translation
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_translationmap : vx_core.Type_translationmap? = null

    override fun translationmap() : vx_core.Type_translationmap {
      var output : vx_core.Type_translationmap = vx_core.e_translationmap
      var testnull : vx_core.Type_translationmap? = vx_p_translationmap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":user")) {
        output = this.user()
      } else if ((skey==":connectlist")) {
        output = this.connectlist()
      } else if ((skey==":connectmap")) {
        output = this.connectmap()
      } else if ((skey==":locale")) {
        output = this.locale()
      } else if ((skey==":translation")) {
        output = this.translation()
      } else if ((skey==":translationmap")) {
        output = this.translationmap()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":user", this.user())
      map.put(":connectlist", this.connectlist())
      map.put(":connectmap", this.connectmap())
      map.put(":locale", this.locale())
      map.put(":translation", this.translation())
      map.put(":translationmap", this.translationmap())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_session = vx_core.vx_copy(vx_core.e_session, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_session = this
      var ischanged : Boolean = false
      var value : vx_core.Class_session = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_user : vx_core.Type_user = value.user()
      var vx_p_connectlist : vx_core.Type_connectlist = value.connectlist()
      var vx_p_connectmap : vx_core.Type_connectmap = value.connectmap()
      var vx_p_locale : vx_core.Type_locale = value.locale()
      var vx_p_translation : vx_core.Type_translation = value.translation()
      var vx_p_translationmap : vx_core.Type_translationmap = value.translationmap()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":user")
      validkeys.add(":connectlist")
      validkeys.add(":connectmap")
      validkeys.add(":locale")
      validkeys.add(":translation")
      validkeys.add(":translationmap")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":user")) {
            if (valsub == vx_p_user) {
            } else if (valsub is vx_core.Type_user) {
              var valuser : vx_core.Type_user = valsub as vx_core.Type_user
              ischanged = true
              vx_p_user = valuser
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("user"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":connectlist")) {
            if (valsub == vx_p_connectlist) {
            } else if (valsub is vx_core.Type_connectlist) {
              var valconnectlist : vx_core.Type_connectlist = valsub as vx_core.Type_connectlist
              ischanged = true
              vx_p_connectlist = valconnectlist
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("connectlist"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":connectmap")) {
            if (valsub == vx_p_connectmap) {
            } else if (valsub is vx_core.Type_connectmap) {
              var valconnectmap : vx_core.Type_connectmap = valsub as vx_core.Type_connectmap
              ischanged = true
              vx_p_connectmap = valconnectmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("connectmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":locale")) {
            if (valsub == vx_p_locale) {
            } else if (valsub is vx_core.Type_locale) {
              var vallocale : vx_core.Type_locale = valsub as vx_core.Type_locale
              ischanged = true
              vx_p_locale = vallocale
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("locale"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":translation")) {
            if (valsub == vx_p_translation) {
            } else if (valsub is vx_core.Type_translation) {
              var valtranslation : vx_core.Type_translation = valsub as vx_core.Type_translation
              ischanged = true
              vx_p_translation = valtranslation
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("translation"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":translationmap")) {
            if (valsub == vx_p_translationmap) {
            } else if (valsub is vx_core.Type_translationmap) {
              var valtranslationmap : vx_core.Type_translationmap = valsub as vx_core.Type_translationmap
              ischanged = true
              vx_p_translationmap = valtranslationmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("translationmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/session", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_session = vx_core.Class_session()
        work.vx_p_user = vx_p_user
        work.vx_p_connectlist = vx_p_connectlist
        work.vx_p_connectmap = vx_p_connectmap
        work.vx_p_locale = vx_p_locale
        work.vx_p_translation = vx_p_translation
        work.vx_p_translationmap = vx_p_translationmap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_session
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_session
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "session", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_session : vx_core.Type_session = vx_core.Class_session()
  val t_session : vx_core.Type_session = vx_core.Class_session()

  interface Type_setting : vx_core.Type_struct {
    fun pathmap() : vx_core.Type_stringmap
  }

  class Class_setting : vx_core.Class_base, Type_setting {
    constructor() {}

    var vx_p_pathmap : vx_core.Type_stringmap? = null

    override fun pathmap() : vx_core.Type_stringmap {
      var output : vx_core.Type_stringmap = vx_core.e_stringmap
      var testnull : vx_core.Type_stringmap? = vx_p_pathmap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":pathmap")) {
        output = this.pathmap()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":pathmap", this.pathmap())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_setting = vx_core.vx_copy(vx_core.e_setting, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_setting = this
      var ischanged : Boolean = false
      var value : vx_core.Class_setting = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pathmap : vx_core.Type_stringmap = value.pathmap()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":pathmap")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/setting", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/setting", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":pathmap")) {
            if (valsub == vx_p_pathmap) {
            } else if (valsub is vx_core.Type_stringmap) {
              var valpathmap : vx_core.Type_stringmap = valsub as vx_core.Type_stringmap
              ischanged = true
              vx_p_pathmap = valpathmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pathmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/setting", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/setting", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_setting = vx_core.Class_setting()
        work.vx_p_pathmap = vx_p_pathmap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_setting
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_setting
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "setting", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_setting : vx_core.Type_setting = vx_core.Class_setting()
  val t_setting : vx_core.Type_setting = vx_core.Class_setting()

  interface Type_state : vx_core.Type_struct {
    fun statelistenermap() : vx_core.Type_statelistenermap
  }

  class Class_state : vx_core.Class_base, Type_state {
    constructor() {}

    var vx_p_statelistenermap : vx_core.Type_statelistenermap? = null

    override fun statelistenermap() : vx_core.Type_statelistenermap {
      var output : vx_core.Type_statelistenermap = vx_core.e_statelistenermap
      var testnull : vx_core.Type_statelistenermap? = vx_p_statelistenermap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":statelistenermap")) {
        output = this.statelistenermap()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":statelistenermap", this.statelistenermap())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_state = vx_core.vx_copy(vx_core.e_state, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_state = this
      var ischanged : Boolean = false
      var value : vx_core.Class_state = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_statelistenermap : vx_core.Type_statelistenermap = value.statelistenermap()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":statelistenermap")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/state", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/state", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":statelistenermap")) {
            if (valsub == vx_p_statelistenermap) {
            } else if (valsub is vx_core.Type_statelistenermap) {
              var valstatelistenermap : vx_core.Type_statelistenermap = valsub as vx_core.Type_statelistenermap
              ischanged = true
              vx_p_statelistenermap = valstatelistenermap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("statelistenermap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/state", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/state", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_state = vx_core.Class_state()
        work.vx_p_statelistenermap = vx_p_statelistenermap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_state
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_state
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "state", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_state : vx_core.Type_state = vx_core.Class_state()
  val t_state : vx_core.Type_state = vx_core.Class_state()

  interface Type_statelistener : vx_core.Type_struct {
    fun name() : vx_core.Type_string
    fun value() : vx_core.Type_any
    fun fn_boolean() : vx_core.Func_boolean_from_none
  }

  class Class_statelistener : vx_core.Class_base, Type_statelistener {
    constructor() {}

    var vx_p_name : vx_core.Type_string? = null

    override fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_name
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_value : vx_core.Type_any? = null

    override fun value() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var testnull : vx_core.Type_any? = vx_p_value
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_fn_boolean : vx_core.Func_boolean_from_none? = null

    override fun fn_boolean() : vx_core.Func_boolean_from_none {
      var output : vx_core.Func_boolean_from_none = vx_core.e_boolean_from_none
      var testnull : vx_core.Func_boolean_from_none? = vx_p_fn_boolean
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":name")) {
        output = this.name()
      } else if ((skey==":value")) {
        output = this.value()
      } else if ((skey==":fn-boolean")) {
        output = this.fn_boolean()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":name", this.name())
      map.put(":value", this.value())
      map.put(":fn-boolean", this.fn_boolean())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_statelistener = vx_core.vx_copy(vx_core.e_statelistener, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_statelistener = this
      var ischanged : Boolean = false
      var value : vx_core.Class_statelistener = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_value : vx_core.Type_any = value.value()
      var vx_p_fn_boolean : vx_core.Func_boolean_from_none = value.fn_boolean()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":name")
      validkeys.add(":value")
      validkeys.add(":fn-boolean")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":value")) {
            if (valsub == vx_p_value) {
            } else if (valsub is vx_core.Type_any) {
              var valvalue : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_value = valvalue
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("value"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":fn-boolean")) {
            if (valsub == vx_p_fn_boolean) {
            } else if (valsub is vx_core.Func_boolean_from_none) {
              var valfn_boolean : vx_core.Func_boolean_from_none = valsub as vx_core.Func_boolean_from_none
              ischanged = true
              vx_p_fn_boolean = valfn_boolean
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("fn-boolean"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/statelistener", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_statelistener = vx_core.Class_statelistener()
        work.vx_p_name = vx_p_name
        work.vx_p_value = vx_p_value
        work.vx_p_fn_boolean = vx_p_fn_boolean
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_statelistener
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_statelistener
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "statelistener", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_statelistener : vx_core.Type_statelistener = vx_core.Class_statelistener()
  val t_statelistener : vx_core.Type_statelistener = vx_core.Class_statelistener()

  interface Type_statelistenermap : vx_core.Type_map {
    fun vx_mapstatelistener() : Map<String, vx_core.Type_statelistener>
    fun vx_statelistener(key : vx_core.Type_string) : vx_core.Type_statelistener
  }

  class Class_statelistenermap : vx_core.Class_base, Type_statelistenermap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_statelistener> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_statelistener>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_statelistener) {
        var castval : vx_core.Type_statelistener = value as vx_core.Type_statelistener
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_statelistener> = LinkedHashMap<String, vx_core.Type_statelistener>(this.vx_p_map)
        if (castval == vx_core.e_statelistener) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_statelistener(key : vx_core.Type_string) : vx_core.Type_statelistener {
      var output : vx_core.Type_statelistener = vx_core.e_statelistener
      var map : vx_core.Class_statelistenermap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_statelistener> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_statelistener)
      return output
    }

    override fun vx_mapstatelistener() : Map<String, vx_core.Type_statelistener> {
      var output : Map<String, vx_core.Type_statelistener> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_statelistener(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_statelistenermap = vx_core.Class_statelistenermap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_statelistener> = LinkedHashMap<String, vx_core.Type_statelistener>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_statelistener) {
          var castval : vx_core.Type_statelistener = value as vx_core.Type_statelistener
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/statelistenermap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_statelistenermap = vx_core.vx_copy(vx_core.e_statelistenermap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_statelistenermap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_statelistenermap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_statelistener> = LinkedHashMap<String, vx_core.Type_statelistener>(value.vx_mapstatelistener())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/statelistenermap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_statelistener = vx_core.e_statelistener
          if (false) {
          } else if (valsub is vx_core.Type_statelistener) {
            var valallowed : vx_core.Type_statelistener = valsub as vx_core.Type_statelistener
            valany = valallowed
          } else if (valsub is vx_core.Type_statelistener) {
            valany = valsub as vx_core.Type_statelistener
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/statelistenermap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_statelistenermap = vx_core.Class_statelistenermap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_statelistenermap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_statelistenermap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "statelistenermap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_statelistener), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_statelistenermap : vx_core.Type_statelistenermap = vx_core.Class_statelistenermap()
  val t_statelistenermap : vx_core.Type_statelistenermap = vx_core.Class_statelistenermap()

  interface Type_string : vx_core.Type_any {
    fun vx_string() : String
  }

  class Class_string : vx_core.Class_base, Type_string {
    constructor() {}

    internal var vxstring : String = ""
    
    // :implements
    override fun vx_string() : String {
      return vxstring
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_string = vx_core.vx_copy(vx_core.e_string, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_string = this
      var ischanged : Boolean = false
      var value : vx_core.Class_string = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var sb : kotlin.text.StringBuilder = StringBuilder(value.vx_string())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_string) {
          var valstring : vx_core.Type_string = valsub as vx_core.Type_string
          var ssub : String = valstring.vx_string()
          if (ssub.equals("")) {
          } else {
            ischanged = true
            sb.append(ssub)
          }
        } else if (valsub is vx_core.Type_int) {
          var valint : vx_core.Type_int = valsub as vx_core.Type_int
          ischanged = true
          sb.append(valint.vx_int())
        } else if (valsub is vx_core.Type_float) {
          var valfloat : vx_core.Type_float = valsub as vx_core.Type_float
          ischanged = true
          sb.append(valfloat.vx_float())
        } else if (valsub is vx_core.Type_decimal) {
          var valdecimal : vx_core.Type_decimal = valsub as vx_core.Type_decimal
          ischanged = true
          sb.append(valdecimal.vx_string())
        } else if (valsub is String) {
          var sval : String = valsub as String
          if (sval.equals("")) {
          } else {
            ischanged = true
            sb.append(sval)
          }
        } else if (valsub is Int) {
          var ival : Int = valsub as Int
          ischanged = true
          sb.append(ival)
        } else if (valsub is Float) {
          var fval : Float = valsub as Float
          ischanged = true
          sb.append(fval)
        } else if (valsub is vx_core.Type_any) {
          var anysub : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/string", ":invalidtype", anysub)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/string", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var vxstring : String = sb.toString()
        var work : vx_core.Class_string = vx_core.Class_string()
        work.vxstring = vxstring
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "string", // name
        ":string", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_string : vx_core.Type_string = vx_core.Class_string()
  val t_string : vx_core.Type_string = vx_core.Class_string()

  interface Type_stringlist : vx_core.Type_list {
    fun vx_liststring() : List<vx_core.Type_string>
    fun vx_string(index : vx_core.Type_int) : vx_core.Type_string
  }

  class Class_stringlist : vx_core.Class_base, Type_stringlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_string> = vx_core.immutablelist(
      ArrayList<vx_core.Type_string>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_string(index : vx_core.Type_int) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var list : vx_core.Class_stringlist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_string> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_liststring() : List<vx_core.Type_string> {
      var output : List<vx_core.Type_string> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_string = this.vx_string(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringlist = vx_core.vx_copy(vx_core.e_stringlist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_stringlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_string> = ArrayList<vx_core.Type_string>(value.vx_liststring())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_stringlist) {
          var multi : vx_core.Type_stringlist = valsub as vx_core.Type_stringlist
          ischanged = true
          listval.addAll(multi.vx_liststring())
        } else if (valsub is vx_core.Type_string) {
          var allowsub : vx_core.Type_string = valsub as vx_core.Type_string
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is String) {
          ischanged = true
          listval.add(vx_core.vx_new(vx_core.t_string, valsub))
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_string) {
              var valitem : vx_core.Type_string = item as vx_core.Type_string
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/stringlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/stringlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_stringlist = vx_core.Class_stringlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "stringlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_stringlist : vx_core.Type_stringlist = vx_core.Class_stringlist()
  val t_stringlist : vx_core.Type_stringlist = vx_core.Class_stringlist()

  interface Type_stringlistlist : vx_core.Type_list {
    fun vx_liststringlist() : List<vx_core.Type_stringlist>
    fun vx_stringlist(index : vx_core.Type_int) : vx_core.Type_stringlist
  }

  class Class_stringlistlist : vx_core.Class_base, Type_stringlistlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_stringlist> = vx_core.immutablelist(
      ArrayList<vx_core.Type_stringlist>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_stringlist(index : vx_core.Type_int) : vx_core.Type_stringlist {
      var output : vx_core.Type_stringlist = vx_core.e_stringlist
      var list : vx_core.Class_stringlistlist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_stringlist> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_liststringlist() : List<vx_core.Type_stringlist> {
      var output : List<vx_core.Type_stringlist> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_stringlist = this.vx_stringlist(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringlistlist = vx_core.vx_copy(vx_core.e_stringlistlist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringlistlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_stringlistlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_stringlist> = ArrayList<vx_core.Type_stringlist>(value.vx_liststringlist())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_stringlistlist) {
          var multi : vx_core.Type_stringlistlist = valsub as vx_core.Type_stringlistlist
          ischanged = true
          listval.addAll(multi.vx_liststringlist())
        } else if (valsub is vx_core.Type_stringlist) {
          var allowsub : vx_core.Type_stringlist = valsub as vx_core.Type_stringlist
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is vx_core.Type_stringlist) {
          ischanged = true
          listval.add(valsub as vx_core.Type_stringlist)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_stringlist) {
              var valitem : vx_core.Type_stringlist = item as vx_core.Type_stringlist
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/stringlistlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/stringlistlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_stringlistlist = vx_core.Class_stringlistlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringlistlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringlistlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "stringlistlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_stringlist), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_stringlistlist : vx_core.Type_stringlistlist = vx_core.Class_stringlistlist()
  val t_stringlistlist : vx_core.Type_stringlistlist = vx_core.Class_stringlistlist()

  interface Type_stringmap : vx_core.Type_map {
    fun vx_mapstring() : Map<String, vx_core.Type_string>
    fun vx_string(key : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_stringmap : vx_core.Class_base, Type_stringmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_string> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_string>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_string) {
        var castval : vx_core.Type_string = value as vx_core.Type_string
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>(this.vx_p_map)
        if (castval == vx_core.e_string) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_string(key : vx_core.Type_string) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var map : vx_core.Class_stringmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_string> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_string)
      return output
    }

    override fun vx_mapstring() : Map<String, vx_core.Type_string> {
      var output : Map<String, vx_core.Type_string> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_string(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_stringmap = vx_core.Class_stringmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_string) {
          var castval : vx_core.Type_string = value as vx_core.Type_string
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/stringmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringmap = vx_core.vx_copy(vx_core.e_stringmap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_stringmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>(value.vx_mapstring())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/stringmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_string = vx_core.e_string
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valallowed : vx_core.Type_string = valsub as vx_core.Type_string
            valany = valallowed
          } else if (valsub is String) {
            valany = vx_core.vx_new(vx_core.t_string, valsub)
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/stringmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_stringmap = vx_core.Class_stringmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "stringmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_stringmap : vx_core.Type_stringmap = vx_core.Class_stringmap()
  val t_stringmap : vx_core.Type_stringmap = vx_core.Class_stringmap()

  interface Type_stringmutablemap : vx_core.Type_map {
    fun vx_mapstring() : Map<String, vx_core.Type_string>
    fun vx_string(key : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_stringmutablemap : vx_core.Class_base, Type_stringmutablemap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_string> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_string>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_string) {
        var castval : vx_core.Type_string = value as vx_core.Type_string
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>(this.vx_p_map)
        if (castval == vx_core.e_string) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_string(key : vx_core.Type_string) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var map : vx_core.Class_stringmutablemap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_string> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_string)
      return output
    }

    override fun vx_mapstring() : Map<String, vx_core.Type_string> {
      var output : Map<String, vx_core.Type_string> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_string(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_stringmutablemap = vx_core.Class_stringmutablemap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_string) {
          var castval : vx_core.Type_string = value as vx_core.Type_string
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/stringmutablemap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringmutablemap = vx_core.vx_copy(vx_core.e_stringmutablemap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_stringmutablemap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_stringmutablemap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_string> = LinkedHashMap<String, vx_core.Type_string>(value.vx_mapstring())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/stringmutablemap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_string = vx_core.e_string
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valallowed : vx_core.Type_string = valsub as vx_core.Type_string
            valany = valallowed
          } else if (valsub is String) {
            valany = vx_core.vx_new(vx_core.t_string, valsub)
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/stringmutablemap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_stringmutablemap = vx_core.Class_stringmutablemap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringmutablemap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringmutablemap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "stringmutablemap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_stringmutablemap : vx_core.Type_stringmutablemap = vx_core.Class_stringmutablemap()
  val t_stringmutablemap : vx_core.Type_stringmutablemap = vx_core.Class_stringmutablemap()

  interface Type_struct : vx_core.Type_any {
    fun vx_any(key : vx_core.Type_string) : vx_core.Type_any
    fun vx_map() : Map<String, vx_core.Type_any>
  }

  class Class_struct : vx_core.Class_base, Type_struct {
    constructor() {}

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_struct = vx_core.vx_copy(vx_core.e_struct, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_struct = this
      var ischanged : Boolean = false
      var value : vx_core.Class_struct = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_struct = vx_core.Class_struct()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_struct
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_struct
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "struct", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_struct : vx_core.Type_struct = vx_core.Class_struct()
  val t_struct : vx_core.Type_struct = vx_core.Class_struct()

  interface Type_thenelse : vx_core.Type_struct {
    fun code() : vx_core.Type_string
    fun value() : vx_core.Type_any
    fun values() : vx_core.Type_list
    fun fn_cond() : vx_core.Func_boolean_from_func
    fun fn_any() : vx_core.Func_any_from_func
  }

  class Class_thenelse : vx_core.Class_base, Type_thenelse {
    constructor() {}

    var vx_p_code : vx_core.Type_string? = null

    override fun code() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_code
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_value : vx_core.Type_any? = null

    override fun value() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var testnull : vx_core.Type_any? = vx_p_value
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_values : vx_core.Type_list? = null

    override fun values() : vx_core.Type_list {
      var output : vx_core.Type_list = vx_core.e_list
      var testnull : vx_core.Type_list? = vx_p_values
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_fn_cond : vx_core.Func_boolean_from_func? = null

    override fun fn_cond() : vx_core.Func_boolean_from_func {
      var output : vx_core.Func_boolean_from_func = vx_core.e_boolean_from_func
      var testnull : vx_core.Func_boolean_from_func? = vx_p_fn_cond
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_fn_any : vx_core.Func_any_from_func? = null

    override fun fn_any() : vx_core.Func_any_from_func {
      var output : vx_core.Func_any_from_func = vx_core.e_any_from_func
      var testnull : vx_core.Func_any_from_func? = vx_p_fn_any
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":code")) {
        output = this.code()
      } else if ((skey==":value")) {
        output = this.value()
      } else if ((skey==":values")) {
        output = this.values()
      } else if ((skey==":fn-cond")) {
        output = this.fn_cond()
      } else if ((skey==":fn-any")) {
        output = this.fn_any()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":code", this.code())
      map.put(":value", this.value())
      map.put(":values", this.values())
      map.put(":fn-cond", this.fn_cond())
      map.put(":fn-any", this.fn_any())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_thenelse = vx_core.vx_copy(vx_core.e_thenelse, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_thenelse = this
      var ischanged : Boolean = false
      var value : vx_core.Class_thenelse = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_code : vx_core.Type_string = value.code()
      var vx_p_value : vx_core.Type_any = value.value()
      var vx_p_values : vx_core.Type_list = value.values()
      var vx_p_fn_cond : vx_core.Func_boolean_from_func = value.fn_cond()
      var vx_p_fn_any : vx_core.Func_any_from_func = value.fn_any()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":code")
      validkeys.add(":value")
      validkeys.add(":values")
      validkeys.add(":fn-cond")
      validkeys.add(":fn-any")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":code")) {
            if (valsub == vx_p_code) {
            } else if (valsub is vx_core.Type_string) {
              var valcode : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_code = valcode
            } else if (valsub is String) {
              ischanged = true
              vx_p_code = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("code"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":value")) {
            if (valsub == vx_p_value) {
            } else if (valsub is vx_core.Type_any) {
              var valvalue : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_value = valvalue
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("value"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":values")) {
            if (valsub == vx_p_values) {
            } else if (valsub is vx_core.Type_list) {
              var valvalues : vx_core.Type_list = valsub as vx_core.Type_list
              ischanged = true
              vx_p_values = valvalues
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("values"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":fn-cond")) {
            if (valsub == vx_p_fn_cond) {
            } else if (valsub is vx_core.Func_boolean_from_func) {
              var valfn_cond : vx_core.Func_boolean_from_func = valsub as vx_core.Func_boolean_from_func
              ischanged = true
              vx_p_fn_cond = valfn_cond
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("fn-cond"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":fn-any")) {
            if (valsub == vx_p_fn_any) {
            } else if (valsub is vx_core.Func_any_from_func) {
              var valfn_any : vx_core.Func_any_from_func = valsub as vx_core.Func_any_from_func
              ischanged = true
              vx_p_fn_any = valfn_any
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("fn-any"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/thenelse", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_thenelse = vx_core.Class_thenelse()
        work.vx_p_code = vx_p_code
        work.vx_p_value = vx_p_value
        work.vx_p_values = vx_p_values
        work.vx_p_fn_cond = vx_p_fn_cond
        work.vx_p_fn_any = vx_p_fn_any
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_thenelse
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_thenelse
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "thenelse", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_thenelse : vx_core.Type_thenelse = vx_core.Class_thenelse()
  val t_thenelse : vx_core.Type_thenelse = vx_core.Class_thenelse()

  interface Type_thenelselist : vx_core.Type_list {
    fun vx_listthenelse() : List<vx_core.Type_thenelse>
    fun vx_thenelse(index : vx_core.Type_int) : vx_core.Type_thenelse
  }

  class Class_thenelselist : vx_core.Class_base, Type_thenelselist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_thenelse> = vx_core.immutablelist(
      ArrayList<vx_core.Type_thenelse>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_thenelse(index : vx_core.Type_int) : vx_core.Type_thenelse {
      var output : vx_core.Type_thenelse = vx_core.e_thenelse
      var list : vx_core.Class_thenelselist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_thenelse> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listthenelse() : List<vx_core.Type_thenelse> {
      var output : List<vx_core.Type_thenelse> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_thenelse = this.vx_thenelse(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_thenelselist = vx_core.vx_copy(vx_core.e_thenelselist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_thenelselist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_thenelselist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_thenelse> = ArrayList<vx_core.Type_thenelse>(value.vx_listthenelse())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_thenelselist) {
          var multi : vx_core.Type_thenelselist = valsub as vx_core.Type_thenelselist
          ischanged = true
          listval.addAll(multi.vx_listthenelse())
        } else if (valsub is vx_core.Type_thenelse) {
          var allowsub : vx_core.Type_thenelse = valsub as vx_core.Type_thenelse
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is vx_core.Type_thenelse) {
          ischanged = true
          listval.add(valsub as vx_core.Type_thenelse)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_thenelse) {
              var valitem : vx_core.Type_thenelse = item as vx_core.Type_thenelse
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/thenelselist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/thenelselist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_thenelselist = vx_core.Class_thenelselist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_thenelselist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_thenelselist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "thenelselist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_thenelse), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_thenelselist : vx_core.Type_thenelselist = vx_core.Class_thenelselist()
  val t_thenelselist : vx_core.Type_thenelselist = vx_core.Class_thenelselist()

  interface Type_translation : vx_core.Type_struct {
    fun name() : vx_core.Type_string
    fun wordmap() : vx_core.Type_stringmap
  }

  class Class_translation : vx_core.Class_base, Type_translation {
    constructor() {}

    var vx_p_name : vx_core.Type_string? = null

    override fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_name
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_wordmap : vx_core.Type_stringmap? = null

    override fun wordmap() : vx_core.Type_stringmap {
      var output : vx_core.Type_stringmap = vx_core.e_stringmap
      var testnull : vx_core.Type_stringmap? = vx_p_wordmap
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":name")) {
        output = this.name()
      } else if ((skey==":wordmap")) {
        output = this.wordmap()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":name", this.name())
      map.put(":wordmap", this.wordmap())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_translation = vx_core.vx_copy(vx_core.e_translation, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_translation = this
      var ischanged : Boolean = false
      var value : vx_core.Class_translation = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_wordmap : vx_core.Type_stringmap = value.wordmap()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":name")
      validkeys.add(":wordmap")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":wordmap")) {
            if (valsub == vx_p_wordmap) {
            } else if (valsub is vx_core.Type_stringmap) {
              var valwordmap : vx_core.Type_stringmap = valsub as vx_core.Type_stringmap
              ischanged = true
              vx_p_wordmap = valwordmap
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("wordmap"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/translation", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_translation = vx_core.Class_translation()
        work.vx_p_name = vx_p_name
        work.vx_p_wordmap = vx_p_wordmap
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_translation
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_translation
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "translation", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_translation : vx_core.Type_translation = vx_core.Class_translation()
  val t_translation : vx_core.Type_translation = vx_core.Class_translation()

  interface Type_translationlist : vx_core.Type_list {
    fun vx_listtranslation() : List<vx_core.Type_translation>
    fun vx_translation(index : vx_core.Type_int) : vx_core.Type_translation
  }

  class Class_translationlist : vx_core.Class_base, Type_translationlist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_translation> = vx_core.immutablelist(
      ArrayList<vx_core.Type_translation>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_translation(index : vx_core.Type_int) : vx_core.Type_translation {
      var output : vx_core.Type_translation = vx_core.e_translation
      var list : vx_core.Class_translationlist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_translation> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_listtranslation() : List<vx_core.Type_translation> {
      var output : List<vx_core.Type_translation> = this.vx_p_list
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_translation = this.vx_translation(index)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_translationlist = vx_core.vx_copy(vx_core.e_translationlist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_translationlist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_translationlist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_translation> = ArrayList<vx_core.Type_translation>(value.vx_listtranslation())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_translationlist) {
          var multi : vx_core.Type_translationlist = valsub as vx_core.Type_translationlist
          ischanged = true
          listval.addAll(multi.vx_listtranslation())
        } else if (valsub is vx_core.Type_translation) {
          var allowsub : vx_core.Type_translation = valsub as vx_core.Type_translation
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is vx_core.Type_translation) {
          ischanged = true
          listval.add(valsub as vx_core.Type_translation)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_translation) {
              var valitem : vx_core.Type_translation = item as vx_core.Type_translation
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/translationlist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/translationlist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_translationlist = vx_core.Class_translationlist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_translationlist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_translationlist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "translationlist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_translation), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_translationlist : vx_core.Type_translationlist = vx_core.Class_translationlist()
  val t_translationlist : vx_core.Type_translationlist = vx_core.Class_translationlist()

  interface Type_translationmap : vx_core.Type_map {
    fun vx_maptranslation() : Map<String, vx_core.Type_translation>
    fun vx_translation(key : vx_core.Type_string) : vx_core.Type_translation
  }

  class Class_translationmap : vx_core.Class_base, Type_translationmap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_translation> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_translation>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_translation) {
        var castval : vx_core.Type_translation = value as vx_core.Type_translation
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_translation> = LinkedHashMap<String, vx_core.Type_translation>(this.vx_p_map)
        if (castval == vx_core.e_translation) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_translation(key : vx_core.Type_string) : vx_core.Type_translation {
      var output : vx_core.Type_translation = vx_core.e_translation
      var map : vx_core.Class_translationmap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_translation> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_translation)
      return output
    }

    override fun vx_maptranslation() : Map<String, vx_core.Type_translation> {
      var output : Map<String, vx_core.Type_translation> = this.vx_p_map
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = this.vx_translation(key)
      return output
    }


    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_translationmap = vx_core.Class_translationmap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_translation> = LinkedHashMap<String, vx_core.Type_translation>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_translation) {
          var castval : vx_core.Type_translation = value as vx_core.Type_translation
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/translationmap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_translationmap = vx_core.vx_copy(vx_core.e_translationmap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_translationmap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_translationmap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_translation> = LinkedHashMap<String, vx_core.Type_translation>(value.vx_maptranslation())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/translationmap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_translation = vx_core.e_translation
          if (false) {
          } else if (valsub is vx_core.Type_translation) {
            var valallowed : vx_core.Type_translation = valsub as vx_core.Type_translation
            valany = valallowed
          } else if (valsub is vx_core.Type_translation) {
            valany = valsub as vx_core.Type_translation
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/translationmap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_translationmap = vx_core.Class_translationmap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_translationmap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_translationmap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "translationmap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_translation), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_translationmap : vx_core.Type_translationmap = vx_core.Class_translationmap()
  val t_translationmap : vx_core.Type_translationmap = vx_core.Class_translationmap()

  interface Type_type : vx_core.Type_any {
  }

  class Class_type : vx_core.Class_base, Type_type {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_type = vx_core.vx_copy(vx_core.e_type, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_type = this
      var ischanged : Boolean = false
      var value : vx_core.Class_type = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_type = vx_core.Class_type()
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_type
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_type
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "type", // name
        ":type", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_type : vx_core.Type_type = vx_core.Class_type()
  val t_type : vx_core.Type_type = vx_core.Class_type()

  interface Type_typedef : vx_core.Type_struct {
    fun pkgname() : vx_core.Type_string
    fun name() : vx_core.Type_string
    fun extend() : vx_core.Type_string
    fun allowfuncs() : vx_core.Type_funclist
    fun allowtypes() : vx_core.Type_typelist
    fun allowvalues() : vx_core.Type_anylist
    fun disallowfuncs() : vx_core.Type_funclist
    fun disallowtypes() : vx_core.Type_typelist
    fun disallowvalues() : vx_core.Type_anylist
    fun properties() : vx_core.Type_argmap
    fun proplast() : vx_core.Type_arg
    fun traits() : vx_core.Type_typelist
  }

  class Class_typedef : vx_core.Class_base, Type_typedef {
    constructor() {}

    var vx_p_pkgname : vx_core.Type_string? = null

    override fun pkgname() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_pkgname
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_name : vx_core.Type_string? = null

    override fun name() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_name
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_extend : vx_core.Type_string? = null

    override fun extend() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_extend
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_allowfuncs : vx_core.Type_funclist? = null

    override fun allowfuncs() : vx_core.Type_funclist {
      var output : vx_core.Type_funclist = vx_core.e_funclist
      var testnull : vx_core.Type_funclist? = vx_p_allowfuncs
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_allowtypes : vx_core.Type_typelist? = null

    override fun allowtypes() : vx_core.Type_typelist {
      var output : vx_core.Type_typelist = vx_core.e_typelist
      var testnull : vx_core.Type_typelist? = vx_p_allowtypes
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_allowvalues : vx_core.Type_anylist? = null

    override fun allowvalues() : vx_core.Type_anylist {
      var output : vx_core.Type_anylist = vx_core.e_anylist
      var testnull : vx_core.Type_anylist? = vx_p_allowvalues
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_disallowfuncs : vx_core.Type_funclist? = null

    override fun disallowfuncs() : vx_core.Type_funclist {
      var output : vx_core.Type_funclist = vx_core.e_funclist
      var testnull : vx_core.Type_funclist? = vx_p_disallowfuncs
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_disallowtypes : vx_core.Type_typelist? = null

    override fun disallowtypes() : vx_core.Type_typelist {
      var output : vx_core.Type_typelist = vx_core.e_typelist
      var testnull : vx_core.Type_typelist? = vx_p_disallowtypes
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_disallowvalues : vx_core.Type_anylist? = null

    override fun disallowvalues() : vx_core.Type_anylist {
      var output : vx_core.Type_anylist = vx_core.e_anylist
      var testnull : vx_core.Type_anylist? = vx_p_disallowvalues
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_properties : vx_core.Type_argmap? = null

    override fun properties() : vx_core.Type_argmap {
      var output : vx_core.Type_argmap = vx_core.e_argmap
      var testnull : vx_core.Type_argmap? = vx_p_properties
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_proplast : vx_core.Type_arg? = null

    override fun proplast() : vx_core.Type_arg {
      var output : vx_core.Type_arg = vx_core.e_arg
      var testnull : vx_core.Type_arg? = vx_p_proplast
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_traits : vx_core.Type_typelist? = null

    override fun traits() : vx_core.Type_typelist {
      var output : vx_core.Type_typelist = vx_core.e_typelist
      var testnull : vx_core.Type_typelist? = vx_p_traits
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":pkgname")) {
        output = this.pkgname()
      } else if ((skey==":name")) {
        output = this.name()
      } else if ((skey==":extends")) {
        output = this.extend()
      } else if ((skey==":allowfuncs")) {
        output = this.allowfuncs()
      } else if ((skey==":allowtypes")) {
        output = this.allowtypes()
      } else if ((skey==":allowvalues")) {
        output = this.allowvalues()
      } else if ((skey==":disallowfuncs")) {
        output = this.disallowfuncs()
      } else if ((skey==":disallowtypes")) {
        output = this.disallowtypes()
      } else if ((skey==":disallowvalues")) {
        output = this.disallowvalues()
      } else if ((skey==":properties")) {
        output = this.properties()
      } else if ((skey==":proplast")) {
        output = this.proplast()
      } else if ((skey==":traits")) {
        output = this.traits()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":pkgname", this.pkgname())
      map.put(":name", this.name())
      map.put(":extends", this.extend())
      map.put(":allowfuncs", this.allowfuncs())
      map.put(":allowtypes", this.allowtypes())
      map.put(":allowvalues", this.allowvalues())
      map.put(":disallowfuncs", this.disallowfuncs())
      map.put(":disallowtypes", this.disallowtypes())
      map.put(":disallowvalues", this.disallowvalues())
      map.put(":properties", this.properties())
      map.put(":proplast", this.proplast())
      map.put(":traits", this.traits())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_typedef = vx_core.vx_copy(vx_core.e_typedef, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_typedef = this
      var ischanged : Boolean = false
      var value : vx_core.Class_typedef = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_pkgname : vx_core.Type_string = value.pkgname()
      var vx_p_name : vx_core.Type_string = value.name()
      var vx_p_extend : vx_core.Type_string = value.extend()
      var vx_p_allowfuncs : vx_core.Type_funclist = value.allowfuncs()
      var vx_p_allowtypes : vx_core.Type_typelist = value.allowtypes()
      var vx_p_allowvalues : vx_core.Type_anylist = value.allowvalues()
      var vx_p_disallowfuncs : vx_core.Type_funclist = value.disallowfuncs()
      var vx_p_disallowtypes : vx_core.Type_typelist = value.disallowtypes()
      var vx_p_disallowvalues : vx_core.Type_anylist = value.disallowvalues()
      var vx_p_properties : vx_core.Type_argmap = value.properties()
      var vx_p_proplast : vx_core.Type_arg = value.proplast()
      var vx_p_traits : vx_core.Type_typelist = value.traits()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":pkgname")
      validkeys.add(":name")
      validkeys.add(":extends")
      validkeys.add(":allowfuncs")
      validkeys.add(":allowtypes")
      validkeys.add(":allowvalues")
      validkeys.add(":disallowfuncs")
      validkeys.add(":disallowtypes")
      validkeys.add(":disallowvalues")
      validkeys.add(":properties")
      validkeys.add(":proplast")
      validkeys.add(":traits")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":pkgname")) {
            if (valsub == vx_p_pkgname) {
            } else if (valsub is vx_core.Type_string) {
              var valpkgname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_pkgname = valpkgname
            } else if (valsub is String) {
              ischanged = true
              vx_p_pkgname = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("pkgname"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":name")) {
            if (valsub == vx_p_name) {
            } else if (valsub is vx_core.Type_string) {
              var valname : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_name = valname
            } else if (valsub is String) {
              ischanged = true
              vx_p_name = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("name"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":extends")) {
            if (valsub == vx_p_extend) {
            } else if (valsub is vx_core.Type_string) {
              var valextend : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_extend = valextend
            } else if (valsub is String) {
              ischanged = true
              vx_p_extend = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("extends"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":allowfuncs")) {
            if (valsub == vx_p_allowfuncs) {
            } else if (valsub is vx_core.Type_funclist) {
              var valallowfuncs : vx_core.Type_funclist = valsub as vx_core.Type_funclist
              ischanged = true
              vx_p_allowfuncs = valallowfuncs
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("allowfuncs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":allowtypes")) {
            if (valsub == vx_p_allowtypes) {
            } else if (valsub is vx_core.Type_typelist) {
              var valallowtypes : vx_core.Type_typelist = valsub as vx_core.Type_typelist
              ischanged = true
              vx_p_allowtypes = valallowtypes
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("allowtypes"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":allowvalues")) {
            if (valsub == vx_p_allowvalues) {
            } else if (valsub is vx_core.Type_anylist) {
              var valallowvalues : vx_core.Type_anylist = valsub as vx_core.Type_anylist
              ischanged = true
              vx_p_allowvalues = valallowvalues
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("allowvalues"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":disallowfuncs")) {
            if (valsub == vx_p_disallowfuncs) {
            } else if (valsub is vx_core.Type_funclist) {
              var valdisallowfuncs : vx_core.Type_funclist = valsub as vx_core.Type_funclist
              ischanged = true
              vx_p_disallowfuncs = valdisallowfuncs
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("disallowfuncs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":disallowtypes")) {
            if (valsub == vx_p_disallowtypes) {
            } else if (valsub is vx_core.Type_typelist) {
              var valdisallowtypes : vx_core.Type_typelist = valsub as vx_core.Type_typelist
              ischanged = true
              vx_p_disallowtypes = valdisallowtypes
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("disallowtypes"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":disallowvalues")) {
            if (valsub == vx_p_disallowvalues) {
            } else if (valsub is vx_core.Type_anylist) {
              var valdisallowvalues : vx_core.Type_anylist = valsub as vx_core.Type_anylist
              ischanged = true
              vx_p_disallowvalues = valdisallowvalues
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("disallowvalues"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":properties")) {
            if (valsub == vx_p_properties) {
            } else if (valsub is vx_core.Type_argmap) {
              var valproperties : vx_core.Type_argmap = valsub as vx_core.Type_argmap
              ischanged = true
              vx_p_properties = valproperties
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("properties"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":proplast")) {
            if (valsub == vx_p_proplast) {
            } else if (valsub is vx_core.Type_arg) {
              var valproplast : vx_core.Type_arg = valsub as vx_core.Type_arg
              ischanged = true
              vx_p_proplast = valproplast
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("proplast"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":traits")) {
            if (valsub == vx_p_traits) {
            } else if (valsub is vx_core.Type_typelist) {
              var valtraits : vx_core.Type_typelist = valsub as vx_core.Type_typelist
              ischanged = true
              vx_p_traits = valtraits
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("traits"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/typedef", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_typedef = vx_core.Class_typedef()
        work.vx_p_pkgname = vx_p_pkgname
        work.vx_p_name = vx_p_name
        work.vx_p_extend = vx_p_extend
        work.vx_p_allowfuncs = vx_p_allowfuncs
        work.vx_p_allowtypes = vx_p_allowtypes
        work.vx_p_allowvalues = vx_p_allowvalues
        work.vx_p_disallowfuncs = vx_p_disallowfuncs
        work.vx_p_disallowtypes = vx_p_disallowtypes
        work.vx_p_disallowvalues = vx_p_disallowvalues
        work.vx_p_properties = vx_p_properties
        work.vx_p_proplast = vx_p_proplast
        work.vx_p_traits = vx_p_traits
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typedef
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "typedef", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_typedef : vx_core.Type_typedef = vx_core.Class_typedef()
  val t_typedef : vx_core.Type_typedef = vx_core.Class_typedef()

  interface Type_typelist : vx_core.Type_list {
  }

  class Class_typelist : vx_core.Class_base, Type_typelist {
    constructor() {}

    var vx_p_list : List<vx_core.Type_any> = vx_core.immutablelist(
      ArrayList<vx_core.Type_any>()
    )

    override fun vx_list() : List<vx_core.Type_any> {
      var output : List<vx_core.Type_any> = vx_core.immutablelist(
        ArrayList<vx_core.Type_any>(this.vx_p_list)
      )
      return output
    }

    override fun vx_any(index : vx_core.Type_int) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var list : vx_core.Class_typelist = this
      var iindex : Int = index.vx_int()
      var listval : List<vx_core.Type_any> = list.vx_p_list
      if (iindex < listval.size) {
        output = listval.get(iindex)
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_typelist = vx_core.vx_copy(vx_core.e_typelist, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_typelist = this
      var ischanged : Boolean = false
      var value : vx_core.Class_typelist = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var listval : MutableList<vx_core.Type_any> = ArrayList<vx_core.Type_any>(value.vx_list())
      var msg : vx_core.Type_msg
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_typelist) {
          var multi : vx_core.Type_typelist = valsub as vx_core.Type_typelist
          ischanged = true
          listval.addAll(multi.vx_list())
        } else if (valsub is vx_core.Type_any) {
          var allowsub : vx_core.Type_any = valsub as vx_core.Type_any
          ischanged = true
          listval.add(allowsub)
        } else if (valsub is List<*>) {
          var listunknown : List<Any> = valsub as List<Any>
          for (item : Any in listunknown) {
            if (false) {
            } else if (item is vx_core.Type_any) {
              var valitem : vx_core.Type_any = item as vx_core.Type_any
              ischanged = true
              listval.add(valitem)
            }
          }
        } else if (valsub is vx_core.Type_any) {
          var anyinvalid : vx_core.Type_any = valsub as vx_core.Type_any
          msg = vx_core.vx_msg_from_error("vx/core/typelist", ":invalidtype", anyinvalid)
          msgblock = vx_core.vx_copy(msgblock, msg)
        } else {
          msg = vx_core.vx_msg_from_error("vx/core/typelist", ":invalidtype", vx_core.vx_new_string(valsub.toString()))
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_typelist = vx_core.Class_typelist()
        work.vx_p_list = vx_core.immutablelist(listval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typelist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typelist
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "typelist", // name
        ":list", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_typelist : vx_core.Type_typelist = vx_core.Class_typelist()
  val t_typelist : vx_core.Type_typelist = vx_core.Class_typelist()

  interface Type_typemap : vx_core.Type_map {
  }

  class Class_typemap : vx_core.Class_base, Type_typemap {
    constructor() {}

    var vx_p_map : Map<String, vx_core.Type_any> = vx_core.immutablemap(LinkedHashMap<String, vx_core.Type_any>())

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
      return vx_core.immutablemap(map)
    }

    override fun vx_set(name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      if (false) {
      } else if (value is vx_core.Type_any) {
        var castval : vx_core.Type_any = value as vx_core.Type_any
        var key : String = name.vx_string()
        if (key.startsWith(":")) {
          key = key.substring(1)
        }
        var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(this.vx_p_map)
        if (castval == vx_core.e_any) {
          map.remove(key)
        } else {
          map.put(key, castval)
        }
        this.vx_p_map = vx_core.immutablemap(map)
        output = vx_core.c_true
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Class_typemap = this
      var skey : String = key.vx_string()
      var mapval : Map<String, vx_core.Type_any> = map.vx_p_map
      output = mapval.getOrDefault(skey, vx_core.e_any)
      return output
    }

    override fun vx_new_from_map(mapval : Map<String, vx_core.Type_any>) : vx_core.Type_map {
      var output : vx_core.Class_typemap = vx_core.Class_typemap()
      var msgblock : vx_core.Type_msgblock = vx_core.e_msgblock
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      val keys : Set<String> = mapval.keys
      for (key : String in keys) {
        var value : vx_core.Type_any = mapval.getOrDefault(key, vx_core.e_any)
        if (false) {
        } else if (value is vx_core.Type_any) {
          var castval : vx_core.Type_any = value as vx_core.Type_any
          map.put(key, castval)
        } else {
          var msg : vx_core.Type_msg = vx_core.vx_msg_from_error("vx/core/typemap", ":invalidvalue", value)
          msgblock = vx_core.vx_copy(msgblock, msg)
        }
      }
      output.vx_p_map = vx_core.immutablemap(map)
      if (msgblock != vx_core.e_msgblock) {
        output.vxmsgblock = msgblock
      }
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_typemap = vx_core.vx_copy(vx_core.e_typemap, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_typemap = this
      var ischanged : Boolean = false
      var value : vx_core.Class_typemap = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var mapval : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>(value.vx_map())
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstring : vx_core.Type_string = valsub as vx_core.Type_string
            key = valstring.vx_string()
          } else if (valsub is String) {
            var sval : String = valsub as String
            key = sval
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/typemap", ":keyexpected", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
        } else {
          var valany : vx_core.Type_any = vx_core.e_any
          if (false) {
          } else if (valsub is vx_core.Type_any) {
            var valallowed : vx_core.Type_any = valsub as vx_core.Type_any
            valany = valallowed
          } else if (valsub is vx_core.Type_any) {
            valany = valsub as vx_core.Type_any
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valinvalid
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
            mapany.put("key", vx_core.vx_new_string(key))
            mapany.put("value", msgval)
            var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
            msg = vx_core.vx_msg_from_error("vx/core/typemap", ":invalidkeyvalue", msgmap)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (valany != vx_core.e_any) {
            ischanged = true
            if (key.startsWith(":")) {
              key = key.substring(1)
            }
            mapval.put(key, valany)
            key = ""
          }
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_typemap = vx_core.Class_typemap()
        work.vx_p_map = vx_core.immutablemap(mapval)
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typemap
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typemap
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "typemap", // name
        ":map", // extends
        vx_core.e_typelist, // traits
        vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_typemap : vx_core.Type_typemap = vx_core.Class_typemap()
  val t_typemap : vx_core.Type_typemap = vx_core.Class_typemap()

  interface Type_user : vx_core.Type_struct {
    fun security() : vx_core.Type_security
    fun username() : vx_core.Type_string
    fun token() : vx_core.Type_string
  }

  class Class_user : vx_core.Class_base, Type_user {
    constructor() {}

    var vx_p_security : vx_core.Type_security? = null

    override fun security() : vx_core.Type_security {
      var output : vx_core.Type_security = vx_core.e_security
      var testnull : vx_core.Type_security? = vx_p_security
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_username : vx_core.Type_string? = null

    override fun username() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_username
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_token : vx_core.Type_string? = null

    override fun token() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.e_string
      var testnull : vx_core.Type_string? = vx_p_token
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":security")) {
        output = this.security()
      } else if ((skey==":username")) {
        output = this.username()
      } else if ((skey==":token")) {
        output = this.token()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":security", this.security())
      map.put(":username", this.username())
      map.put(":token", this.token())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_user = vx_core.vx_copy(vx_core.e_user, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_user = this
      var ischanged : Boolean = false
      var value : vx_core.Class_user = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_security : vx_core.Type_security = value.security()
      var vx_p_username : vx_core.Type_string = value.username()
      var vx_p_token : vx_core.Type_string = value.token()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":security")
      validkeys.add(":username")
      validkeys.add(":token")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":security")) {
            if (valsub == vx_p_security) {
            } else if (valsub is vx_core.Type_security) {
              var valsecurity : vx_core.Type_security = valsub as vx_core.Type_security
              ischanged = true
              vx_p_security = valsecurity
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("security"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":username")) {
            if (valsub == vx_p_username) {
            } else if (valsub is vx_core.Type_string) {
              var valusername : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_username = valusername
            } else if (valsub is String) {
              ischanged = true
              vx_p_username = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("username"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":token")) {
            if (valsub == vx_p_token) {
            } else if (valsub is vx_core.Type_string) {
              var valtoken : vx_core.Type_string = valsub as vx_core.Type_string
              ischanged = true
              vx_p_token = valtoken
            } else if (valsub is String) {
              ischanged = true
              vx_p_token = vx_core.vx_new(vx_core.t_string, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("token"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/user", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_user = vx_core.Class_user()
        work.vx_p_security = vx_p_security
        work.vx_p_username = vx_p_username
        work.vx_p_token = vx_p_token
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_user
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_user
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "user", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_user : vx_core.Type_user = vx_core.Class_user()
  val t_user : vx_core.Type_user = vx_core.Class_user()

  interface Type_value : vx_core.Type_struct {
    fun next() : vx_core.Type_any
    fun refs() : vx_core.Type_int
  }

  class Class_value : vx_core.Class_base, Type_value {
    constructor() {}

    var vx_p_next : vx_core.Type_any? = null

    override fun next() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var testnull : vx_core.Type_any? = vx_p_next
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    var vx_p_refs : vx_core.Type_int? = null

    override fun refs() : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.e_int
      var testnull : vx_core.Type_int? = vx_p_refs
      if (testnull != null) {
        output = testnull
      }
      return output
    }

    override fun vx_any(key : vx_core.Type_string) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var skey : String = key.vx_string()
      if (false) {
      } else if ((skey==":next")) {
        output = this.next()
      } else if ((skey==":refs")) {
        output = this.refs()
      }
      return output
    }

    override fun vx_map() : Map<String, vx_core.Type_any> {
      var map : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
      map.put(":next", this.next())
      map.put(":refs", this.refs())
      var output : Map<String, vx_core.Type_any> = vx_core.immutablemap(map)
      return output
    }

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_value = vx_core.vx_copy(vx_core.e_value, *vals)
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      var output : vx_core.Type_value = this
      var ischanged : Boolean = false
      var value : vx_core.Class_value = this
      var msgblock : vx_core.Type_msgblock = vx_core.vx_msgblock_from_copy_arrayval(value, vals)
      if (this.vx_constdef() != vx_core.e_constdef) {
        ischanged = true
      }
      var vx_p_next : vx_core.Type_any = value.next()
      var vx_p_refs : vx_core.Type_int = value.refs()
      var validkeys : MutableList<String> = ArrayList<String>()
      validkeys.add(":next")
      validkeys.add(":refs")
      var key : String = ""
      var msg : vx_core.Type_msg = vx_core.e_msg
      var msgval : vx_core.Type_any = vx_core.e_any
      for (valsub : Any in vals) {
        if (valsub is vx_core.Type_msgblock) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (valsub is vx_core.Type_msg) {
          msgblock = vx_core.vx_copy(msgblock, valsub)
        } else if (key.equals("")) {
          var istestkey : Boolean = false
          var testkey : String = ""
          if (false) {
          } else if (valsub is vx_core.Type_string) {
            var valstr : vx_core.Type_string = valsub as vx_core.Type_string
            testkey = valstr.vx_string()
            istestkey = true
          } else if (valsub is String) {
            var sval : String = valsub as String
            testkey = sval
            istestkey = true
          } else {
            if (false) {
            } else if (valsub is vx_core.Type_any) {
              var valmsg : vx_core.Type_any = valsub as vx_core.Type_any
              msgval = valmsg
            } else {
              msgval = vx_core.vx_new_string(valsub.toString())
            }
            msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidkeytype", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          if (istestkey) {
            if (!testkey.startsWith(":")) {
              testkey = ":" + testkey
            }
            var isvalidkey : Boolean = validkeys.contains(testkey)
            if (isvalidkey) {
              key = testkey
            } else {
              msgval = vx_core.vx_new_string(testkey)
              msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidkey", msgval)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          }
        } else {
          if (false) {
          } else if ((key==":next")) {
            if (valsub == vx_p_next) {
            } else if (valsub is vx_core.Type_any) {
              var valnext : vx_core.Type_any = valsub as vx_core.Type_any
              ischanged = true
              vx_p_next = valnext
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("next"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else if ((key==":refs")) {
            if (valsub == vx_p_refs) {
            } else if (valsub is vx_core.Type_int) {
              var valrefs : vx_core.Type_int = valsub as vx_core.Type_int
              ischanged = true
              vx_p_refs = valrefs
            } else if (valsub is Int) {
              ischanged = true
              vx_p_refs = vx_core.vx_new(vx_core.t_int, valsub)
            } else {
              if (false) {
              } else if (valsub is vx_core.Type_any) {
                var valinvalid : vx_core.Type_any = valsub as vx_core.Type_any
                msgval = valinvalid
              } else {
                msgval = vx_core.vx_new_string(valsub.toString())
              }
              var mapany : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
              mapany.put("key", vx_core.vx_new_string("refs"))
              mapany.put("value", msgval)
              var msgmap : vx_core.Type_map = vx_core.t_anymap.vx_new_from_map(mapany)
              msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidvalue", msgmap)
              msgblock = vx_core.vx_copy(msgblock, msg)
            }
          } else {
            msgval = vx_core.vx_new_string(key)
            msg = vx_core.vx_msg_from_error("vx/core/value", ":invalidkey", msgval)
            msgblock = vx_core.vx_copy(msgblock, msg)
          }
          key = ""
        }
      }
      if (ischanged || (msgblock != vx_core.e_msgblock)) {
        var work : vx_core.Class_value = vx_core.Class_value()
        work.vx_p_next = vx_p_next
        work.vx_p_refs = vx_p_refs
        if (msgblock != vx_core.e_msgblock) {
          work.vxmsgblock = msgblock
        }
        output = work
      }
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_value
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_value
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.typedef_new(
        "vx/core", // pkgname
        "value", // name
        ":struct", // extends
        vx_core.e_typelist, // traits
        vx_core.e_typelist, // allowtypes
        vx_core.e_typelist, // disallowtypes
        vx_core.e_funclist, // allowfuncs
        vx_core.e_funclist, // disallowfuncs
        vx_core.e_anylist, // allowvalues
        vx_core.e_anylist, // disallowvalues
        vx_core.e_argmap // properties
      )
      return output
    }

  }

  val e_value : vx_core.Type_value = vx_core.Class_value()
  val t_value : vx_core.Type_value = vx_core.Class_value()

  class Const_false {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "false", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_boolean) : Unit {
      var outval : vx_core.Class_boolean = output as vx_core.Class_boolean
      outval.vx_p_constdef = constdef()
      outval.vxboolean = false
    }

    }
  }

  val c_false : vx_core.Type_boolean = vx_core.Class_boolean()

  val e_boolean : vx_core.Type_boolean = vx_core.c_false

  class Const_global {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "global", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "project", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_project) : Unit {
      var outval : vx_core.Class_project = output as vx_core.Class_project
      outval.vx_p_constdef = constdef()
    }

    }
  }

  val c_global : vx_core.Type_project = vx_core.Class_project()


  class Const_infinity {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "infinity", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 0
    }

    }
  }

  val c_infinity : vx_core.Type_int = vx_core.Class_int()


  class Const_mempool_active {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "mempool-active", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "mempool", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_mempool) : Unit {
      var outval : vx_core.Class_mempool = output as vx_core.Class_mempool
      outval.vx_p_constdef = constdef()
    }

    }
  }

  val c_mempool_active : vx_core.Type_mempool = vx_core.Class_mempool()


  class Const_msg_error {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "msg-error", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 2
    }

    }
  }

  val c_msg_error : vx_core.Type_int = vx_core.Class_int()


  class Const_msg_info {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "msg-info", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 0
    }

    }
  }

  val c_msg_info : vx_core.Type_int = vx_core.Class_int()


  class Const_msg_severe {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "msg-severe", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 3
    }

    }
  }

  val c_msg_severe : vx_core.Type_int = vx_core.Class_int()


  class Const_msg_warning {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "msg-warning", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 1
    }

    }
  }

  val c_msg_warning : vx_core.Type_int = vx_core.Class_int()


  class Const_neginfinity {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "neginfinity", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 0
    }

    }
  }

  val c_neginfinity : vx_core.Type_int = vx_core.Class_int()


  class Const_newline {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "newline", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_string) : Unit {
      var outval : vx_core.Class_string = output as vx_core.Class_string
      outval.vx_p_constdef = constdef()
      outval.vxstring = "\n"
    }

    }
  }

  val c_newline : vx_core.Type_string = vx_core.Class_string()


  class Const_notanumber {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "notanumber", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_int) : Unit {
      var outval : vx_core.Class_int = output as vx_core.Class_int
      outval.vx_p_constdef = constdef()
      outval.vxint = 0
    }

    }
  }

  val c_notanumber : vx_core.Type_int = vx_core.Class_int()


  class Const_nothing {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "nothing", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_string) : Unit {
      var outval : vx_core.Class_string = output as vx_core.Class_string
      outval.vx_p_constdef = constdef()
      outval.vxstring = "nothing"
    }

    }
  }

  val c_nothing : vx_core.Type_string = vx_core.Class_string()


  class Const_path_test_resources {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "path-test-resources", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_string) : Unit {
      var outval : vx_core.Class_string = output as vx_core.Class_string
      outval.vx_p_constdef = constdef()
      outval.vxstring = "src/test/kotlin/resources"
    }

    }
  }

  val c_path_test_resources : vx_core.Type_string = vx_core.Class_string()


  class Const_quote {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "quote", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_string) : Unit {
      var outval : vx_core.Class_string = output as vx_core.Class_string
      outval.vx_p_constdef = constdef()
      outval.vxstring = "\""
    }

    }
  }

  val c_quote : vx_core.Type_string = vx_core.Class_string()


  class Const_true {
    constructor() {}
    companion object {

    fun constdef() : vx_core.Type_constdef {
      var output : vx_core.Type_constdef = vx_core.constdef_new(
        "vx/core", // pkgname
        "true", // name
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        )
      )
      return output
    }

    fun const_new(output : vx_core.Type_boolean) : Unit {
      var outval : vx_core.Class_boolean = output as vx_core.Class_boolean
      outval.vx_p_constdef = constdef()
      outval.vxboolean = true
    }

    }
  }

  val c_true : vx_core.Type_boolean = vx_core.Class_boolean()


  interface Func_not : vx_core.Func_any_from_any {
    fun vx_not(value : vx_core.Type_boolean) : vx_core.Type_boolean
  }

  class Class_not : vx_core.Class_base, Func_not {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_not = vx_core.Class_not()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_not = vx_core.Class_not()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_not
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_not
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_boolean = value as vx_core.Type_boolean
      var outputval : vx_core.Type_any = vx_core.f_not(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_not(value)
      return output
    }

    override fun vx_not(value : vx_core.Type_boolean) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_not(value)
      return output
    }

  }

  val e_not : vx_core.Func_not = vx_core.Class_not()
  val t_not : vx_core.Func_not = vx_core.Class_not()

  fun f_not(value : vx_core.Type_boolean) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.vx_new_boolean(!value.vx_boolean())
    return output
  }


  interface Func_notempty : vx_core.Func_any_from_any {
    fun vx_notempty(text : vx_core.Type_string) : vx_core.Type_boolean
  }

  class Class_notempty : vx_core.Class_base, Func_notempty {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_notempty = vx_core.Class_notempty()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_notempty = vx_core.Class_notempty()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_notempty
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_notempty
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_notempty(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_notempty(text)
      return output
    }

    override fun vx_notempty(text : vx_core.Type_string) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_notempty(text)
      return output
    }

  }

  val e_notempty : vx_core.Func_notempty = vx_core.Class_notempty()
  val t_notempty : vx_core.Func_notempty = vx_core.Class_notempty()

  fun f_notempty(text : vx_core.Type_string) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_is_empty(
        text
      )
    )
    return output
  }


  interface Func_notempty_1 : vx_core.Func_any_from_any {
    fun vx_notempty_1(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_notempty_1 : vx_core.Class_base, Func_notempty_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_notempty_1 = vx_core.Class_notempty_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_notempty_1 = vx_core.Class_notempty_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!-empty", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_notempty_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_notempty_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_notempty_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_notempty_1(value)
      return output
    }

    override fun vx_notempty_1(value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_notempty_1(value)
      return output
    }

  }

  val e_notempty_1 : vx_core.Func_notempty_1 = vx_core.Class_notempty_1()
  val t_notempty_1 : vx_core.Func_notempty_1 = vx_core.Class_notempty_1()

  fun f_notempty_1(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_is_empty_1(
        value
      )
    )
    return output
  }


  interface Func_ne : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_ne(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_ne : vx_core.Class_base, Func_ne {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_ne = vx_core.Class_ne()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_ne = vx_core.Class_ne()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!=", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_ne
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_ne
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_ne(val1, val2)
      return output
    }

    override fun vx_ne(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_ne(val1, val2)
      return output
    }

  }

  val e_ne : vx_core.Func_ne = vx_core.Class_ne()
  val t_ne : vx_core.Func_ne = vx_core.Class_ne()

  fun f_ne(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_eq(
        val1,
        val2
      )
    )
    return output
  }


  interface Func_neqeq : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_neqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_neqeq : vx_core.Class_base, Func_neqeq {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_neqeq = vx_core.Class_neqeq()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_neqeq = vx_core.Class_neqeq()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "!==", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_neqeq
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_neqeq
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_neqeq(val1, val2)
      return output
    }

    override fun vx_neqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_neqeq(val1, val2)
      return output
    }

  }

  val e_neqeq : vx_core.Func_neqeq = vx_core.Class_neqeq()
  val t_neqeq : vx_core.Func_neqeq = vx_core.Class_neqeq()

  fun f_neqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_eqeq(
        val1,
        val2
      )
    )
    return output
  }


  interface Func_multiply : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_multiply(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_multiply : vx_core.Class_base, Func_multiply {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply = vx_core.Class_multiply()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply = vx_core.Class_multiply()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_multiply
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_multiply
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_multiply(num1, num2)
      return output
    }

    override fun vx_multiply(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_multiply(num1, num2)
      return output
    }

  }

  val e_multiply : vx_core.Func_multiply = vx_core.Class_multiply()
  val t_multiply : vx_core.Func_multiply = vx_core.Class_multiply()

  fun f_multiply(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    val result : Int = num1.vx_int() * num2.vx_int()
    output = vx_core.vx_new_int(result)
    return output
  }


  interface Func_multiply_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_multiply_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number
  }

  class Class_multiply_1 : vx_core.Class_base, Func_multiply_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply_1 = vx_core.Class_multiply_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply_1 = vx_core.Class_multiply_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_multiply_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_multiply_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_multiply_1(num1, num2)
      return output
    }

    override fun vx_multiply_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.f_multiply_1(num1, num2)
      return output
    }

  }

  val e_multiply_1 : vx_core.Func_multiply_1 = vx_core.Class_multiply_1()
  val t_multiply_1 : vx_core.Func_multiply_1 = vx_core.Class_multiply_1()

  fun f_multiply_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    val result : Float = vx_core.vx_float_from_number(num1) * vx_core.vx_float_from_number(num2)
    output = vx_core.vx_new_float(result)
    return output
  }


  interface Func_multiply_2 : vx_core.Func_any_from_any {
    fun vx_multiply_2(nums : vx_core.Type_intlist) : vx_core.Type_int
  }

  class Class_multiply_2 : vx_core.Class_base, Func_multiply_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply_2 = vx_core.Class_multiply_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply_2 = vx_core.Class_multiply_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_multiply_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_multiply_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_intlist = value as vx_core.Type_intlist
      var outputval : vx_core.Type_any = vx_core.f_multiply_2(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_intlist = vx_core.f_any_from_any(vx_core.t_intlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_multiply_2(nums)
      return output
    }

    override fun vx_multiply_2(nums : vx_core.Type_intlist) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_multiply_2(nums)
      return output
    }

  }

  val e_multiply_2 : vx_core.Func_multiply_2 = vx_core.Class_multiply_2()
  val t_multiply_2 : vx_core.Func_multiply_2 = vx_core.Class_multiply_2()

  fun f_multiply_2(nums : vx_core.Type_intlist) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_int,
      nums,
      vx_core.vx_new_int(1),
      vx_core.t_any_from_reduce.vx_fn_new({total_any : vx_core.Type_any, num_any : vx_core.Type_any ->
        var total : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, total_any)
        var num : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, num_any)
        var output_1 : vx_core.Type_any = vx_core.f_multiply(
          total,
          num
        )
        output_1
      })
    )
    return output
  }


  interface Func_multiply_3 : vx_core.Func_any_from_any {
    fun vx_multiply_3(nums : vx_core.Type_numberlist) : vx_core.Type_number
  }

  class Class_multiply_3 : vx_core.Class_base, Func_multiply_3 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply_3 = vx_core.Class_multiply_3()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_multiply_3 = vx_core.Class_multiply_3()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "*", // name
        3, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_multiply_3
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_multiply_3
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_numberlist = value as vx_core.Type_numberlist
      var outputval : vx_core.Type_any = vx_core.f_multiply_3(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_numberlist = vx_core.f_any_from_any(vx_core.t_numberlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_multiply_3(nums)
      return output
    }

    override fun vx_multiply_3(nums : vx_core.Type_numberlist) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.f_multiply_3(nums)
      return output
    }

  }

  val e_multiply_3 : vx_core.Func_multiply_3 = vx_core.Class_multiply_3()
  val t_multiply_3 : vx_core.Func_multiply_3 = vx_core.Class_multiply_3()

  fun f_multiply_3(nums : vx_core.Type_numberlist) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_number,
      nums,
      vx_core.vx_new_int(1),
      vx_core.t_any_from_reduce.vx_fn_new({total_any : vx_core.Type_any, num_any : vx_core.Type_any ->
        var total : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, total_any)
        var num : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, num_any)
        var output_1 : vx_core.Type_any = vx_core.f_multiply_1(
          total,
          num
        )
        output_1
      })
    )
    return output
  }


  interface Func_plus : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_plus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_plus : vx_core.Class_base, Func_plus {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus = vx_core.Class_plus()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus = vx_core.Class_plus()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_plus(num1, num2)
      return output
    }

    override fun vx_plus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_plus(num1, num2)
      return output
    }

  }

  val e_plus : vx_core.Func_plus = vx_core.Class_plus()
  val t_plus : vx_core.Func_plus = vx_core.Class_plus()

  fun f_plus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    val result : Int = num1.vx_int() + num2.vx_int()
    output = vx_core.vx_new_int(result)
    return output
  }


  interface Func_plus_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_plus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number
  }

  class Class_plus_1 : vx_core.Class_base, Func_plus_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus_1 = vx_core.Class_plus_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus_1 = vx_core.Class_plus_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_plus_1(num1, num2)
      return output
    }

    override fun vx_plus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.f_plus_1(num1, num2)
      return output
    }

  }

  val e_plus_1 : vx_core.Func_plus_1 = vx_core.Class_plus_1()
  val t_plus_1 : vx_core.Func_plus_1 = vx_core.Class_plus_1()

  fun f_plus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    val result : Float = vx_core.vx_float_from_number(num1) + vx_core.vx_float_from_number(num2)
    output = vx_core.vx_new_float(result)
    return output
  }


  interface Func_plus_2 : vx_core.Func_any_from_any {
    fun vx_plus_2(nums : vx_core.Type_intlist) : vx_core.Type_int
  }

  class Class_plus_2 : vx_core.Class_base, Func_plus_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus_2 = vx_core.Class_plus_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus_2 = vx_core.Class_plus_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_intlist = value as vx_core.Type_intlist
      var outputval : vx_core.Type_any = vx_core.f_plus_2(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_intlist = vx_core.f_any_from_any(vx_core.t_intlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_plus_2(nums)
      return output
    }

    override fun vx_plus_2(nums : vx_core.Type_intlist) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_plus_2(nums)
      return output
    }

  }

  val e_plus_2 : vx_core.Func_plus_2 = vx_core.Class_plus_2()
  val t_plus_2 : vx_core.Func_plus_2 = vx_core.Class_plus_2()

  fun f_plus_2(nums : vx_core.Type_intlist) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_int,
      nums,
      vx_core.vx_new_int(0),
      vx_core.t_any_from_reduce.vx_fn_new({total_any : vx_core.Type_any, num_any : vx_core.Type_any ->
        var total : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, total_any)
        var num : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, num_any)
        var output_1 : vx_core.Type_any = vx_core.f_plus(
          total,
          num
        )
        output_1
      })
    )
    return output
  }


  interface Func_plus_3 : vx_core.Func_any_from_any {
    fun vx_plus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number
  }

  class Class_plus_3 : vx_core.Class_base, Func_plus_3 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus_3 = vx_core.Class_plus_3()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus_3 = vx_core.Class_plus_3()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+", // name
        3, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus_3
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus_3
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_numberlist = value as vx_core.Type_numberlist
      var outputval : vx_core.Type_any = vx_core.f_plus_3(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_numberlist = vx_core.f_any_from_any(vx_core.t_numberlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_plus_3(nums)
      return output
    }

    override fun vx_plus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.f_plus_3(nums)
      return output
    }

  }

  val e_plus_3 : vx_core.Func_plus_3 = vx_core.Class_plus_3()
  val t_plus_3 : vx_core.Func_plus_3 = vx_core.Class_plus_3()

  fun f_plus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_number,
      nums,
      vx_core.vx_new_int(0),
      vx_core.t_any_from_reduce.vx_fn_new({total_any : vx_core.Type_any, num_any : vx_core.Type_any ->
        var total : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, total_any)
        var num : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, num_any)
        var output_1 : vx_core.Type_any = vx_core.f_plus_1(
          total,
          num
        )
        output_1
      })
    )
    return output
  }


  interface Func_plus1 : vx_core.Func_any_from_any {
    fun vx_plus1(num : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_plus1 : vx_core.Class_base, Func_plus1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus1 = vx_core.Class_plus1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_plus1 = vx_core.Class_plus1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "+1", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_plus1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_plus1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_int = value as vx_core.Type_int
      var outputval : vx_core.Type_any = vx_core.f_plus1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_plus1(num)
      return output
    }

    override fun vx_plus1(num : vx_core.Type_int) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_plus1(num)
      return output
    }

  }

  val e_plus1 : vx_core.Func_plus1 = vx_core.Class_plus1()
  val t_plus1 : vx_core.Func_plus1 = vx_core.Class_plus1()

  fun f_plus1(num : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_plus(
      num,
      vx_core.vx_new_int(1)
    )
    return output
  }


  interface Func_minus : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_minus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_minus : vx_core.Class_base, Func_minus {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus = vx_core.Class_minus()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus = vx_core.Class_minus()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_minus(num1, num2)
      return output
    }

    override fun vx_minus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_minus(num1, num2)
      return output
    }

  }

  val e_minus : vx_core.Func_minus = vx_core.Class_minus()
  val t_minus : vx_core.Func_minus = vx_core.Class_minus()

  fun f_minus(num1 : vx_core.Type_int, num2 : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    val result : Int = num1.vx_int() - num2.vx_int()
    output = vx_core.vx_new_int(result)
    return output
  }


  interface Func_minus_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_minus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number
  }

  class Class_minus_1 : vx_core.Class_base, Func_minus_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus_1 = vx_core.Class_minus_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus_1 = vx_core.Class_minus_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_minus_1(num1, num2)
      return output
    }

    override fun vx_minus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.f_minus_1(num1, num2)
      return output
    }

  }

  val e_minus_1 : vx_core.Func_minus_1 = vx_core.Class_minus_1()
  val t_minus_1 : vx_core.Func_minus_1 = vx_core.Class_minus_1()

  fun f_minus_1(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    val result : Float = vx_core.vx_float_from_number(num1) - vx_core.vx_float_from_number(num2)
    output = vx_core.vx_new_float(result)
    return output
  }


  interface Func_minus_2 : vx_core.Func_any_from_any {
    fun vx_minus_2(nums : vx_core.Type_intlist) : vx_core.Type_int
  }

  class Class_minus_2 : vx_core.Class_base, Func_minus_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus_2 = vx_core.Class_minus_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus_2 = vx_core.Class_minus_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_intlist = value as vx_core.Type_intlist
      var outputval : vx_core.Type_any = vx_core.f_minus_2(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_intlist = vx_core.f_any_from_any(vx_core.t_intlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_minus_2(nums)
      return output
    }

    override fun vx_minus_2(nums : vx_core.Type_intlist) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_minus_2(nums)
      return output
    }

  }

  val e_minus_2 : vx_core.Func_minus_2 = vx_core.Class_minus_2()
  val t_minus_2 : vx_core.Func_minus_2 = vx_core.Class_minus_2()

  fun f_minus_2(nums : vx_core.Type_intlist) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_int,
      nums,
      vx_core.vx_new_int(0),
      vx_core.t_any_from_reduce.vx_fn_new({total_any : vx_core.Type_any, num_any : vx_core.Type_any ->
        var total : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, total_any)
        var num : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, num_any)
        var output_1 : vx_core.Type_any = vx_core.f_minus(
          total,
          num
        )
        output_1
      })
    )
    return output
  }


  interface Func_minus_3 : vx_core.Func_any_from_any {
    fun vx_minus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number
  }

  class Class_minus_3 : vx_core.Class_base, Func_minus_3 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus_3 = vx_core.Class_minus_3()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus_3 = vx_core.Class_minus_3()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-", // name
        3, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus_3
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus_3
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_numberlist = value as vx_core.Type_numberlist
      var outputval : vx_core.Type_any = vx_core.f_minus_3(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var nums : vx_core.Type_numberlist = vx_core.f_any_from_any(vx_core.t_numberlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_minus_3(nums)
      return output
    }

    override fun vx_minus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.f_minus_3(nums)
      return output
    }

  }

  val e_minus_3 : vx_core.Func_minus_3 = vx_core.Class_minus_3()
  val t_minus_3 : vx_core.Func_minus_3 = vx_core.Class_minus_3()

  fun f_minus_3(nums : vx_core.Type_numberlist) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    output = vx_core.f_any_from_list_start_reduce(
      vx_core.t_number,
      nums,
      vx_core.vx_new_int(0),
      vx_core.t_any_from_reduce.vx_fn_new({total_any : vx_core.Type_any, num_any : vx_core.Type_any ->
        var total : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, total_any)
        var num : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, num_any)
        var output_1 : vx_core.Type_any = vx_core.f_minus_1(
          total,
          num
        )
        output_1
      })
    )
    return output
  }


  interface Func_minus1 : vx_core.Func_any_from_any {
    fun vx_minus1(num : vx_core.Type_int) : vx_core.Type_int
  }

  class Class_minus1 : vx_core.Class_base, Func_minus1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus1 = vx_core.Class_minus1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_minus1 = vx_core.Class_minus1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "-1", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_minus1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_minus1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_int = value as vx_core.Type_int
      var outputval : vx_core.Type_any = vx_core.f_minus1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_minus1(num)
      return output
    }

    override fun vx_minus1(num : vx_core.Type_int) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_minus1(num)
      return output
    }

  }

  val e_minus1 : vx_core.Func_minus1 = vx_core.Class_minus1()
  val t_minus1 : vx_core.Func_minus1 = vx_core.Class_minus1()

  fun f_minus1(num : vx_core.Type_int) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_minus(
      num,
      vx_core.vx_new_int(1)
    )
    return output
  }


  interface Func_dotmethod : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_dotmethod(target : vx_core.Type_any, method : vx_core.Type_string, parameters : vx_core.Type_anylist) : vx_core.Type_any
  }

  class Class_dotmethod : vx_core.Class_base, Func_dotmethod {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_dotmethod = vx_core.Class_dotmethod()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_dotmethod = vx_core.Class_dotmethod()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ".", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_dotmethod
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_dotmethod
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var target : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var method : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var parameters : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_dotmethod(target, method, parameters)
      return output
    }

    override fun vx_dotmethod(target : vx_core.Type_any, method : vx_core.Type_string, parameters : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.f_dotmethod(target, method, parameters)
      return output
    }

  }

  val e_dotmethod : vx_core.Func_dotmethod = vx_core.Class_dotmethod()
  val t_dotmethod : vx_core.Func_dotmethod = vx_core.Class_dotmethod()

  fun f_dotmethod(target : vx_core.Type_any, method : vx_core.Type_string, parameters : vx_core.Type_anylist) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    return output
  }


  interface Func_divide : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_divide(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number
  }

  class Class_divide : vx_core.Class_base, Func_divide {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_divide = vx_core.Class_divide()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_divide = vx_core.Class_divide()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "/", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_divide
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_divide
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var num1 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(0)))
      var num2 : vx_core.Type_number = vx_core.f_any_from_any(vx_core.t_number, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_divide(num1, num2)
      return output
    }

    override fun vx_divide(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.f_divide(num1, num2)
      return output
    }

  }

  val e_divide : vx_core.Func_divide = vx_core.Class_divide()
  val t_divide : vx_core.Func_divide = vx_core.Class_divide()

  fun f_divide(num1 : vx_core.Type_number, num2 : vx_core.Type_number) : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    val float1 : Float = vx_core.vx_float_from_number(num1)
    val float2 : Float = vx_core.vx_float_from_number(num2)
    if (float1 == 0f) {
    } else if (float2 == 0f) {
      output = vx_core.c_notanumber
    } else {
      val result : Float = float1 / float2
      output = vx_core.vx_new_float(result)
    }
    return output
  }


  interface Func_lt : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_lt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_lt : vx_core.Class_base, Func_lt {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_lt = vx_core.Class_lt()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_lt = vx_core.Class_lt()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_lt
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_lt
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_lt(val1, val2)
      return output
    }

    override fun vx_lt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_lt(val1, val2)
      return output
    }

  }

  val e_lt : vx_core.Func_lt = vx_core.Class_lt()
  val t_lt : vx_core.Func_lt = vx_core.Class_lt()

  fun f_lt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_switch(
      vx_core.t_boolean,
      vx_core.f_compare(
        val1,
        val2
      ),
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case_1(
          vx_core.vx_new_int(-1),
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_1 : vx_core.Type_any = vx_core.vx_new_boolean(true)
            output_1
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_2 : vx_core.Type_any = vx_core.vx_new_boolean(false)
            output_2
          })
        )
      )
    )
    return output
  }


  interface Func_lt_1 : vx_core.Func_any_from_any {
    fun vx_lt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_lt_1 : vx_core.Class_base, Func_lt_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_lt_1 = vx_core.Class_lt_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_lt_1 = vx_core.Class_lt_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_lt_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_lt_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_lt_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_lt_1(values)
      return output
    }

    override fun vx_lt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_lt_1(values)
      return output
    }

  }

  val e_lt_1 : vx_core.Func_lt_1 = vx_core.Class_lt_1()
  val t_lt_1 : vx_core.Func_lt_1 = vx_core.Class_lt_1()

  fun f_lt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_any_from_list_start_reduce_next(
      vx_core.t_boolean,
      values,
      vx_core.vx_new_boolean(true),
      vx_core.t_any_from_reduce_next.vx_fn_new({reduce_any : vx_core.Type_any, current_any : vx_core.Type_any, next_any : vx_core.Type_any ->
        var reduce : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
        var current : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, current_any)
        var next : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, next_any)
        var output_1 : vx_core.Type_any = vx_core.f_and(
          reduce,
          vx_core.f_lt(
            current,
            next
          )
        )
        output_1
      })
    )
    return output
  }


  interface Func_chainfirst : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_chainfirst(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T
  }

  class Class_chainfirst : vx_core.Class_base, Func_chainfirst {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_chainfirst = vx_core.Class_chainfirst()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_chainfirst = vx_core.Class_chainfirst()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<-", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_chainfirst
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_chainfirst
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fnlist : vx_core.Type_any_from_anylist = vx_core.f_any_from_any(vx_core.t_any_from_anylist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_chainfirst(generic_any_1, value, fnlist)
      return output
    }

    override fun <T : vx_core.Type_any> vx_chainfirst(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T {
      var output : T = vx_core.f_chainfirst(generic_any_1, value, fnlist)
      return output
    }

  }

  val e_chainfirst : vx_core.Func_chainfirst = vx_core.Class_chainfirst()
  val t_chainfirst : vx_core.Func_chainfirst = vx_core.Class_chainfirst()

  fun <T : vx_core.Type_any> f_chainfirst(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_chainlast : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_chainlast(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T
  }

  class Class_chainlast : vx_core.Class_base, Func_chainlast {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_chainlast = vx_core.Class_chainlast()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_chainlast = vx_core.Class_chainlast()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<<-", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_chainlast
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_chainlast
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fnlist : vx_core.Type_any_from_anylist = vx_core.f_any_from_any(vx_core.t_any_from_anylist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_chainlast(generic_any_1, value, fnlist)
      return output
    }

    override fun <T : vx_core.Type_any> vx_chainlast(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T {
      var output : T = vx_core.f_chainlast(generic_any_1, value, fnlist)
      return output
    }

  }

  val e_chainlast : vx_core.Func_chainlast = vx_core.Class_chainlast()
  val t_chainlast : vx_core.Func_chainlast = vx_core.Class_chainlast()

  fun <T : vx_core.Type_any> f_chainlast(generic_any_1 : T, value : T, fnlist : vx_core.Type_any_from_anylist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_le : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_le(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_le : vx_core.Class_base, Func_le {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_le = vx_core.Class_le()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_le = vx_core.Class_le()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_le
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_le
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_le(val1, val2)
      return output
    }

    override fun vx_le(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_le(val1, val2)
      return output
    }

  }

  val e_le : vx_core.Func_le = vx_core.Class_le()
  val t_le : vx_core.Func_le = vx_core.Class_le()

  fun f_le(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_gt(
        val1,
        val2
      )
    )
    return output
  }


  interface Func_le_1 : vx_core.Func_any_from_any {
    fun vx_le_1(args : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_le_1 : vx_core.Class_base, Func_le_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_le_1 = vx_core.Class_le_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_le_1 = vx_core.Class_le_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "<=", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_le_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_le_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_le_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var args : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_le_1(args)
      return output
    }

    override fun vx_le_1(args : vx_core.Type_anylist) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_le_1(args)
      return output
    }

  }

  val e_le_1 : vx_core.Func_le_1 = vx_core.Class_le_1()
  val t_le_1 : vx_core.Func_le_1 = vx_core.Class_le_1()

  fun f_le_1(args : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_gt_1(
        args
      )
    )
    return output
  }


  interface Func_eq : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_eq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_eq : vx_core.Class_base, Func_eq {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_eq = vx_core.Class_eq()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_eq = vx_core.Class_eq()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "=", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_eq
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_eq
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_eq(val1, val2)
      return output
    }

    override fun vx_eq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_eq(val1, val2)
      return output
    }

  }

  val e_eq : vx_core.Func_eq = vx_core.Class_eq()
  val t_eq : vx_core.Func_eq = vx_core.Class_eq()

  fun f_eq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    var isequal : Boolean = false
    if (val1 == val2) {
      isequal = true
    } else {
      val strval1 : vx_core.Type_string = vx_core.f_string_from_any(val1)
      val strval2 : vx_core.Type_string = vx_core.f_string_from_any(val2)
      if (strval1.vx_string().equals(strval2.vx_string())) {
        isequal = true
      }
    }
    output = vx_core.vx_new_boolean(isequal)
    return output
  }


  interface Func_eq_1 : vx_core.Func_any_from_any {
    fun vx_eq_1(values : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_eq_1 : vx_core.Class_base, Func_eq_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_eq_1 = vx_core.Class_eq_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_eq_1 = vx_core.Class_eq_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "=", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_eq_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_eq_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_eq_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_eq_1(values)
      return output
    }

    override fun vx_eq_1(values : vx_core.Type_anylist) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_eq_1(values)
      return output
    }

  }

  val e_eq_1 : vx_core.Func_eq_1 = vx_core.Class_eq_1()
  val t_eq_1 : vx_core.Func_eq_1 = vx_core.Class_eq_1()

  fun f_eq_1(values : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_any_from_list_start_reduce_next(
      vx_core.t_boolean,
      values,
      vx_core.vx_new_boolean(false),
      vx_core.t_any_from_reduce_next.vx_fn_new({reduce_any : vx_core.Type_any, current_any : vx_core.Type_any, next_any : vx_core.Type_any ->
        var reduce : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
        var current : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, current_any)
        var next : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, next_any)
        var output_1 : vx_core.Type_any = vx_core.f_and(
          reduce,
          vx_core.f_eq(
            current,
            next
          )
        )
        output_1
      })
    )
    return output
  }


  interface Func_eqeq : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_eqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_eqeq : vx_core.Class_base, Func_eqeq {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_eqeq = vx_core.Class_eqeq()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_eqeq = vx_core.Class_eqeq()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "==", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_eqeq
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_eqeq
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_eqeq(val1, val2)
      return output
    }

    override fun vx_eqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_eqeq(val1, val2)
      return output
    }

  }

  val e_eqeq : vx_core.Func_eqeq = vx_core.Class_eqeq()
  val t_eqeq : vx_core.Func_eqeq = vx_core.Class_eqeq()

  fun f_eqeq(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val isequal : Boolean = vx_core.vx_eqeq(val1, val2)
    output = vx_core.vx_new_boolean(isequal)
    return output
  }


  interface Func_gt : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_gt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_gt : vx_core.Class_base, Func_gt {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_gt = vx_core.Class_gt()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_gt = vx_core.Class_gt()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ">", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_gt
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_gt
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_gt(val1, val2)
      return output
    }

    override fun vx_gt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_gt(val1, val2)
      return output
    }

  }

  val e_gt : vx_core.Func_gt = vx_core.Class_gt()
  val t_gt : vx_core.Func_gt = vx_core.Class_gt()

  fun f_gt(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_switch(
      vx_core.t_boolean,
      vx_core.f_compare(
        val1,
        val2
      ),
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case_1(
          vx_core.vx_new_int(1),
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_1 : vx_core.Type_any = vx_core.vx_new_boolean(true)
            output_1
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_2 : vx_core.Type_any = vx_core.vx_new_boolean(false)
            output_2
          })
        )
      )
    )
    return output
  }


  interface Func_gt_1 : vx_core.Func_any_from_any {
    fun vx_gt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_gt_1 : vx_core.Class_base, Func_gt_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_gt_1 = vx_core.Class_gt_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_gt_1 = vx_core.Class_gt_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ">", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_gt_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_gt_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_gt_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_gt_1(values)
      return output
    }

    override fun vx_gt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_gt_1(values)
      return output
    }

  }

  val e_gt_1 : vx_core.Func_gt_1 = vx_core.Class_gt_1()
  val t_gt_1 : vx_core.Func_gt_1 = vx_core.Class_gt_1()

  fun f_gt_1(values : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_any_from_list_start_reduce_next(
      vx_core.t_boolean,
      values,
      vx_core.vx_new_boolean(true),
      vx_core.t_any_from_reduce_next.vx_fn_new({reduce_any : vx_core.Type_any, current_any : vx_core.Type_any, next_any : vx_core.Type_any ->
        var reduce : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
        var current : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, current_any)
        var next : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, next_any)
        var output_1 : vx_core.Type_any = vx_core.f_and(
          reduce,
          vx_core.f_gt(
            current,
            next
          )
        )
        output_1
      })
    )
    return output
  }


  interface Func_ge : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_ge(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_ge : vx_core.Class_base, Func_ge {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_ge = vx_core.Class_ge()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_ge = vx_core.Class_ge()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_ge
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_ge
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_ge(val1, val2)
      return output
    }

    override fun vx_ge(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_ge(val1, val2)
      return output
    }

  }

  val e_ge : vx_core.Func_ge = vx_core.Class_ge()
  val t_ge : vx_core.Func_ge = vx_core.Class_ge()

  fun f_ge(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_lt(
        val1,
        val2
      )
    )
    return output
  }


  interface Func_ge_1 : vx_core.Func_any_from_any {
    fun vx_ge_1(args : vx_core.Type_anylist) : vx_core.Type_boolean
  }

  class Class_ge_1 : vx_core.Class_base, Func_ge_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_ge_1 = vx_core.Class_ge_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_ge_1 = vx_core.Class_ge_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        ">=", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_ge_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_ge_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_ge_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var args : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_ge_1(args)
      return output
    }

    override fun vx_ge_1(args : vx_core.Type_anylist) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_ge_1(args)
      return output
    }

  }

  val e_ge_1 : vx_core.Func_ge_1 = vx_core.Class_ge_1()
  val t_ge_1 : vx_core.Func_ge_1 = vx_core.Class_ge_1()

  fun f_ge_1(args : vx_core.Type_anylist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_not(
      vx_core.f_lt_1(
        args
      )
    )
    return output
  }


  interface Func_allowfuncs_from_security : vx_core.Func_any_from_any {
    fun vx_allowfuncs_from_security(security : vx_core.Type_security) : vx_core.Type_funclist
  }

  class Class_allowfuncs_from_security : vx_core.Class_base, Func_allowfuncs_from_security {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_allowfuncs_from_security = vx_core.Class_allowfuncs_from_security()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_allowfuncs_from_security = vx_core.Class_allowfuncs_from_security()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "allowfuncs<-security", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "funclist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_func), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_allowfuncs_from_security
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_allowfuncs_from_security
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_security = value as vx_core.Type_security
      var outputval : vx_core.Type_any = vx_core.f_allowfuncs_from_security(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var security : vx_core.Type_security = vx_core.f_any_from_any(vx_core.t_security, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_allowfuncs_from_security(security)
      return output
    }

    override fun vx_allowfuncs_from_security(security : vx_core.Type_security) : vx_core.Type_funclist {
      var output : vx_core.Type_funclist = vx_core.f_allowfuncs_from_security(security)
      return output
    }

  }

  val e_allowfuncs_from_security : vx_core.Func_allowfuncs_from_security = vx_core.Class_allowfuncs_from_security()
  val t_allowfuncs_from_security : vx_core.Func_allowfuncs_from_security = vx_core.Class_allowfuncs_from_security()

  fun f_allowfuncs_from_security(security : vx_core.Type_security) : vx_core.Type_funclist {
    var output : vx_core.Type_funclist = vx_core.e_funclist
    output = security.allowfuncs()
    return output
  }


  interface Func_allowtypenames_from_typedef : vx_core.Func_any_from_any {
    fun vx_allowtypenames_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_stringlist
  }

  class Class_allowtypenames_from_typedef : vx_core.Class_base, Func_allowtypenames_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_allowtypenames_from_typedef = vx_core.Class_allowtypenames_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_allowtypenames_from_typedef = vx_core.Class_allowtypenames_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "allowtypenames<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_allowtypenames_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_allowtypenames_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_allowtypenames_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_allowtypenames_from_typedef(vtypedef)
      return output
    }

    override fun vx_allowtypenames_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_stringlist {
      var output : vx_core.Type_stringlist = vx_core.f_allowtypenames_from_typedef(vtypedef)
      return output
    }

  }

  val e_allowtypenames_from_typedef : vx_core.Func_allowtypenames_from_typedef = vx_core.Class_allowtypenames_from_typedef()
  val t_allowtypenames_from_typedef : vx_core.Func_allowtypenames_from_typedef = vx_core.Class_allowtypenames_from_typedef()

  fun f_allowtypenames_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_stringlist {
    var output : vx_core.Type_stringlist = vx_core.e_stringlist
    output = vx_core.f_typenames_from_typelist(
      vx_core.f_allowtypes_from_typedef(
        vtypedef
      )
    )
    return output
  }


  interface Func_allowtypes_from_typedef : vx_core.Func_any_from_any {
    fun vx_allowtypes_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist
  }

  class Class_allowtypes_from_typedef : vx_core.Class_base, Func_allowtypes_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_allowtypes_from_typedef = vx_core.Class_allowtypes_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_allowtypes_from_typedef = vx_core.Class_allowtypes_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "allowtypes<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "typelist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_allowtypes_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_allowtypes_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_allowtypes_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_allowtypes_from_typedef(vtypedef)
      return output
    }

    override fun vx_allowtypes_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist {
      var output : vx_core.Type_typelist = vx_core.f_allowtypes_from_typedef(vtypedef)
      return output
    }

  }

  val e_allowtypes_from_typedef : vx_core.Func_allowtypes_from_typedef = vx_core.Class_allowtypes_from_typedef()
  val t_allowtypes_from_typedef : vx_core.Func_allowtypes_from_typedef = vx_core.Class_allowtypes_from_typedef()

  fun f_allowtypes_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist {
    var output : vx_core.Type_typelist = vx_core.e_typelist
    output = vtypedef.allowtypes()
    return output
  }


  interface Func_and : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_and(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean
  }

  class Class_and : vx_core.Class_base, Func_and {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_and = vx_core.Class_and()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_and = vx_core.Class_and()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "and", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_and
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_and
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_and(val1, val2)
      return output
    }

    override fun vx_and(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_and(val1, val2)
      return output
    }

  }

  val e_and : vx_core.Func_and = vx_core.Class_and()
  val t_and : vx_core.Func_and = vx_core.Class_and()

  fun f_and(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    if (val1.vx_boolean() && val2.vx_boolean()) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }
    return output
  }


  interface Func_and_1 : vx_core.Func_any_from_any {
    fun vx_and_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean
  }

  class Class_and_1 : vx_core.Class_base, Func_and_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_and_1 = vx_core.Class_and_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_and_1 = vx_core.Class_and_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "and", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_and_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_and_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_booleanlist = value as vx_core.Type_booleanlist
      var outputval : vx_core.Type_any = vx_core.f_and_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_booleanlist = vx_core.f_any_from_any(vx_core.t_booleanlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_and_1(values)
      return output
    }

    override fun vx_and_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_and_1(values)
      return output
    }

  }

  val e_and_1 : vx_core.Func_and_1 = vx_core.Class_and_1()
  val t_and_1 : vx_core.Func_and_1 = vx_core.Class_and_1()

  fun f_and_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_switch(
      vx_core.t_boolean,
      vx_core.f_length_1(
        values
      ),
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case_1(
          vx_core.vx_new_int(0),
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_1 : vx_core.Type_any = vx_core.vx_new_boolean(true)
            output_1
          })
        ),
        vx_core.f_case_1(
          vx_core.vx_new_int(1),
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_2 : vx_core.Type_any = vx_core.f_any_from_list(
              vx_core.t_boolean,
              values,
              vx_core.vx_new_int(1)
            )
            output_2
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_3 : vx_core.Type_any = vx_core.f_any_from_list_start_reduce_next(
              vx_core.t_boolean,
              values,
              vx_core.vx_new_boolean(true),
              vx_core.t_any_from_reduce_next.vx_fn_new({reduce_any : vx_core.Type_any, current_any : vx_core.Type_any, next_any : vx_core.Type_any ->
                var reduce : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
                var current : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, current_any)
                var next : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, next_any)
                var output_4 : vx_core.Type_any = vx_core.f_and(
                  reduce,
                  vx_core.f_and(
                    current,
                    next
                  )
                )
                output_4
              })
            )
            output_3
          })
        )
      )
    )
    return output
  }


  interface Func_any_from_any : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T
    fun vx_fn_new(fn : Class_any_from_any.IFn) : vx_core.Func_any_from_any
  }

  class Class_any_from_any : vx_core.Class_base, Func_any_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any = vx_core.Class_any_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any = vx_core.Class_any_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any
      return output
    }

    fun interface IFn {
      fun resolve(value : vx_core.Type_any) : vx_core.Type_any
    }

    var fn : Class_any_from_any.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      val output : vx_core.Class_any_from_any = vx_core.Class_any_from_any()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_any(generic_any_1, value)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_any.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve(value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_any : vx_core.Func_any_from_any = vx_core.Class_any_from_any()
  val t_any_from_any : vx_core.Func_any_from_any = vx_core.Class_any_from_any()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any(generic_any_1 : T, value : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    @Suppress("UNCHECKED_CAST")
    output = value as T
    return output
  }


  interface Func_any_from_any_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_async(generic_any_1 : T, value : U) : CompletableFuture<T>
    fun vx_fn_new(fn : Class_any_from_any_async.IFn) : vx_core.Func_any_from_any_async
  }

  class Class_any_from_any_async : vx_core.Class_base, Func_any_from_any_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_async = vx_core.Class_any_from_any_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_async = vx_core.Class_any_from_any_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any_async
      return output
    }

    fun interface IFn {
      fun resolve(value : vx_core.Type_any) : CompletableFuture<vx_core.Type_any>
    }

    var fn : Class_any_from_any_async.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_any_async.IFn) : vx_core.Func_any_from_any_async {
      val output : vx_core.Class_any_from_any_async = vx_core.Class_any_from_any_async()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_any_from_any_async(generic_any_1, value)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_async(generic_any_1 : T, value : U) : CompletableFuture<T> {
      var output : CompletableFuture<T>
      var fnlocal : Class_any_from_any_async.IFn? = this.fn
      if (fnlocal == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : CompletableFuture<vx_core.Type_any> = fnlocal.resolve(value)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_any_async : vx_core.Func_any_from_any_async = vx_core.Class_any_from_any_async()
  val t_any_from_any_async : vx_core.Func_any_from_any_async = vx_core.Class_any_from_any_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any_async(generic_any_1 : T, value : U) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_any_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T
    fun vx_fn_new(fn : Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context
  }

  class Class_any_from_any_context : vx_core.Class_base, Func_any_from_any_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_context = vx_core.Class_any_from_any_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_context = vx_core.Class_any_from_any_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any_context
      return output
    }

    fun interface IFn {
      fun resolve(context : vx_core.Type_context, value : vx_core.Type_any) : vx_core.Type_any
    }

    var fn : Class_any_from_any_context.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      val output : vx_core.Class_any_from_any_context = vx_core.Class_any_from_any_context()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_any_context(generic_any_1, context, value)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_any_context.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve(context, value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_any_context : vx_core.Func_any_from_any_context = vx_core.Class_any_from_any_context()
  val t_any_from_any_context : vx_core.Func_any_from_any_context = vx_core.Class_any_from_any_context()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    @Suppress("UNCHECKED_CAST")
    output = (value as T)
    return output
  }


  interface Func_any_from_any_context_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context_async(generic_any_1 : T, context : vx_core.Type_context, value : U) : CompletableFuture<T>
    fun vx_fn_new(fn : Class_any_from_any_context_async.IFn) : vx_core.Func_any_from_any_context_async
  }

  class Class_any_from_any_context_async : vx_core.Class_base, Func_any_from_any_context_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_context_async = vx_core.Class_any_from_any_context_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_context_async = vx_core.Class_any_from_any_context_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-context-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any_context_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any_context_async
      return output
    }

    fun interface IFn {
      fun resolve(context : vx_core.Type_context, value : vx_core.Type_any) : CompletableFuture<vx_core.Type_any>
    }

    var fn : Class_any_from_any_context_async.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_any_context_async.IFn) : vx_core.Func_any_from_any_context_async {
      val output : vx_core.Class_any_from_any_context_async = vx_core.Class_any_from_any_context_async()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_any_from_any_context_async(generic_any_1, context, value)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context_async(generic_any_1 : T, context : vx_core.Type_context, value : U) : CompletableFuture<T> {
      var output : CompletableFuture<T>
      var fnlocal : Class_any_from_any_context_async.IFn? = this.fn
      if (fnlocal == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : CompletableFuture<vx_core.Type_any> = fnlocal.resolve(context, value)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_any_context_async : vx_core.Func_any_from_any_context_async = vx_core.Class_any_from_any_context_async()
  val t_any_from_any_context_async : vx_core.Func_any_from_any_context_async = vx_core.Class_any_from_any_context_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any_context_async(generic_any_1 : T, context : vx_core.Type_context, value : U) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_any_key_value : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_key_value(generic_any_1 : T, current : T, key : vx_core.Type_string, value : U) : T
    fun vx_fn_new(fn : Class_any_from_any_key_value.IFn) : vx_core.Func_any_from_any_key_value
  }

  class Class_any_from_any_key_value : vx_core.Class_base, Func_any_from_any_key_value {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_key_value = vx_core.Class_any_from_any_key_value()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_any_key_value = vx_core.Class_any_from_any_key_value()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-any-key-value", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_any_key_value
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_any_key_value
      return output
    }

    fun interface IFn {
      fun resolve(current : vx_core.Type_any, key : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_any
    }

    var fn : Class_any_from_any_key_value.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_any_key_value.IFn) : vx_core.Func_any_from_any_key_value {
      val output : vx_core.Class_any_from_any_key_value = vx_core.Class_any_from_any_key_value()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var current : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_any_key_value(generic_any_1, current, key, value)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_key_value(generic_any_1 : T, current : T, key : vx_core.Type_string, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_any_key_value.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve(current, key, value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_any_key_value : vx_core.Func_any_from_any_key_value = vx_core.Class_any_from_any_key_value()
  val t_any_from_any_key_value : vx_core.Func_any_from_any_key_value = vx_core.Class_any_from_any_key_value()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_any_key_value(generic_any_1 : T, current : T, key : vx_core.Type_string, value : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_any_from_func(generic_any_1 : T) : T
    fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_any_from_func
  }

  class Class_any_from_func : vx_core.Class_base, Func_any_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_func = vx_core.Class_any_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_func = vx_core.Class_any_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_func
      return output
    }

    fun interface IFn {
      fun resolve() : vx_core.Type_any
    }

    var fn : Class_any_from_func.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_any_from_func {
      val output : vx_core.Class_any_from_func = vx_core.Class_any_from_func()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_func(generic_any_1)
      return output
    }

    override fun <T : vx_core.Type_any> vx_any_from_func(generic_any_1 : T) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_func.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve()
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_func : vx_core.Func_any_from_func = vx_core.Class_any_from_func()
  val t_any_from_func : vx_core.Func_any_from_func = vx_core.Class_any_from_func()

  fun <T : vx_core.Type_any> f_any_from_func(generic_any_1 : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_func_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any> vx_any_from_func_async(generic_any_1 : T) : CompletableFuture<T>
    fun vx_fn_new(fn : Class_any_from_func_async.IFn) : vx_core.Func_any_from_func_async
  }

  class Class_any_from_func_async : vx_core.Class_base, Func_any_from_func_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_func_async = vx_core.Class_any_from_func_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_func_async = vx_core.Class_any_from_func_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-func-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_func_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_func_async
      return output
    }

    fun interface IFn {
      fun resolve() : CompletableFuture<vx_core.Type_any>
    }

    var fn : Class_any_from_func_async.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_func_async.IFn) : vx_core.Func_any_from_func_async {
      val output : vx_core.Class_any_from_func_async = vx_core.Class_any_from_func_async()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_any_from_func_async(generic_any_1)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any> vx_any_from_func_async(generic_any_1 : T) : CompletableFuture<T> {
      var output : CompletableFuture<T>
      var fnlocal : Class_any_from_func_async.IFn? = this.fn
      if (fnlocal == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : CompletableFuture<vx_core.Type_any> = fnlocal.resolve()
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_func_async : vx_core.Func_any_from_func_async = vx_core.Class_any_from_func_async()
  val t_any_from_func_async : vx_core.Func_any_from_func_async = vx_core.Class_any_from_func_async()

  fun <T : vx_core.Type_any> f_any_from_func_async(generic_any_1 : T) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_int : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_any_from_int(generic_any_1 : T, value : vx_core.Type_int) : T
    fun vx_fn_new(fn : Class_any_from_int.IFn) : vx_core.Func_any_from_int
  }

  class Class_any_from_int : vx_core.Class_base, Func_any_from_int {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_int = vx_core.Class_any_from_int()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_int = vx_core.Class_any_from_int()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-int", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_int
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_int
      return output
    }

    fun interface IFn {
      fun resolve(value : vx_core.Type_int) : vx_core.Type_any
    }

    var fn : Class_any_from_int.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_int.IFn) : vx_core.Func_any_from_int {
      val output : vx_core.Class_any_from_int = vx_core.Class_any_from_int()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_int(generic_any_1, value)
      return output
    }

    override fun <T : vx_core.Type_any> vx_any_from_int(generic_any_1 : T, value : vx_core.Type_int) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_int.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve(value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_int : vx_core.Func_any_from_int = vx_core.Class_any_from_int()
  val t_any_from_int : vx_core.Func_any_from_int = vx_core.Class_any_from_int()

  fun <T : vx_core.Type_any> f_any_from_int(generic_any_1 : T, value : vx_core.Type_int) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_int_any : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_int_any(generic_any_1 : T, num : vx_core.Type_int, value : U) : T
    fun vx_fn_new(fn : Class_any_from_int_any.IFn) : vx_core.Func_any_from_int_any
  }

  class Class_any_from_int_any : vx_core.Class_base, Func_any_from_int_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_int_any = vx_core.Class_any_from_int_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_int_any = vx_core.Class_any_from_int_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-int-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_int_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_int_any
      return output
    }

    fun interface IFn {
      fun resolve(num : vx_core.Type_int, value : vx_core.Type_any) : vx_core.Type_any
    }

    var fn : Class_any_from_int_any.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_int_any.IFn) : vx_core.Func_any_from_int_any {
      val output : vx_core.Class_any_from_int_any = vx_core.Class_any_from_int_any()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var num : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_int_any(generic_any_1, num, value)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_int_any(generic_any_1 : T, num : vx_core.Type_int, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_int_any.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve(num, value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_int_any : vx_core.Func_any_from_int_any = vx_core.Class_any_from_int_any()
  val t_any_from_int_any : vx_core.Func_any_from_int_any = vx_core.Class_any_from_int_any()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_int_any(generic_any_1 : T, num : vx_core.Type_int, value : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_key_value : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_key_value(generic_any_1 : T, key : vx_core.Type_string, value : U) : T
    fun vx_fn_new(fn : Class_any_from_key_value.IFn) : vx_core.Func_any_from_key_value
  }

  class Class_any_from_key_value : vx_core.Class_base, Func_any_from_key_value {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_key_value = vx_core.Class_any_from_key_value()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_key_value = vx_core.Class_any_from_key_value()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-key-value", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_key_value
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_key_value
      return output
    }

    fun interface IFn {
      fun resolve(key : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_any
    }

    var fn : Class_any_from_key_value.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_key_value.IFn) : vx_core.Func_any_from_key_value {
      val output : vx_core.Class_any_from_key_value = vx_core.Class_any_from_key_value()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_key_value(generic_any_1, key, value)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_key_value(generic_any_1 : T, key : vx_core.Type_string, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_key_value.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve(key, value)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_key_value : vx_core.Func_any_from_key_value = vx_core.Class_any_from_key_value()
  val t_any_from_key_value : vx_core.Func_any_from_key_value = vx_core.Class_any_from_key_value()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_key_value(generic_any_1 : T, key : vx_core.Type_string, value : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_key_value_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_key_value_async(generic_any_1 : T, key : vx_core.Type_string, value : U) : CompletableFuture<T>
    fun vx_fn_new(fn : Class_any_from_key_value_async.IFn) : vx_core.Func_any_from_key_value_async
  }

  class Class_any_from_key_value_async : vx_core.Class_base, Func_any_from_key_value_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_key_value_async = vx_core.Class_any_from_key_value_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_key_value_async = vx_core.Class_any_from_key_value_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-key-value-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_key_value_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_key_value_async
      return output
    }

    fun interface IFn {
      fun resolve(key : vx_core.Type_string, value : vx_core.Type_any) : CompletableFuture<vx_core.Type_any>
    }

    var fn : Class_any_from_key_value_async.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_key_value_async.IFn) : vx_core.Func_any_from_key_value_async {
      val output : vx_core.Class_any_from_key_value_async = vx_core.Class_any_from_key_value_async()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_any_from_key_value_async(generic_any_1, key, value)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_key_value_async(generic_any_1 : T, key : vx_core.Type_string, value : U) : CompletableFuture<T> {
      var output : CompletableFuture<T>
      var fnlocal : Class_any_from_key_value_async.IFn? = this.fn
      if (fnlocal == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : CompletableFuture<vx_core.Type_any> = fnlocal.resolve(key, value)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_key_value_async : vx_core.Func_any_from_key_value_async = vx_core.Class_any_from_key_value_async()
  val t_any_from_key_value_async : vx_core.Func_any_from_key_value_async = vx_core.Class_any_from_key_value_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_key_value_async(generic_any_1 : T, key : vx_core.Type_string, value : U) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_list : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_any_from_list(generic_any_1 : T, values : X, index : vx_core.Type_int) : T
  }

  class Class_any_from_list : vx_core.Class_base, Func_any_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_list = vx_core.Class_any_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_list = vx_core.Class_any_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_list
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var index : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_list(generic_any_1, values, index)
      return output
    }

    override fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_any_from_list(generic_any_1 : T, values : X, index : vx_core.Type_int) : T {
      var output : T = vx_core.f_any_from_list(generic_any_1, values, index)
      return output
    }

  }

  val e_any_from_list : vx_core.Func_any_from_list = vx_core.Class_any_from_list()
  val t_any_from_list : vx_core.Func_any_from_list = vx_core.Class_any_from_list()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_any_from_list(generic_any_1 : T, values : X, index : vx_core.Type_int) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    val intindex : Int = index.vx_int()
    val intsize : Int = values.vx_list().size
    if (intindex <= intsize) {
      val listvalue : List<vx_core.Type_any> = values.vx_list()
      val value : vx_core.Type_any = listvalue.get(intindex - 1)
      output = vx_core.f_any_from_any(generic_any_1, value)
    }
    return output
  }


  interface Func_any_from_list_start_reduce : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, Y : vx_core.Type_list> vx_any_from_list_start_reduce(generic_any_1 : T, list : Y, valstart : T, fn_reduce : vx_core.Func_any_from_reduce) : T
  }

  class Class_any_from_list_start_reduce : vx_core.Class_base, Func_any_from_list_start_reduce {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_list_start_reduce = vx_core.Class_any_from_list_start_reduce()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_list_start_reduce = vx_core.Class_any_from_list_start_reduce()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_list_start_reduce
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_list_start_reduce
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var list : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valstart : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var fn_reduce : vx_core.Func_any_from_reduce = vx_core.f_any_from_any(vx_core.t_any_from_reduce, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce)
      return output
    }

    override fun <T : vx_core.Type_any, Y : vx_core.Type_list> vx_any_from_list_start_reduce(generic_any_1 : T, list : Y, valstart : T, fn_reduce : vx_core.Func_any_from_reduce) : T {
      var output : T = vx_core.f_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce)
      return output
    }

  }

  val e_any_from_list_start_reduce : vx_core.Func_any_from_list_start_reduce = vx_core.Class_any_from_list_start_reduce()
  val t_any_from_list_start_reduce : vx_core.Func_any_from_list_start_reduce = vx_core.Class_any_from_list_start_reduce()

  fun <T : vx_core.Type_any, Y : vx_core.Type_list> f_any_from_list_start_reduce(generic_any_1 : T, list : Y, valstart : T, fn_reduce : vx_core.Func_any_from_reduce) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_any_from_list_start_reduce(generic_any_1, list, valstart, fn_reduce)
    return output
  }


  interface Func_any_from_list_start_reduce_next : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, Y : vx_core.Type_list> vx_any_from_list_start_reduce_next(generic_any_1 : T, list : Y, valstart : T, fn_reduce_next : vx_core.Func_any_from_reduce_next) : T
  }

  class Class_any_from_list_start_reduce_next : vx_core.Class_base, Func_any_from_list_start_reduce_next {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_list_start_reduce_next = vx_core.Class_any_from_list_start_reduce_next()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_list_start_reduce_next = vx_core.Class_any_from_list_start_reduce_next()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-list-start-reduce-next", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_list_start_reduce_next
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_list_start_reduce_next
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var list : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valstart : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var fn_reduce_next : vx_core.Func_any_from_reduce_next = vx_core.f_any_from_any(vx_core.t_any_from_reduce_next, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next)
      return output
    }

    override fun <T : vx_core.Type_any, Y : vx_core.Type_list> vx_any_from_list_start_reduce_next(generic_any_1 : T, list : Y, valstart : T, fn_reduce_next : vx_core.Func_any_from_reduce_next) : T {
      var output : T = vx_core.f_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next)
      return output
    }

  }

  val e_any_from_list_start_reduce_next : vx_core.Func_any_from_list_start_reduce_next = vx_core.Class_any_from_list_start_reduce_next()
  val t_any_from_list_start_reduce_next : vx_core.Func_any_from_list_start_reduce_next = vx_core.Class_any_from_list_start_reduce_next()

  fun <T : vx_core.Type_any, Y : vx_core.Type_list> f_any_from_list_start_reduce_next(generic_any_1 : T, list : Y, valstart : T, fn_reduce_next : vx_core.Func_any_from_reduce_next) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_any_from_list_start_reduce_next(generic_any_1, list, valstart, fn_reduce_next)
    return output
  }


  interface Func_any_from_map : vx_core.Type_func, vx_core.Type_replfunc {
    fun <N : vx_core.Type_map, T : vx_core.Type_any> vx_any_from_map(generic_any_1 : T, valuemap : N, key : vx_core.Type_string) : T
  }

  class Class_any_from_map : vx_core.Class_base, Func_any_from_map {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_map = vx_core.Class_any_from_map()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_map = vx_core.Class_any_from_map()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-map", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_map
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_map(generic_any_1, valuemap, key)
      return output
    }

    override fun <N : vx_core.Type_map, T : vx_core.Type_any> vx_any_from_map(generic_any_1 : T, valuemap : N, key : vx_core.Type_string) : T {
      var output : T = vx_core.f_any_from_map(generic_any_1, valuemap, key)
      return output
    }

  }

  val e_any_from_map : vx_core.Func_any_from_map = vx_core.Class_any_from_map()
  val t_any_from_map : vx_core.Func_any_from_map = vx_core.Class_any_from_map()

  fun <N : vx_core.Type_map, T : vx_core.Type_any> f_any_from_map(generic_any_1 : T, valuemap : N, key : vx_core.Type_string) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_any_from_map(generic_any_1, valuemap, key)
    return output
  }


  interface Func_any_from_map_start_reduce : vx_core.Type_func, vx_core.Type_replfunc {
    fun <N : vx_core.Type_map, T : vx_core.Type_any> vx_any_from_map_start_reduce(generic_any_1 : T, map : N, start : T, fn_reduce : vx_core.Func_any_from_any_key_value) : T
  }

  class Class_any_from_map_start_reduce : vx_core.Class_base, Func_any_from_map_start_reduce {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_map_start_reduce = vx_core.Class_any_from_map_start_reduce()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_map_start_reduce = vx_core.Class_any_from_map_start_reduce()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-map-start-reduce", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_map_start_reduce
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_map_start_reduce
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var map : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var start : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var fn_reduce : vx_core.Func_any_from_any_key_value = vx_core.f_any_from_any(vx_core.t_any_from_any_key_value, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce)
      return output
    }

    override fun <N : vx_core.Type_map, T : vx_core.Type_any> vx_any_from_map_start_reduce(generic_any_1 : T, map : N, start : T, fn_reduce : vx_core.Func_any_from_any_key_value) : T {
      var output : T = vx_core.f_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce)
      return output
    }

  }

  val e_any_from_map_start_reduce : vx_core.Func_any_from_map_start_reduce = vx_core.Class_any_from_map_start_reduce()
  val t_any_from_map_start_reduce : vx_core.Func_any_from_map_start_reduce = vx_core.Class_any_from_map_start_reduce()

  fun <N : vx_core.Type_map, T : vx_core.Type_any> f_any_from_map_start_reduce(generic_any_1 : T, map : N, start : T, fn_reduce : vx_core.Func_any_from_any_key_value) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_any_from_map_start_reduce(generic_any_1, map, start, fn_reduce)
    return output
  }


  interface Func_any_from_none : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_any_from_none(generic_any_1 : T) : T
    fun vx_fn_new(fn : Class_any_from_none.IFn) : vx_core.Func_any_from_none
  }

  class Class_any_from_none : vx_core.Class_base, Func_any_from_none {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_none = vx_core.Class_any_from_none()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_none = vx_core.Class_any_from_none()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-none", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_none
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_none
      return output
    }

    fun interface IFn {
      fun resolve() : vx_core.Type_any
    }

    var fn : Class_any_from_none.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_none.IFn) : vx_core.Func_any_from_none {
      val output : vx_core.Class_any_from_none = vx_core.Class_any_from_none()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_any_from_none(generic_any_1)
      return output
    }

    override fun <T : vx_core.Type_any> vx_any_from_none(generic_any_1 : T) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_none.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve()
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_none : vx_core.Func_any_from_none = vx_core.Class_any_from_none()
  val t_any_from_none : vx_core.Func_any_from_none = vx_core.Class_any_from_none()

  fun <T : vx_core.Type_any> f_any_from_none(generic_any_1 : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_none_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any> vx_any_from_none_async(generic_any_1 : T) : CompletableFuture<T>
    fun vx_fn_new(fn : Class_any_from_none_async.IFn) : vx_core.Func_any_from_none_async
  }

  class Class_any_from_none_async : vx_core.Class_base, Func_any_from_none_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_none_async = vx_core.Class_any_from_none_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_none_async = vx_core.Class_any_from_none_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-none-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_none_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_none_async
      return output
    }

    fun interface IFn {
      fun resolve() : CompletableFuture<vx_core.Type_any>
    }

    var fn : Class_any_from_none_async.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_none_async.IFn) : vx_core.Func_any_from_none_async {
      val output : vx_core.Class_any_from_none_async = vx_core.Class_any_from_none_async()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_any_from_none_async(generic_any_1)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any> vx_any_from_none_async(generic_any_1 : T) : CompletableFuture<T> {
      var output : CompletableFuture<T>
      var fnlocal : Class_any_from_none_async.IFn? = this.fn
      if (fnlocal == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : CompletableFuture<vx_core.Type_any> = fnlocal.resolve()
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_none_async : vx_core.Func_any_from_none_async = vx_core.Class_any_from_none_async()
  val t_any_from_none_async : vx_core.Func_any_from_none_async = vx_core.Class_any_from_none_async()

  fun <T : vx_core.Type_any> f_any_from_none_async(generic_any_1 : T) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_reduce : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce(generic_any_1 : T, result : T, item : U) : T
    fun vx_fn_new(fn : Class_any_from_reduce.IFn) : vx_core.Func_any_from_reduce
  }

  class Class_any_from_reduce : vx_core.Class_base, Func_any_from_reduce {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce = vx_core.Class_any_from_reduce()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce = vx_core.Class_any_from_reduce()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_reduce
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_reduce
      return output
    }

    fun interface IFn {
      fun resolve(result : vx_core.Type_any, item : vx_core.Type_any) : vx_core.Type_any
    }

    var fn : Class_any_from_reduce.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_reduce.IFn) : vx_core.Func_any_from_reduce {
      val output : vx_core.Class_any_from_reduce = vx_core.Class_any_from_reduce()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var result : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var item : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_reduce(generic_any_1, result, item)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce(generic_any_1 : T, result : T, item : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_reduce.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve(result, item)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_reduce : vx_core.Func_any_from_reduce = vx_core.Class_any_from_reduce()
  val t_any_from_reduce : vx_core.Func_any_from_reduce = vx_core.Class_any_from_reduce()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_reduce(generic_any_1 : T, result : T, item : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_reduce_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce_async(generic_any_1 : T, result : T, item : U) : CompletableFuture<T>
    fun vx_fn_new(fn : Class_any_from_reduce_async.IFn) : vx_core.Func_any_from_reduce_async
  }

  class Class_any_from_reduce_async : vx_core.Class_base, Func_any_from_reduce_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce_async = vx_core.Class_any_from_reduce_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce_async = vx_core.Class_any_from_reduce_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_reduce_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_reduce_async
      return output
    }

    fun interface IFn {
      fun resolve(result : vx_core.Type_any, item : vx_core.Type_any) : CompletableFuture<vx_core.Type_any>
    }

    var fn : Class_any_from_reduce_async.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_reduce_async.IFn) : vx_core.Func_any_from_reduce_async {
      val output : vx_core.Class_any_from_reduce_async = vx_core.Class_any_from_reduce_async()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var result : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var item : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_any_from_reduce_async(generic_any_1, result, item)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce_async(generic_any_1 : T, result : T, item : U) : CompletableFuture<T> {
      var output : CompletableFuture<T>
      var fnlocal : Class_any_from_reduce_async.IFn? = this.fn
      if (fnlocal == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : CompletableFuture<vx_core.Type_any> = fnlocal.resolve(result, item)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_reduce_async : vx_core.Func_any_from_reduce_async = vx_core.Class_any_from_reduce_async()
  val t_any_from_reduce_async : vx_core.Func_any_from_reduce_async = vx_core.Class_any_from_reduce_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_reduce_async(generic_any_1 : T, result : T, item : U) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_reduce_next : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce_next(generic_any_1 : T, result : T, current : U, next : U) : T
    fun vx_fn_new(fn : Class_any_from_reduce_next.IFn) : vx_core.Func_any_from_reduce_next
  }

  class Class_any_from_reduce_next : vx_core.Class_base, Func_any_from_reduce_next {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce_next = vx_core.Class_any_from_reduce_next()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce_next = vx_core.Class_any_from_reduce_next()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_reduce_next
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_reduce_next
      return output
    }

    fun interface IFn {
      fun resolve(result : vx_core.Type_any, current : vx_core.Type_any, next : vx_core.Type_any) : vx_core.Type_any
    }

    var fn : Class_any_from_reduce_next.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_reduce_next.IFn) : vx_core.Func_any_from_reduce_next {
      val output : vx_core.Class_any_from_reduce_next = vx_core.Class_any_from_reduce_next()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var result : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var current : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var next : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_any_from_reduce_next(generic_any_1, result, current, next)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce_next(generic_any_1 : T, result : T, current : U, next : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var fnlocal : Class_any_from_reduce_next.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve(result, current, next)
        output = vx_core.f_any_from_any(generic_any_1, anyoutput)
      }
      return output
    }

  }

  val e_any_from_reduce_next : vx_core.Func_any_from_reduce_next = vx_core.Class_any_from_reduce_next()
  val t_any_from_reduce_next : vx_core.Func_any_from_reduce_next = vx_core.Class_any_from_reduce_next()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_reduce_next(generic_any_1 : T, result : T, current : U, next : U) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_any_from_reduce_next_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce_next_async(generic_any_1 : T, result : T, current : U, next : U) : CompletableFuture<T>
    fun vx_fn_new(fn : Class_any_from_reduce_next_async.IFn) : vx_core.Func_any_from_reduce_next_async
  }

  class Class_any_from_reduce_next_async : vx_core.Class_base, Func_any_from_reduce_next_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-reduce-next-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_reduce_next_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_reduce_next_async
      return output
    }

    fun interface IFn {
      fun resolve(result : vx_core.Type_any, current : vx_core.Type_any, next : vx_core.Type_any) : CompletableFuture<vx_core.Type_any>
    }

    var fn : Class_any_from_reduce_next_async.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_reduce_next_async.IFn) : vx_core.Func_any_from_reduce_next_async {
      val output : vx_core.Class_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var result : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var current : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var next : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_any_from_reduce_next_async(generic_any_1, result, current, next)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_reduce_next_async(generic_any_1 : T, result : T, current : U, next : U) : CompletableFuture<T> {
      var output : CompletableFuture<T>
      var fnlocal : Class_any_from_reduce_next_async.IFn? = this.fn
      if (fnlocal == null) {
        output = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
      } else {
        var future : CompletableFuture<vx_core.Type_any> = fnlocal.resolve(result, current, next)
        output = vx_core.vx_async_from_async(generic_any_1, future)
      }
      return output
    }

  }

  val e_any_from_reduce_next_async : vx_core.Func_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()
  val t_any_from_reduce_next_async : vx_core.Func_any_from_reduce_next_async = vx_core.Class_any_from_reduce_next_async()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_any_from_reduce_next_async(generic_any_1 : T, result : T, current : U, next : U) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    return output
  }


  interface Func_any_from_struct : vx_core.Type_func, vx_core.Type_replfunc {
    fun <R : vx_core.Type_struct, T : vx_core.Type_any> vx_any_from_struct(generic_any_1 : T, vstruct : R, key : vx_core.Type_string) : T
  }

  class Class_any_from_struct : vx_core.Class_base, Func_any_from_struct {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_struct = vx_core.Class_any_from_struct()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_any_from_struct = vx_core.Class_any_from_struct()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "any<-struct", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any_from_struct
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_any_from_struct
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var vstruct : vx_core.Type_struct = vx_core.f_any_from_any(vx_core.t_struct, arglist.vx_any(vx_core.vx_new_int(0)))
      var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_any_from_struct(generic_any_1, vstruct, key)
      return output
    }

    override fun <R : vx_core.Type_struct, T : vx_core.Type_any> vx_any_from_struct(generic_any_1 : T, vstruct : R, key : vx_core.Type_string) : T {
      var output : T = vx_core.f_any_from_struct(generic_any_1, vstruct, key)
      return output
    }

  }

  val e_any_from_struct : vx_core.Func_any_from_struct = vx_core.Class_any_from_struct()
  val t_any_from_struct : vx_core.Func_any_from_struct = vx_core.Class_any_from_struct()

  fun <R : vx_core.Type_struct, T : vx_core.Type_any> f_any_from_struct(generic_any_1 : T, vstruct : R, key : vx_core.Type_string) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    val value : vx_core.Type_any = vstruct.vx_any(key)
    output = vx_core.f_any_from_any(generic_any_1, value);
    return output
  }


  interface Func_async : vx_core.Func_any_from_any_async {
    fun <T : vx_core.Type_any> vx_async(generic_any_1 : T, value : T) : CompletableFuture<T>
  }

  class Class_async : vx_core.Class_base, Func_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_async = vx_core.Class_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_async = vx_core.Class_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_async
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_async.IFn) : vx_core.Func_any_from_any_async {
      return vx_core.e_any_from_any_async
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_async(generic_any_1 : T, value : U) : CompletableFuture<T> {
      var inputval : T = vx_core.f_any_from_any(generic_any_1, value)
      var output : CompletableFuture<T> = vx_core.f_async(generic_any_1, inputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_async(generic_any_1, value)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any> vx_async(generic_any_1 : T, value : T) : CompletableFuture<T> {
      var output : CompletableFuture<T> = vx_core.f_async(generic_any_1, value)
      return output
    }

  }

  val e_async : vx_core.Func_async = vx_core.Class_async()
  val t_async : vx_core.Func_async = vx_core.Class_async()

  fun <T : vx_core.Type_any> f_async(generic_any_1 : T, value : T) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    output = vx_core.vx_async_new_from_value(value)
    return output
  }


  interface Func_boolean_permission_from_func : vx_core.Func_any_from_any_context {
    fun vx_boolean_permission_from_func(context : vx_core.Type_context, func : vx_core.Type_func) : vx_core.Type_boolean
  }

  class Class_boolean_permission_from_func : vx_core.Class_base, Func_boolean_permission_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_permission_from_func = vx_core.Class_boolean_permission_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_permission_from_func = vx_core.Class_boolean_permission_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean-permission<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_permission_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_permission_from_func
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      return vx_core.e_any_from_any_context
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_func = value as vx_core.Type_func
      var outputval : vx_core.Type_any = vx_core.f_boolean_permission_from_func(context, inputval)
      output = vx_core.f_any_from_any_context(generic_any_1, context, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var func : vx_core.Type_func = vx_core.f_any_from_any(vx_core.t_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_boolean_permission_from_func(context, func)
      return output
    }

    override fun vx_boolean_permission_from_func(context : vx_core.Type_context, func : vx_core.Type_func) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_boolean_permission_from_func(context, func)
      return output
    }

  }

  val e_boolean_permission_from_func : vx_core.Func_boolean_permission_from_func = vx_core.Class_boolean_permission_from_func()
  val t_boolean_permission_from_func : vx_core.Func_boolean_permission_from_func = vx_core.Class_boolean_permission_from_func()

  fun f_boolean_permission_from_func(context : vx_core.Type_context, func : vx_core.Type_func) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_contains_1(
      vx_core.f_allowfuncs_from_security(
        vx_core.f_security_from_context(
          context
        )
      ),
      func
    )
    return output
  }


  interface Func_boolean_write_from_map_name_value : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_boolean_write_from_map_name_value(valuemap : vx_core.Type_map, name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_boolean_write_from_map_name_value : vx_core.Class_base, Func_boolean_write_from_map_name_value {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_write_from_map_name_value = vx_core.Class_boolean_write_from_map_name_value()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_write_from_map_name_value = vx_core.Class_boolean_write_from_map_name_value()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean-write<-map-name-value", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_write_from_map_name_value
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_write_from_map_name_value
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var name : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_boolean_write_from_map_name_value(valuemap, name, value)
      return output
    }

    override fun vx_boolean_write_from_map_name_value(valuemap : vx_core.Type_map, name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_boolean_write_from_map_name_value(valuemap, name, value)
      return output
    }

  }

  val e_boolean_write_from_map_name_value : vx_core.Func_boolean_write_from_map_name_value = vx_core.Class_boolean_write_from_map_name_value()
  val t_boolean_write_from_map_name_value : vx_core.Func_boolean_write_from_map_name_value = vx_core.Class_boolean_write_from_map_name_value()

  fun f_boolean_write_from_map_name_value(valuemap : vx_core.Type_map, name : vx_core.Type_string, value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.vx_boolean_write_from_map_name_value(valuemap, name, value)
    return output
  }


  interface Func_boolean_from_any : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_boolean_from_any(value : vx_core.Type_any) : vx_core.Type_boolean
    fun vx_fn_new(fn : Class_boolean_from_any.IFn) : vx_core.Func_boolean_from_any
  }

  class Class_boolean_from_any : vx_core.Class_base, Func_boolean_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_from_any = vx_core.Class_boolean_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_from_any = vx_core.Class_boolean_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_from_any
      return output
    }

    fun interface IFn {
      fun resolve(value : vx_core.Type_any) : vx_core.Type_any
    }

    var fn : Class_boolean_from_any.IFn? = null

    override fun vx_fn_new(fn : Class_boolean_from_any.IFn) : vx_core.Func_boolean_from_any {
      val output : vx_core.Class_boolean_from_any = vx_core.Class_boolean_from_any()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_boolean_from_any(value)
      return output
    }

    override fun vx_boolean_from_any(value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      var fnlocal : Class_boolean_from_any.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve(value)
        output = vx_core.f_any_from_any(vx_core.t_boolean, anyoutput)
      }
      return output
    }

  }

  val e_boolean_from_any : vx_core.Func_boolean_from_any = vx_core.Class_boolean_from_any()
  val t_boolean_from_any : vx_core.Func_boolean_from_any = vx_core.Class_boolean_from_any()

  fun f_boolean_from_any(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    return output
  }


  interface Func_boolean_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_boolean_from_func() : vx_core.Type_boolean
    fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_boolean_from_func
  }

  class Class_boolean_from_func : vx_core.Class_base, Func_boolean_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_from_func = vx_core.Class_boolean_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_from_func = vx_core.Class_boolean_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_from_func
      return output
    }

    fun interface IFn {
      fun resolve() : vx_core.Type_any
    }

    var fn : Class_any_from_func.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_boolean_from_func {
      val output : vx_core.Class_boolean_from_func = vx_core.Class_boolean_from_func()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_boolean_from_func()
      return output
    }

    override fun vx_boolean_from_func() : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      var fnlocal : vx_core.Class_any_from_func.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve()
        output = vx_core.f_any_from_any(vx_core.t_boolean, anyoutput)
      }
      return output
    }

  }

  val e_boolean_from_func : vx_core.Func_boolean_from_func = vx_core.Class_boolean_from_func()
  val t_boolean_from_func : vx_core.Func_boolean_from_func = vx_core.Class_boolean_from_func()

  fun f_boolean_from_func() : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    return output
  }


  interface Func_boolean_from_none : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_boolean_from_none() : vx_core.Type_boolean
    fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_boolean_from_none
  }

  class Class_boolean_from_none : vx_core.Class_base, Func_boolean_from_none {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_from_none = vx_core.Class_boolean_from_none()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_boolean_from_none = vx_core.Class_boolean_from_none()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "boolean<-none", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_boolean_from_none
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_boolean_from_none
      return output
    }

    fun interface IFn {
      fun resolve() : vx_core.Type_any
    }

    var fn : Class_any_from_func.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_boolean_from_none {
      val output : vx_core.Class_boolean_from_none = vx_core.Class_boolean_from_none()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_boolean_from_none()
      return output
    }

    override fun vx_boolean_from_none() : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.c_false
      var fnlocal : vx_core.Class_any_from_func.IFn? = this.fn
      if (fnlocal != null) {
        var anyoutput : vx_core.Type_any = fnlocal.resolve()
        output = vx_core.f_any_from_any(vx_core.t_boolean, anyoutput)
      }
      return output
    }

  }

  val e_boolean_from_none : vx_core.Func_boolean_from_none = vx_core.Class_boolean_from_none()
  val t_boolean_from_none : vx_core.Func_boolean_from_none = vx_core.Class_boolean_from_none()

  fun f_boolean_from_none() : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    return output
  }


  interface Func_case : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_case(values : vx_core.Type_list, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse
  }

  class Class_case : vx_core.Class_base, Func_case {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_case = vx_core.Class_case()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_case = vx_core.Class_case()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "case", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_case
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_case
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_case(values, fn_any)
      return output
    }

    override fun vx_case(values : vx_core.Type_list, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
      var output : vx_core.Type_thenelse = vx_core.f_case(values, fn_any)
      return output
    }

  }

  val e_case : vx_core.Func_case = vx_core.Class_case()
  val t_case : vx_core.Func_case = vx_core.Class_case()

  fun f_case(values : vx_core.Type_list, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
    var output : vx_core.Type_thenelse = vx_core.e_thenelse
    output = vx_core.f_new(
      vx_core.t_thenelse,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        vx_core.vx_new_string(":casemany"),
        vx_core.vx_new_string(":values"),
        values,
        vx_core.vx_new_string(":fn-any"),
        fn_any
      )
    )
    return output
  }


  interface Func_case_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_case_1(value : vx_core.Type_any, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse
  }

  class Class_case_1 : vx_core.Class_base, Func_case_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_case_1 = vx_core.Class_case_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_case_1 = vx_core.Class_case_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "case", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_case_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_case_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_case_1(value, fn_any)
      return output
    }

    override fun vx_case_1(value : vx_core.Type_any, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
      var output : vx_core.Type_thenelse = vx_core.f_case_1(value, fn_any)
      return output
    }

  }

  val e_case_1 : vx_core.Func_case_1 = vx_core.Class_case_1()
  val t_case_1 : vx_core.Func_case_1 = vx_core.Class_case_1()

  fun f_case_1(value : vx_core.Type_any, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
    var output : vx_core.Type_thenelse = vx_core.e_thenelse
    output = vx_core.f_new(
      vx_core.t_thenelse,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        vx_core.vx_new_string(":case"),
        vx_core.vx_new_string(":value"),
        value,
        vx_core.vx_new_string(":fn-any"),
        fn_any
      )
    )
    return output
  }


  interface Func_compare : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_compare(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_int
  }

  class Class_compare : vx_core.Class_base, Func_compare {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_compare = vx_core.Class_compare()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_compare = vx_core.Class_compare()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "compare", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_compare
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_compare
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_compare(val1, val2)
      return output
    }

    override fun vx_compare(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_compare(val1, val2)
      return output
    }

  }

  val e_compare : vx_core.Func_compare = vx_core.Class_compare()
  val t_compare : vx_core.Func_compare = vx_core.Class_compare()

  fun f_compare(val1 : vx_core.Type_any, val2 : vx_core.Type_any) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.vx_compare(val1, val2)
    return output
  }


  interface Func_contains : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_contains(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean
  }

  class Class_contains : vx_core.Class_base, Func_contains {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_contains = vx_core.Class_contains()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_contains = vx_core.Class_contains()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_contains
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_contains
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var find : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_contains(text, find)
      return output
    }

    override fun vx_contains(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_contains(text, find)
      return output
    }

  }

  val e_contains : vx_core.Func_contains = vx_core.Class_contains()
  val t_contains : vx_core.Func_contains = vx_core.Class_contains()

  fun f_contains(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val check : Boolean = vx_boolean_from_string_find(
      text.vx_string(),
      find.vx_string())
    output = vx_core.vx_new_boolean(check)
    return output
  }


  interface Func_contains_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_contains_1(values : vx_core.Type_list, find : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_contains_1 : vx_core.Class_base, Func_contains_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_contains_1 = vx_core.Class_contains_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_contains_1 = vx_core.Class_contains_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "contains", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_contains_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_contains_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var find : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_contains_1(values, find)
      return output
    }

    override fun vx_contains_1(values : vx_core.Type_list, find : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_contains_1(values, find)
      return output
    }

  }

  val e_contains_1 : vx_core.Func_contains_1 = vx_core.Class_contains_1()
  val t_contains_1 : vx_core.Func_contains_1 = vx_core.Class_contains_1()

  fun f_contains_1(values : vx_core.Type_list, find : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.vx_contains_1(values, find)
    return output
  }


  interface Func_context_main : vx_core.Func_any_from_any {
    fun vx_context_main(args : vx_core.Type_anylist) : vx_core.Type_context
  }

  class Class_context_main : vx_core.Class_base, Func_context_main {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_context_main = vx_core.Class_context_main()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_context_main = vx_core.Class_context_main()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "context-main", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "context", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_context_main
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_context_main
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_context_main(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var args : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_context_main(args)
      return output
    }

    override fun vx_context_main(args : vx_core.Type_anylist) : vx_core.Type_context {
      var output : vx_core.Type_context = vx_core.f_context_main(args)
      return output
    }

  }

  val e_context_main : vx_core.Func_context_main = vx_core.Class_context_main()
  val t_context_main : vx_core.Func_context_main = vx_core.Class_context_main()

  fun f_context_main(args : vx_core.Type_anylist) : vx_core.Type_context {
    var output : vx_core.Type_context = vx_core.e_context
    output = vx_core.f_empty(
      vx_core.t_context
    )
    return output
  }


  interface Func_copy : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_copy(value : T, values : vx_core.Type_anylist) : T
  }

  class Class_copy : vx_core.Class_base, Func_copy {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_copy = vx_core.Class_copy()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_copy = vx_core.Class_copy()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "copy", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_copy
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_copy
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_copy(value, values)
      return output
    }

    override fun <T : vx_core.Type_any> vx_copy(value : T, values : vx_core.Type_anylist) : T {
      var output : T = vx_core.f_copy(value, values)
      return output
    }

  }

  val e_copy : vx_core.Func_copy = vx_core.Class_copy()
  val t_copy : vx_core.Func_copy = vx_core.Class_copy()

  fun <T : vx_core.Type_any> f_copy(value : T, values : vx_core.Type_anylist) : T {
    val arrayany : Array<vx_core.Type_any> = vx_core.arrayany_from_anylist(
      values
    )
    val valuecopy : vx_core.Type_any = value.vx_copy(*arrayany)
    val output : T = valuecopy as T
    return output
  }


  interface Func_else : vx_core.Func_any_from_any {
    fun vx_else(fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse
  }

  class Class_else : vx_core.Class_base, Func_else {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_else = vx_core.Class_else()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_else = vx_core.Class_else()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "else", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_else
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_else
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Func_any_from_func = value as vx_core.Func_any_from_func
      var outputval : vx_core.Type_any = vx_core.f_else(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_else(fn_any)
      return output
    }

    override fun vx_else(fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
      var output : vx_core.Type_thenelse = vx_core.f_else(fn_any)
      return output
    }

  }

  val e_else : vx_core.Func_else = vx_core.Class_else()
  val t_else : vx_core.Func_else = vx_core.Class_else()

  fun f_else(fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
    var output : vx_core.Type_thenelse = vx_core.e_thenelse
    output = vx_core.f_new(
      vx_core.t_thenelse,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        vx_core.vx_new_string(":else"),
        vx_core.vx_new_string(":fn-any"),
        fn_any
      )
    )
    return output
  }


  interface Func_empty : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_empty(type : T) : T
  }

  class Class_empty : vx_core.Class_base, Func_empty {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_empty = vx_core.Class_empty()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_empty = vx_core.Class_empty()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "empty", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_empty
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_empty
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_empty(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var type : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_empty(type)
      return output
    }

    override fun <T : vx_core.Type_any> vx_empty(type : T) : T {
      var output : T = vx_core.f_empty(type)
      return output
    }

  }

  val e_empty : vx_core.Func_empty = vx_core.Class_empty()
  val t_empty : vx_core.Func_empty = vx_core.Class_empty()

  fun <T : vx_core.Type_any> f_empty(type : T) : T {
    val output : T = vx_core.vx_empty(type)
    return output
  }


  interface Func_extends_from_any : vx_core.Func_any_from_any {
    fun vx_extends_from_any(value : vx_core.Type_any) : vx_core.Type_string
  }

  class Class_extends_from_any : vx_core.Class_base, Func_extends_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_extends_from_any = vx_core.Class_extends_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_extends_from_any = vx_core.Class_extends_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "extends<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_extends_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_extends_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_extends_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_extends_from_any(value)
      return output
    }

    override fun vx_extends_from_any(value : vx_core.Type_any) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_extends_from_any(value)
      return output
    }

  }

  val e_extends_from_any : vx_core.Func_extends_from_any = vx_core.Class_extends_from_any()
  val t_extends_from_any : vx_core.Func_extends_from_any = vx_core.Class_extends_from_any()

  fun f_extends_from_any(value : vx_core.Type_any) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_extends_from_typedef(
      vx_core.f_typedef_from_any(
        value
      )
    )
    return output
  }


  interface Func_extends_from_typedef : vx_core.Func_any_from_any {
    fun vx_extends_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string
  }

  class Class_extends_from_typedef : vx_core.Class_base, Func_extends_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_extends_from_typedef = vx_core.Class_extends_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_extends_from_typedef = vx_core.Class_extends_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "extends<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_extends_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_extends_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_extends_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_extends_from_typedef(vtypedef)
      return output
    }

    override fun vx_extends_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_extends_from_typedef(vtypedef)
      return output
    }

  }

  val e_extends_from_typedef : vx_core.Func_extends_from_typedef = vx_core.Class_extends_from_typedef()
  val t_extends_from_typedef : vx_core.Func_extends_from_typedef = vx_core.Class_extends_from_typedef()

  fun f_extends_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vtypedef.extend()
    return output
  }


  interface Func_first_from_list : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_first_from_list(generic_any_1 : T, values : X) : T
  }

  class Class_first_from_list : vx_core.Class_base, Func_first_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_first_from_list = vx_core.Class_first_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_first_from_list = vx_core.Class_first_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "first<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_first_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_first_from_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_first_from_list(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_first_from_list(generic_any_1, values)
      return output
    }

    override fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_first_from_list(generic_any_1 : T, values : X) : T {
      var output : T = vx_core.f_first_from_list(generic_any_1, values)
      return output
    }

  }

  val e_first_from_list : vx_core.Func_first_from_list = vx_core.Class_first_from_list()
  val t_first_from_list : vx_core.Func_first_from_list = vx_core.Class_first_from_list()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_first_from_list(generic_any_1 : T, values : X) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.f_any_from_list(
      generic_any_1,
      values,
      vx_core.vx_new_int(1)
    )
    return output
  }


  interface Func_first_from_list_any_from_any : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_first_from_list_any_from_any(generic_any_1 : T, values : X, fn_any_from_any : vx_core.Func_any_from_any) : T
  }

  class Class_first_from_list_any_from_any : vx_core.Class_base, Func_first_from_list_any_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_first_from_list_any_from_any = vx_core.Class_first_from_list_any_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_first_from_list_any_from_any = vx_core.Class_first_from_list_any_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "first<-list-any<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_first_from_list_any_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_first_from_list_any_from_any
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any : vx_core.Func_any_from_any = vx_core.f_any_from_any(vx_core.t_any_from_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_first_from_list_any_from_any(generic_any_1, values, fn_any_from_any)
      return output
    }

    override fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_first_from_list_any_from_any(generic_any_1 : T, values : X, fn_any_from_any : vx_core.Func_any_from_any) : T {
      var output : T = vx_core.f_first_from_list_any_from_any(generic_any_1, values, fn_any_from_any)
      return output
    }

  }

  val e_first_from_list_any_from_any : vx_core.Func_first_from_list_any_from_any = vx_core.Class_first_from_list_any_from_any()
  val t_first_from_list_any_from_any : vx_core.Func_first_from_list_any_from_any = vx_core.Class_first_from_list_any_from_any()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_first_from_list_any_from_any(generic_any_1 : T, values : X, fn_any_from_any : vx_core.Func_any_from_any) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    val listvalue : List<vx_core.Type_any> = values.vx_list()
    for (value : vx_core.Type_any in listvalue) {
      if (value != vx_core.c_nothing) {
        output = fn_any_from_any.vx_any_from_any(generic_any_1, value)
        break
      }
    }
    return output
  }


  interface Func_float_from_string : vx_core.Func_any_from_any {
    fun vx_float_from_string(text : vx_core.Type_string) : vx_core.Type_float
  }

  class Class_float_from_string : vx_core.Class_base, Func_float_from_string {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_float_from_string = vx_core.Class_float_from_string()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_float_from_string = vx_core.Class_float_from_string()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "float<-string", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "float", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_float_from_string
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_float_from_string
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_float_from_string(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_float_from_string(text)
      return output
    }

    override fun vx_float_from_string(text : vx_core.Type_string) : vx_core.Type_float {
      var output : vx_core.Type_float = vx_core.f_float_from_string(text)
      return output
    }

  }

  val e_float_from_string : vx_core.Func_float_from_string = vx_core.Class_float_from_string()
  val t_float_from_string : vx_core.Func_float_from_string = vx_core.Class_float_from_string()

  fun f_float_from_string(text : vx_core.Type_string) : vx_core.Type_float {
    var output : vx_core.Type_float = vx_core.e_float
    val num : Float = vx_core.vx_float_from_string(text.vx_string())
    output = vx_core.vx_new_float(num)
    return output
  }


  interface Func_fn : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_fn(generic_any_1 : T, parameters : vx_core.Type_arglist, fn_any : vx_core.Func_any_from_func) : T
  }

  class Class_fn : vx_core.Class_base, Func_fn {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_fn = vx_core.Class_fn()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_fn = vx_core.Class_fn()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "fn", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_fn
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var parameters : vx_core.Type_arglist = vx_core.f_any_from_any(vx_core.t_arglist, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_fn(generic_any_1, parameters, fn_any)
      return output
    }

    override fun <T : vx_core.Type_any> vx_fn(generic_any_1 : T, parameters : vx_core.Type_arglist, fn_any : vx_core.Func_any_from_func) : T {
      var output : T = vx_core.f_fn(generic_any_1, parameters, fn_any)
      return output
    }

  }

  val e_fn : vx_core.Func_fn = vx_core.Class_fn()
  val t_fn : vx_core.Func_fn = vx_core.Class_fn()

  fun <T : vx_core.Type_any> f_fn(generic_any_1 : T, parameters : vx_core.Type_arglist, fn_any : vx_core.Func_any_from_func) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_funcdef_from_func : vx_core.Func_any_from_any {
    fun vx_funcdef_from_func(value : vx_core.Type_func) : vx_core.Type_funcdef
  }

  class Class_funcdef_from_func : vx_core.Class_base, Func_funcdef_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_funcdef_from_func = vx_core.Class_funcdef_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_funcdef_from_func = vx_core.Class_funcdef_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "funcdef<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "funcdef", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funcdef_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funcdef_from_func
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_func = value as vx_core.Type_func
      var outputval : vx_core.Type_any = vx_core.f_funcdef_from_func(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_func = vx_core.f_any_from_any(vx_core.t_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_funcdef_from_func(value)
      return output
    }

    override fun vx_funcdef_from_func(value : vx_core.Type_func) : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.f_funcdef_from_func(value)
      return output
    }

  }

  val e_funcdef_from_func : vx_core.Func_funcdef_from_func = vx_core.Class_funcdef_from_func()
  val t_funcdef_from_func : vx_core.Func_funcdef_from_func = vx_core.Class_funcdef_from_func()

  fun f_funcdef_from_func(value : vx_core.Type_func) : vx_core.Type_funcdef {
    var output : vx_core.Type_funcdef = vx_core.e_funcdef
    output = value.vx_funcdef()
    return output
  }


  interface Func_funcname_from_funcdef : vx_core.Func_any_from_any {
    fun vx_funcname_from_funcdef(funcdef : vx_core.Type_funcdef) : vx_core.Type_string
  }

  class Class_funcname_from_funcdef : vx_core.Class_base, Func_funcname_from_funcdef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_funcname_from_funcdef = vx_core.Class_funcname_from_funcdef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_funcname_from_funcdef = vx_core.Class_funcname_from_funcdef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "funcname<-funcdef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_funcname_from_funcdef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_funcname_from_funcdef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_funcdef = value as vx_core.Type_funcdef
      var outputval : vx_core.Type_any = vx_core.f_funcname_from_funcdef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var funcdef : vx_core.Type_funcdef = vx_core.f_any_from_any(vx_core.t_funcdef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_funcname_from_funcdef(funcdef)
      return output
    }

    override fun vx_funcname_from_funcdef(funcdef : vx_core.Type_funcdef) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_funcname_from_funcdef(funcdef)
      return output
    }

  }

  val e_funcname_from_funcdef : vx_core.Func_funcname_from_funcdef = vx_core.Class_funcname_from_funcdef()
  val t_funcname_from_funcdef : vx_core.Func_funcname_from_funcdef = vx_core.Class_funcname_from_funcdef()

  fun f_funcname_from_funcdef(funcdef : vx_core.Type_funcdef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_new(
      vx_core.t_string,
      vx_core.vx_new(
        vx_core.t_anylist,
        funcdef.pkgname(),
        vx_core.vx_new_string("/"),
        funcdef.name()
      )
    )
    return output
  }


  interface Func_if : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_if(generic_any_1 : T, clause : vx_core.Type_boolean, then : T) : T
  }

  class Class_if : vx_core.Class_base, Func_if {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_if = vx_core.Class_if()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_if = vx_core.Class_if()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_if
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_if
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var clause : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      var then : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_if(generic_any_1, clause, then)
      return output
    }

    override fun <T : vx_core.Type_any> vx_if(generic_any_1 : T, clause : vx_core.Type_boolean, then : T) : T {
      var output : T = vx_core.f_if(generic_any_1, clause, then)
      return output
    }

  }

  val e_if : vx_core.Func_if = vx_core.Class_if()
  val t_if : vx_core.Func_if = vx_core.Class_if()

  fun <T : vx_core.Type_any> f_if(generic_any_1 : T, clause : vx_core.Type_boolean, then : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    if (clause.vx_boolean()) {
      output = then
    }
    return output
  }


  interface Func_if_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_if_1(generic_any_1 : T, clause : vx_core.Type_boolean, thenval : T, elseval : T) : T
  }

  class Class_if_1 : vx_core.Class_base, Func_if_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_if_1 = vx_core.Class_if_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_if_1 = vx_core.Class_if_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_if_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_if_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var clause : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      var thenval : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      var elseval : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_if_1(generic_any_1, clause, thenval, elseval)
      return output
    }

    override fun <T : vx_core.Type_any> vx_if_1(generic_any_1 : T, clause : vx_core.Type_boolean, thenval : T, elseval : T) : T {
      var output : T = vx_core.f_if_1(generic_any_1, clause, thenval, elseval)
      return output
    }

  }

  val e_if_1 : vx_core.Func_if_1 = vx_core.Class_if_1()
  val t_if_1 : vx_core.Func_if_1 = vx_core.Class_if_1()

  fun <T : vx_core.Type_any> f_if_1(generic_any_1 : T, clause : vx_core.Type_boolean, thenval : T, elseval : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    if (clause.vx_boolean()) {
      output = thenval
    } else {
      output = elseval
    }
    return output
  }


  interface Func_if_2 : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_if_2(generic_any_1 : T, thenelselist : vx_core.Type_thenelselist) : T
  }

  class Class_if_2 : vx_core.Class_base, Func_if_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_if_2 = vx_core.Class_if_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_if_2 = vx_core.Class_if_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "if", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_if_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_if_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_thenelselist = value as vx_core.Type_thenelselist
      var outputval : vx_core.Type_any = vx_core.f_if_2(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var thenelselist : vx_core.Type_thenelselist = vx_core.f_any_from_any(vx_core.t_thenelselist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_if_2(generic_any_1, thenelselist)
      return output
    }

    override fun <T : vx_core.Type_any> vx_if_2(generic_any_1 : T, thenelselist : vx_core.Type_thenelselist) : T {
      var output : T = vx_core.f_if_2(generic_any_1, thenelselist)
      return output
    }

  }

  val e_if_2 : vx_core.Func_if_2 = vx_core.Class_if_2()
  val t_if_2 : vx_core.Func_if_2 = vx_core.Class_if_2()

  fun <T : vx_core.Type_any> f_if_2(generic_any_1 : T, thenelselist : vx_core.Type_thenelselist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_if_2(generic_any_1, thenelselist)
    return output
  }


  interface Func_int_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_int_from_func() : vx_core.Type_int
    fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_int_from_func
  }

  class Class_int_from_func : vx_core.Class_base, Func_int_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_int_from_func = vx_core.Class_int_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_int_from_func = vx_core.Class_int_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "int<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_int_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_int_from_func
      return output
    }

    var fn : Class_any_from_func.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_int_from_func {
      val output : vx_core.Class_int_from_func = vx_core.Class_int_from_func()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_int_from_func()
      return output
    }

    override fun vx_int_from_func() : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_int_from_func()
      return output
    }

  }

  val e_int_from_func : vx_core.Func_int_from_func = vx_core.Class_int_from_func()
  val t_int_from_func : vx_core.Func_int_from_func = vx_core.Class_int_from_func()

  fun f_int_from_func() : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    return output
  }


  interface Func_int_from_string : vx_core.Func_any_from_any {
    fun vx_int_from_string(value : vx_core.Type_string) : vx_core.Type_int
  }

  class Class_int_from_string : vx_core.Class_base, Func_int_from_string {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_int_from_string = vx_core.Class_int_from_string()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_int_from_string = vx_core.Class_int_from_string()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "int<-string", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_int_from_string
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_int_from_string
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_int_from_string(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_int_from_string(value)
      return output
    }

    override fun vx_int_from_string(value : vx_core.Type_string) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_int_from_string(value)
      return output
    }

  }

  val e_int_from_string : vx_core.Func_int_from_string = vx_core.Class_int_from_string()
  val t_int_from_string : vx_core.Func_int_from_string = vx_core.Class_int_from_string()

  fun f_int_from_string(value : vx_core.Type_string) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_switch(
      vx_core.t_int,
      value,
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case_1(
          vx_core.vx_new_string("notanumber"),
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_1 : vx_core.Type_any = vx_core.c_notanumber
            output_1
          })
        ),
        vx_core.f_case_1(
          vx_core.vx_new_string("infinity"),
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_2 : vx_core.Type_any = vx_core.c_infinity
            output_2
          })
        ),
        vx_core.f_case_1(
          vx_core.vx_new_string("neginfinity"),
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_3 : vx_core.Type_any = vx_core.c_neginfinity
            output_3
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new({ ->
            var intresult : vx_core.Type_int = vx_core.e_int
            val strval : String = value.vx_string()
            try {
              val floatresult : Float = strval.toFloat()
              val iresult : Int = floatresult.toInt()
              intresult = vx_core.vx_new_int(iresult)
            } catch (ex : Exception) {
              intresult = vx_core.c_notanumber
            }
            intresult
          })
        )
      )
    )
    return output
  }


  interface Func_is_empty : vx_core.Func_any_from_any {
    fun vx_is_empty(text : vx_core.Type_string) : vx_core.Type_boolean
  }

  class Class_is_empty : vx_core.Class_base, Func_is_empty {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_empty = vx_core.Class_is_empty()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_empty = vx_core.Class_is_empty()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_empty
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_empty
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_is_empty(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_empty(text)
      return output
    }

    override fun vx_is_empty(text : vx_core.Type_string) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_is_empty(text)
      return output
    }

  }

  val e_is_empty : vx_core.Func_is_empty = vx_core.Class_is_empty()
  val t_is_empty : vx_core.Func_is_empty = vx_core.Class_is_empty()

  fun f_is_empty(text : vx_core.Type_string) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    if (text.vx_string().length == 0) {
      output = vx_core.c_true
    }
    return output
  }


  interface Func_is_empty_1 : vx_core.Func_any_from_any {
    fun vx_is_empty_1(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_empty_1 : vx_core.Class_base, Func_is_empty_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_empty_1 = vx_core.Class_is_empty_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_empty_1 = vx_core.Class_is_empty_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-empty", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_empty_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_empty_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_empty_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_empty_1(value)
      return output
    }

    override fun vx_is_empty_1(value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_is_empty_1(value)
      return output
    }

  }

  val e_is_empty_1 : vx_core.Func_is_empty_1 = vx_core.Class_is_empty_1()
  val t_is_empty_1 : vx_core.Func_is_empty_1 = vx_core.Class_is_empty_1()

  fun f_is_empty_1(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    if (value == value.vx_empty()) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }
    return output
  }


  interface Func_is_endswith : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_is_endswith(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean
  }

  class Class_is_endswith : vx_core.Class_base, Func_is_endswith {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_endswith = vx_core.Class_is_endswith()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_endswith = vx_core.Class_is_endswith()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-endswith", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_endswith
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_endswith
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var find : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_is_endswith(text, find)
      return output
    }

    override fun vx_is_endswith(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_is_endswith(text, find)
      return output
    }

  }

  val e_is_endswith : vx_core.Func_is_endswith = vx_core.Class_is_endswith()
  val t_is_endswith : vx_core.Func_is_endswith = vx_core.Class_is_endswith()

  fun f_is_endswith(text : vx_core.Type_string, find : vx_core.Type_string) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val stext : String = text.vx_string()
    val sfind : String = find.vx_string()
    if (stext.endsWith(sfind)) {
      output = vx_core.c_true
    }
    return output
  }


  interface Func_is_float : vx_core.Func_any_from_any {
    fun vx_is_float(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_float : vx_core.Class_base, Func_is_float {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_float = vx_core.Class_is_float()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_float = vx_core.Class_is_float()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-float", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_float
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_float
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_float(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_float(value)
      return output
    }

    override fun vx_is_float(value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_is_float(value)
      return output
    }

  }

  val e_is_float : vx_core.Func_is_float = vx_core.Class_is_float()
  val t_is_float : vx_core.Func_is_float = vx_core.Class_is_float()

  fun f_is_float(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val result : Boolean = vx_core.vx_is_float(value)
    output = vx_core.vx_new_boolean(result)
    return output
  }


  interface Func_is_func : vx_core.Func_any_from_any {
    fun vx_is_func(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_func : vx_core.Class_base, Func_is_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_func = vx_core.Class_is_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_func = vx_core.Class_is_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_func
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_func(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_func(value)
      return output
    }

    override fun vx_is_func(value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_is_func(value)
      return output
    }

  }

  val e_is_func : vx_core.Func_is_func = vx_core.Class_is_func()
  val t_is_func : vx_core.Func_is_func = vx_core.Class_is_func()

  fun f_is_func(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    if (value is vx_core.Type_func) {
      output = vx_core.c_true
    }
    return output
  }


  interface Func_is_int : vx_core.Func_any_from_any {
    fun vx_is_int(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_int : vx_core.Class_base, Func_is_int {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_int = vx_core.Class_is_int()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_int = vx_core.Class_is_int()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-int", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_int
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_int
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_int(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_int(value)
      return output
    }

    override fun vx_is_int(value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_is_int(value)
      return output
    }

  }

  val e_is_int : vx_core.Func_is_int = vx_core.Class_is_int()
  val t_is_int : vx_core.Func_is_int = vx_core.Class_is_int()

  fun f_is_int(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    val result : Boolean = vx_core.vx_is_int(value)
    output = vx_core.vx_new_boolean(result)
    return output
  }


  interface Func_is_number : vx_core.Func_any_from_any {
    fun vx_is_number(value : vx_core.Type_any) : vx_core.Type_boolean
  }

  class Class_is_number : vx_core.Class_base, Func_is_number {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_number = vx_core.Class_is_number()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_number = vx_core.Class_is_number()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-number", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_number
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_number
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_is_number(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_number(value)
      return output
    }

    override fun vx_is_number(value : vx_core.Type_any) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_is_number(value)
      return output
    }

  }

  val e_is_number : vx_core.Func_is_number = vx_core.Class_is_number()
  val t_is_number : vx_core.Func_is_number = vx_core.Class_is_number()

  fun f_is_number(value : vx_core.Type_any) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_switch(
      vx_core.t_boolean,
      vx_core.f_typename_from_any(
        value
      ),
      vx_core.vx_new(
        vx_core.t_thenelselist,
        vx_core.f_case(
          vx_core.f_new(
            vx_core.t_list,
            vx_core.vx_new(
              vx_core.t_anylist,
              vx_core.vx_new_string("vx/core/decimal"),
              vx_core.vx_new_string("vx/core/float"),
              vx_core.vx_new_string("vx/core/int"),
              vx_core.vx_new_string("vx/core/number")
            )
          ),
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_1 : vx_core.Type_any = vx_core.vx_new_boolean(true)
            output_1
          })
        ),
        vx_core.f_else(
          vx_core.t_any_from_func.vx_fn_new({ ->
            var output_2 : vx_core.Type_any = vx_core.vx_new_boolean(false)
            output_2
          })
        )
      )
    )
    return output
  }


  interface Func_is_pass_from_permission : vx_core.Func_any_from_any_context {
    fun vx_is_pass_from_permission(context : vx_core.Type_context, permission : vx_core.Type_permission) : vx_core.Type_boolean
  }

  class Class_is_pass_from_permission : vx_core.Class_base, Func_is_pass_from_permission {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_pass_from_permission = vx_core.Class_is_pass_from_permission()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_is_pass_from_permission = vx_core.Class_is_pass_from_permission()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "is-pass<-permission", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_is_pass_from_permission
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_is_pass_from_permission
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      return vx_core.e_any_from_any_context
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_permission = value as vx_core.Type_permission
      var outputval : vx_core.Type_any = vx_core.f_is_pass_from_permission(context, inputval)
      output = vx_core.f_any_from_any_context(generic_any_1, context, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var permission : vx_core.Type_permission = vx_core.f_any_from_any(vx_core.t_permission, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_is_pass_from_permission(context, permission)
      return output
    }

    override fun vx_is_pass_from_permission(context : vx_core.Type_context, permission : vx_core.Type_permission) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_is_pass_from_permission(context, permission)
      return output
    }

  }

  val e_is_pass_from_permission : vx_core.Func_is_pass_from_permission = vx_core.Class_is_pass_from_permission()
  val t_is_pass_from_permission : vx_core.Func_is_pass_from_permission = vx_core.Class_is_pass_from_permission()

  fun f_is_pass_from_permission(context : vx_core.Type_context, permission : vx_core.Type_permission) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_let(
      vx_core.t_boolean,
      vx_core.t_any_from_func.vx_fn_new({ ->
        var id : vx_core.Type_string = permission.id()
        var lookup : vx_core.Type_permission = vx_core.f_permission_from_id_context(
          context,
          id
        )
        var output_1 : vx_core.Type_any = vx_core.f_eq(
          lookup,
          permission
        )
        output_1
      })
    )
    return output
  }


  interface Func_last_from_list : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_last_from_list(generic_any_1 : T, values : X) : T
  }

  class Class_last_from_list : vx_core.Class_base, Func_last_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_last_from_list = vx_core.Class_last_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_last_from_list = vx_core.Class_last_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "last<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_last_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_last_from_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_last_from_list(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_last_from_list(generic_any_1, values)
      return output
    }

    override fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_last_from_list(generic_any_1 : T, values : X) : T {
      var output : T = vx_core.f_last_from_list(generic_any_1, values)
      return output
    }

  }

  val e_last_from_list : vx_core.Func_last_from_list = vx_core.Class_last_from_list()
  val t_last_from_list : vx_core.Func_last_from_list = vx_core.Class_last_from_list()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_last_from_list(generic_any_1 : T, values : X) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.f_let(
      generic_any_1,
      vx_core.t_any_from_func.vx_fn_new({ ->
        var len : vx_core.Type_int = vx_core.f_length_1(
          values
        )
        var output_1 : vx_core.Type_any = vx_core.f_any_from_list(
          generic_any_1,
          values,
          len
        )
        output_1
      })
    )
    return output
  }


  interface Func_length : vx_core.Func_any_from_any {
    fun vx_length(text : vx_core.Type_string) : vx_core.Type_int
  }

  class Class_length : vx_core.Class_base, Func_length {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_length = vx_core.Class_length()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_length = vx_core.Class_length()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_length
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_length
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_length(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_length(text)
      return output
    }

    override fun vx_length(text : vx_core.Type_string) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_length(text)
      return output
    }

  }

  val e_length : vx_core.Func_length = vx_core.Class_length()
  val t_length : vx_core.Func_length = vx_core.Class_length()

  fun f_length(text : vx_core.Type_string) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    val len : Int = text.vx_string().length
    output = vx_core.vx_new_int(len)
    return output
  }


  interface Func_length_1 : vx_core.Func_any_from_any {
    fun vx_length_1(values : vx_core.Type_list) : vx_core.Type_int
  }

  class Class_length_1 : vx_core.Class_base, Func_length_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_length_1 = vx_core.Class_length_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_length_1 = vx_core.Class_length_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_length_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_length_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_length_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_length_1(values)
      return output
    }

    override fun vx_length_1(values : vx_core.Type_list) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_length_1(values)
      return output
    }

  }

  val e_length_1 : vx_core.Func_length_1 = vx_core.Class_length_1()
  val t_length_1 : vx_core.Func_length_1 = vx_core.Class_length_1()

  fun f_length_1(values : vx_core.Type_list) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    val intresult : Int = values.vx_list().size
    output = vx_core.vx_new_int(intresult)
    return output
  }


  interface Func_length_2 : vx_core.Func_any_from_any {
    fun vx_length_2(valuemap : vx_core.Type_map) : vx_core.Type_int
  }

  class Class_length_2 : vx_core.Class_base, Func_length_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_length_2 = vx_core.Class_length_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_length_2 = vx_core.Class_length_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "length", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "int", // name
          "", // extends
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_number), // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_length_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_length_2
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_map = value as vx_core.Type_map
      var outputval : vx_core.Type_any = vx_core.f_length_2(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_length_2(valuemap)
      return output
    }

    override fun vx_length_2(valuemap : vx_core.Type_map) : vx_core.Type_int {
      var output : vx_core.Type_int = vx_core.f_length_2(valuemap)
      return output
    }

  }

  val e_length_2 : vx_core.Func_length_2 = vx_core.Class_length_2()
  val t_length_2 : vx_core.Func_length_2 = vx_core.Class_length_2()

  fun f_length_2(valuemap : vx_core.Type_map) : vx_core.Type_int {
    var output : vx_core.Type_int = vx_core.e_int
    output = vx_core.f_length_1(
      vx_core.f_stringlist_from_map(
        valuemap
      )
    )
    return output
  }


  interface Func_let : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_let(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T
  }

  class Class_let : vx_core.Class_base, Func_let {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_let = vx_core.Class_let()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_let = vx_core.Class_let()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "let", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_let
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_let
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_let(generic_any_1, fn_any)
      return output
    }

    override fun <T : vx_core.Type_any> vx_let(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T {
      var output : T = vx_core.f_let(generic_any_1, fn_any)
      return output
    }

  }

  val e_let : vx_core.Func_let = vx_core.Class_let()
  val t_let : vx_core.Func_let = vx_core.Class_let()

  fun <T : vx_core.Type_any> f_let(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = fn_any.vx_any_from_func(generic_any_1)
    return output
  }


  interface Func_let_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <T : vx_core.Type_any> vx_let_async(generic_any_1 : T, fn_any_async : vx_core.Func_any_from_func_async) : CompletableFuture<T>
  }

  class Class_let_async : vx_core.Class_base, Func_let_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_let_async = vx_core.Class_let_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_let_async = vx_core.Class_let_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "let-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_let_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_let_async
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_async : vx_core.Func_any_from_func_async = vx_core.f_any_from_any(vx_core.t_any_from_func_async, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_let_async(generic_any_1, fn_any_async)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any> vx_let_async(generic_any_1 : T, fn_any_async : vx_core.Func_any_from_func_async) : CompletableFuture<T> {
      var output : CompletableFuture<T> = vx_core.f_let_async(generic_any_1, fn_any_async)
      return output
    }

  }

  val e_let_async : vx_core.Func_let_async = vx_core.Class_let_async()
  val t_let_async : vx_core.Func_let_async = vx_core.Class_let_async()

  fun <T : vx_core.Type_any> f_let_async(generic_any_1 : T, fn_any_async : vx_core.Func_any_from_func_async) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    output = fn_any_async.vx_any_from_func_async(generic_any_1)
    return output
  }


  interface Func_list_join_from_list : vx_core.Func_any_from_any {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_join_from_list(generic_list_1 : X, values : Y) : X
  }

  class Class_list_join_from_list : vx_core.Class_base, Func_list_join_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_join_from_list = vx_core.Class_list_join_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_join_from_list = vx_core.Class_list_join_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_join_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_join_from_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_list_join_from_list(vx_core.t_list, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_list_join_from_list(generic_list_1, values)
      return output
    }

    override fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_join_from_list(generic_list_1 : X, values : Y) : X {
      var output : X = vx_core.f_list_join_from_list(generic_list_1, values)
      return output
    }

  }

  val e_list_join_from_list : vx_core.Func_list_join_from_list = vx_core.Class_list_join_from_list()
  val t_list_join_from_list : vx_core.Func_list_join_from_list = vx_core.Class_list_join_from_list()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_join_from_list(generic_list_1 : X, values : Y) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.f_list_join_from_list_1(
      generic_list_1,
      values,
      vx_core.t_any_from_any.vx_fn_new({value_any : vx_core.Type_any ->
        var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = value
        output_1
      })
    )
    return output
  }


  interface Func_list_join_from_list_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_join_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X
  }

  class Class_list_join_from_list_1 : vx_core.Class_base, Func_list_join_from_list_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_join_from_list_1 = vx_core.Class_list_join_from_list_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_join_from_list_1 = vx_core.Class_list_join_from_list_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list-join<-list", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_join_from_list_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_join_from_list_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any : vx_core.Func_any_from_any = vx_core.f_any_from_any(vx_core.t_any_from_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_list_join_from_list_1(generic_list_1, values, fn_any_from_any)
      return output
    }

    override fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_join_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X {
      var output : X = vx_core.f_list_join_from_list_1(generic_list_1, values, fn_any_from_any)
      return output
    }

  }

  val e_list_join_from_list_1 : vx_core.Func_list_join_from_list_1 = vx_core.Class_list_join_from_list_1()
  val t_list_join_from_list_1 : vx_core.Func_list_join_from_list_1 = vx_core.Class_list_join_from_list_1()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_join_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.vx_list_join_from_list_1(generic_list_1, values, fn_any_from_any)
    return output
  }


  interface Func_list_from_list : vx_core.Func_any_from_any {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list(generic_list_1 : X, values : Y) : X
  }

  class Class_list_from_list : vx_core.Class_base, Func_list_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list = vx_core.Class_list_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list = vx_core.Class_list_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_list_from_list(vx_core.t_list, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_list_from_list(generic_list_1, values)
      return output
    }

    override fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list(generic_list_1 : X, values : Y) : X {
      var output : X = vx_core.f_list_from_list(generic_list_1, values)
      return output
    }

  }

  val e_list_from_list : vx_core.Func_list_from_list = vx_core.Class_list_from_list()
  val t_list_from_list : vx_core.Func_list_from_list = vx_core.Class_list_from_list()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_from_list(generic_list_1 : X, values : Y) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.f_list_from_list_1(
      generic_list_1,
      values,
      vx_core.t_any_from_any.vx_fn_new({value_any : vx_core.Type_any ->
        var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = value
        output_1
      })
    )
    return output
  }


  interface Func_list_from_list_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X
  }

  class Class_list_from_list_1 : vx_core.Class_base, Func_list_from_list_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list_1 = vx_core.Class_list_from_list_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list_1 = vx_core.Class_list_from_list_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-list", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_list_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_list_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any : vx_core.Func_any_from_any = vx_core.f_any_from_any(vx_core.t_any_from_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_list_from_list_1(generic_list_1, values, fn_any_from_any)
      return output
    }

    override fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X {
      var output : X = vx_core.f_list_from_list_1(generic_list_1, values, fn_any_from_any)
      return output
    }

  }

  val e_list_from_list_1 : vx_core.Func_list_from_list_1 = vx_core.Class_list_from_list_1()
  val t_list_from_list_1 : vx_core.Func_list_from_list_1 = vx_core.Class_list_from_list_1()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_from_list_1(generic_list_1 : X, values : Y, fn_any_from_any : vx_core.Func_any_from_any) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.vx_list_from_list_1(generic_list_1, values, fn_any_from_any)
    return output
  }


  interface Func_list_from_list_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_async(generic_list_1 : X, values : Y, fn_any_from_any_async : vx_core.Func_any_from_any_async) : CompletableFuture<X>
  }

  class Class_list_from_list_async : vx_core.Class_base, Func_list_from_list_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list_async = vx_core.Class_list_from_list_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list_async = vx_core.Class_list_from_list_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-list-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_list_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_list_async
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any_async : vx_core.Func_any_from_any_async = vx_core.f_any_from_any(vx_core.t_any_from_any_async, arglist.vx_any(vx_core.vx_new_int(1)))
      var future : CompletableFuture<vx_core.Type_list> = vx_core.f_list_from_list_async(generic_list_1, values, fn_any_from_any_async)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_async(generic_list_1 : X, values : Y, fn_any_from_any_async : vx_core.Func_any_from_any_async) : CompletableFuture<X> {
      var output : CompletableFuture<X> = vx_core.f_list_from_list_async(generic_list_1, values, fn_any_from_any_async)
      return output
    }

  }

  val e_list_from_list_async : vx_core.Func_list_from_list_async = vx_core.Class_list_from_list_async()
  val t_list_from_list_async : vx_core.Func_list_from_list_async = vx_core.Class_list_from_list_async()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_from_list_async(generic_list_1 : X, values : Y, fn_any_from_any_async : vx_core.Func_any_from_any_async) : CompletableFuture<X> {
    var output : CompletableFuture<X> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_list_1))
    output = vx_core.vx_list_from_list_async(generic_list_1, values, fn_any_from_any_async)
    return output
  }


  interface Func_list_from_list_intany : vx_core.Type_func, vx_core.Type_replfunc {
    fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_intany(generic_list_1 : X, values : Y, fn_any_from_int_any : vx_core.Func_any_from_int_any) : X
  }

  class Class_list_from_list_intany : vx_core.Class_base, Func_list_from_list_intany {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list_intany = vx_core.Class_list_from_list_intany()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_list_intany = vx_core.Class_list_from_list_intany()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-list-intany", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_list_intany
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_list_intany
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_int_any : vx_core.Func_any_from_int_any = vx_core.f_any_from_any(vx_core.t_any_from_int_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_list_from_list_intany(generic_list_1, values, fn_any_from_int_any)
      return output
    }

    override fun <X : vx_core.Type_list, Y : vx_core.Type_list> vx_list_from_list_intany(generic_list_1 : X, values : Y, fn_any_from_int_any : vx_core.Func_any_from_int_any) : X {
      var output : X = vx_core.f_list_from_list_intany(generic_list_1, values, fn_any_from_int_any)
      return output
    }

  }

  val e_list_from_list_intany : vx_core.Func_list_from_list_intany = vx_core.Class_list_from_list_intany()
  val t_list_from_list_intany : vx_core.Func_list_from_list_intany = vx_core.Class_list_from_list_intany()

  fun <X : vx_core.Type_list, Y : vx_core.Type_list> f_list_from_list_intany(generic_list_1 : X, values : Y, fn_any_from_int_any : vx_core.Func_any_from_int_any) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.vx_list_from_list_intany(generic_list_1, values, fn_any_from_int_any)
    return output
  }


  interface Func_list_from_map : vx_core.Func_any_from_any {
    fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map(generic_list_1 : X, valuemap : O) : X
  }

  class Class_list_from_map : vx_core.Class_base, Func_list_from_map {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_map = vx_core.Class_list_from_map()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_map = vx_core.Class_list_from_map()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_map
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_map = value as vx_core.Type_map
      var outputval : vx_core.Type_any = vx_core.f_list_from_map(vx_core.t_list, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_list_from_map(generic_list_1, valuemap)
      return output
    }

    override fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map(generic_list_1 : X, valuemap : O) : X {
      var output : X = vx_core.f_list_from_map(generic_list_1, valuemap)
      return output
    }

  }

  val e_list_from_map : vx_core.Func_list_from_map = vx_core.Class_list_from_map()
  val t_list_from_map : vx_core.Func_list_from_map = vx_core.Class_list_from_map()

  fun <O : vx_core.Type_map, X : vx_core.Type_list> f_list_from_map(generic_list_1 : X, valuemap : O) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.f_list_from_map_1(
      generic_list_1,
      valuemap,
      vx_core.t_any_from_key_value.vx_fn_new({key_any : vx_core.Type_any, value_any : vx_core.Type_any ->
        var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, key_any)
        var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = value
        output_1
      })
    )
    return output
  }


  interface Func_list_from_map_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map_1(generic_list_1 : X, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : X
  }

  class Class_list_from_map_1 : vx_core.Class_base, Func_list_from_map_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_map_1 = vx_core.Class_list_from_map_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_map_1 = vx_core.Class_list_from_map_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-map", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_map_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_map_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_key_value : vx_core.Func_any_from_key_value = vx_core.f_any_from_any(vx_core.t_any_from_key_value, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value)
      return output
    }

    override fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map_1(generic_list_1 : X, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : X {
      var output : X = vx_core.f_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value)
      return output
    }

  }

  val e_list_from_map_1 : vx_core.Func_list_from_map_1 = vx_core.Class_list_from_map_1()
  val t_list_from_map_1 : vx_core.Func_list_from_map_1 = vx_core.Class_list_from_map_1()

  fun <O : vx_core.Type_map, X : vx_core.Type_list> f_list_from_map_1(generic_list_1 : X, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.vx_list_from_map_1(generic_list_1, valuemap, fn_any_from_key_value)
    return output
  }


  interface Func_list_from_map_async : vx_core.Type_func, vx_core.Type_replfunc_async {
    fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map_async(generic_list_1 : X, valuemap : O, fn_any_from_key_value_async : vx_core.Func_any_from_key_value_async) : CompletableFuture<X>
  }

  class Class_list_from_map_async : vx_core.Class_base, Func_list_from_map_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_map_async = vx_core.Class_list_from_map_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_map_async = vx_core.Class_list_from_map_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-map-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_map_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_map_async
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_key_value_async : vx_core.Func_any_from_key_value_async = vx_core.f_any_from_any(vx_core.t_any_from_key_value_async, arglist.vx_any(vx_core.vx_new_int(1)))
      var future : CompletableFuture<vx_core.Type_list> = vx_core.f_list_from_map_async(generic_list_1, valuemap, fn_any_from_key_value_async)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <O : vx_core.Type_map, X : vx_core.Type_list> vx_list_from_map_async(generic_list_1 : X, valuemap : O, fn_any_from_key_value_async : vx_core.Func_any_from_key_value_async) : CompletableFuture<X> {
      var output : CompletableFuture<X> = vx_core.f_list_from_map_async(generic_list_1, valuemap, fn_any_from_key_value_async)
      return output
    }

  }

  val e_list_from_map_async : vx_core.Func_list_from_map_async = vx_core.Class_list_from_map_async()
  val t_list_from_map_async : vx_core.Func_list_from_map_async = vx_core.Class_list_from_map_async()

  fun <O : vx_core.Type_map, X : vx_core.Type_list> f_list_from_map_async(generic_list_1 : X, valuemap : O, fn_any_from_key_value_async : vx_core.Func_any_from_key_value_async) : CompletableFuture<X> {
    var output : CompletableFuture<X> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_list_1))
    return output
  }


  interface Func_list_from_type : vx_core.Func_any_from_any {
    fun vx_list_from_type(type : vx_core.Type_any) : vx_core.Type_any
  }

  class Class_list_from_type : vx_core.Class_base, Func_list_from_type {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_type = vx_core.Class_list_from_type()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_list_from_type = vx_core.Class_list_from_type()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "list<-type", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_list_from_type
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_list_from_type
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_list_from_type(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var type : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_list_from_type(type)
      return output
    }

    override fun vx_list_from_type(type : vx_core.Type_any) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.f_list_from_type(type)
      return output
    }

  }

  val e_list_from_type : vx_core.Func_list_from_type = vx_core.Class_list_from_type()
  val t_list_from_type : vx_core.Func_list_from_type = vx_core.Class_list_from_type()

  fun f_list_from_type(type : vx_core.Type_any) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    return output
  }


  interface Func_log : vx_core.Func_any_from_any {
    fun vx_log(value : vx_core.Type_any) : vx_core.Type_any
  }

  class Class_log : vx_core.Class_base, Func_log {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_log = vx_core.Class_log()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_log = vx_core.Class_log()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "log", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_log
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_log
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_log(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_log(value)
      return output
    }

    override fun vx_log(value : vx_core.Type_any) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.f_log(value)
      return output
    }

  }

  val e_log : vx_core.Func_log = vx_core.Class_log()
  val t_log : vx_core.Func_log = vx_core.Class_log()

  fun f_log(value : vx_core.Type_any) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    vx_core.vx_log(value)
    output = value
    return output
  }


  interface Func_log_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_log_1(generic_any_1 : T, text : vx_core.Type_string, value : T) : T
  }

  class Class_log_1 : vx_core.Class_base, Func_log_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_log_1 = vx_core.Class_log_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_log_1 = vx_core.Class_log_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "log", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_log_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_log_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_log_1(generic_any_1, text, value)
      return output
    }

    override fun <T : vx_core.Type_any> vx_log_1(generic_any_1 : T, text : vx_core.Type_string, value : T) : T {
      var output : T = vx_core.f_log_1(generic_any_1, text, value)
      return output
    }

  }

  val e_log_1 : vx_core.Func_log_1 = vx_core.Class_log_1()
  val t_log_1 : vx_core.Func_log_1 = vx_core.Class_log_1()

  fun <T : vx_core.Type_any> f_log_1(generic_any_1 : T, text : vx_core.Type_string, value : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    vx_core.vx_log(text)
    vx_core.vx_log(value)
    output = value
    return output
  }


  interface Func_main : vx_core.Func_any_from_any {
    fun vx_main(args : vx_core.Type_anylist) : vx_core.Type_string
  }

  class Class_main : vx_core.Class_base, Func_main {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_main = vx_core.Class_main()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_main = vx_core.Class_main()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "main", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_main
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_main
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_main(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var args : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_main(args)
      return output
    }

    override fun vx_main(args : vx_core.Type_anylist) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_main(args)
      return output
    }

  }

  val e_main : vx_core.Func_main = vx_core.Class_main()
  val t_main : vx_core.Func_main = vx_core.Class_main()

  fun f_main(args : vx_core.Type_anylist) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_new(
      vx_core.t_string,
      args
    )
    return output
  }


  interface Func_map_from_list : vx_core.Type_func, vx_core.Type_replfunc {
    fun <N : vx_core.Type_map, Y : vx_core.Type_list> vx_map_from_list(generic_map_1 : N, vallist : Y, fn_any_from_any : vx_core.Func_any_from_any) : N
  }

  class Class_map_from_list : vx_core.Class_base, Func_map_from_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_map_from_list = vx_core.Class_map_from_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_map_from_list = vx_core.Class_map_from_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "map<-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_map_from_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_map_from_list
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_map_1 : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var vallist : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_any : vx_core.Func_any_from_any = vx_core.f_any_from_any(vx_core.t_any_from_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_map_from_list(generic_map_1, vallist, fn_any_from_any)
      return output
    }

    override fun <N : vx_core.Type_map, Y : vx_core.Type_list> vx_map_from_list(generic_map_1 : N, vallist : Y, fn_any_from_any : vx_core.Func_any_from_any) : N {
      var output : N = vx_core.f_map_from_list(generic_map_1, vallist, fn_any_from_any)
      return output
    }

  }

  val e_map_from_list : vx_core.Func_map_from_list = vx_core.Class_map_from_list()
  val t_map_from_list : vx_core.Func_map_from_list = vx_core.Class_map_from_list()

  fun <N : vx_core.Type_map, Y : vx_core.Type_list> f_map_from_list(generic_map_1 : N, vallist : Y, fn_any_from_any : vx_core.Func_any_from_any) : N {
    var output : N = vx_core.f_empty(generic_map_1)
    output = vx_core.vx_map_from_list(generic_map_1, vallist, fn_any_from_any)
    return output
  }


  interface Func_map_from_map : vx_core.Func_any_from_any {
    fun <N : vx_core.Type_map, O : vx_core.Type_map> vx_map_from_map(generic_map_1 : N, valuemap : O) : N
  }

  class Class_map_from_map : vx_core.Class_base, Func_map_from_map {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_map_from_map = vx_core.Class_map_from_map()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_map_from_map = vx_core.Class_map_from_map()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_map_from_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_map_from_map
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_map = value as vx_core.Type_map
      var outputval : vx_core.Type_any = vx_core.f_map_from_map(vx_core.t_map, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_map_1 : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_map_from_map(generic_map_1, valuemap)
      return output
    }

    override fun <N : vx_core.Type_map, O : vx_core.Type_map> vx_map_from_map(generic_map_1 : N, valuemap : O) : N {
      var output : N = vx_core.f_map_from_map(generic_map_1, valuemap)
      return output
    }

  }

  val e_map_from_map : vx_core.Func_map_from_map = vx_core.Class_map_from_map()
  val t_map_from_map : vx_core.Func_map_from_map = vx_core.Class_map_from_map()

  fun <N : vx_core.Type_map, O : vx_core.Type_map> f_map_from_map(generic_map_1 : N, valuemap : O) : N {
    var output : N = vx_core.f_empty(generic_map_1)
    output = vx_core.f_map_from_map_1(
      generic_map_1,
      valuemap,
      vx_core.t_any_from_key_value.vx_fn_new({key_any : vx_core.Type_any, value_any : vx_core.Type_any ->
        var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, key_any)
        var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = value
        output_1
      })
    )
    return output
  }


  interface Func_map_from_map_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun <N : vx_core.Type_map, O : vx_core.Type_map> vx_map_from_map_1(generic_map_1 : N, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : N
  }

  class Class_map_from_map_1 : vx_core.Class_base, Func_map_from_map_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_map_from_map_1 = vx_core.Class_map_from_map_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_map_from_map_1 = vx_core.Class_map_from_map_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "map<-map", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "map-1", // name
          ":map", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_map_from_map_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_map_from_map_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_map_1 : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var valuemap : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any_from_key_value : vx_core.Func_any_from_key_value = vx_core.f_any_from_any(vx_core.t_any_from_key_value, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_map_from_map_1(generic_map_1, valuemap, fn_any_from_key_value)
      return output
    }

    override fun <N : vx_core.Type_map, O : vx_core.Type_map> vx_map_from_map_1(generic_map_1 : N, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : N {
      var output : N = vx_core.f_map_from_map_1(generic_map_1, valuemap, fn_any_from_key_value)
      return output
    }

  }

  val e_map_from_map_1 : vx_core.Func_map_from_map_1 = vx_core.Class_map_from_map_1()
  val t_map_from_map_1 : vx_core.Func_map_from_map_1 = vx_core.Class_map_from_map_1()

  fun <N : vx_core.Type_map, O : vx_core.Type_map> f_map_from_map_1(generic_map_1 : N, valuemap : O, fn_any_from_key_value : vx_core.Func_any_from_key_value) : N {
    var output : N = vx_core.f_empty(generic_map_1)
    output = vx_core.vx_map_from_map_fn(
      generic_map_1,
      valuemap,
      fn_any_from_key_value)
    return output
  }


  interface Func_msg_from_error : vx_core.Func_any_from_any {
    fun vx_msg_from_error(error : vx_core.Type_string) : vx_core.Type_msg
  }

  class Class_msg_from_error : vx_core.Class_base, Func_msg_from_error {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_error = vx_core.Class_msg_from_error()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_error = vx_core.Class_msg_from_error()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg_from_error
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg_from_error
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_msg_from_error(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var error : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_msg_from_error(error)
      return output
    }

    override fun vx_msg_from_error(error : vx_core.Type_string) : vx_core.Type_msg {
      var output : vx_core.Type_msg = vx_core.f_msg_from_error(error)
      return output
    }

  }

  val e_msg_from_error : vx_core.Func_msg_from_error = vx_core.Class_msg_from_error()
  val t_msg_from_error : vx_core.Func_msg_from_error = vx_core.Class_msg_from_error()

  fun f_msg_from_error(error : vx_core.Type_string) : vx_core.Type_msg {
    var output : vx_core.Type_msg = vx_core.e_msg
    output = vx_core.f_new(
      vx_core.t_msg,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":severity"),
        vx_core.c_msg_error,
        vx_core.vx_new_string(":text"),
        error
      )
    )
    return output
  }


  interface Func_msg_from_error_1 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_msg_from_error_1(code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg
  }

  class Class_msg_from_error_1 : vx_core.Class_base, Func_msg_from_error_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_error_1 = vx_core.Class_msg_from_error_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_error_1 = vx_core.Class_msg_from_error_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg_from_error_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg_from_error_1
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var code : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var detail : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_msg_from_error_1(code, detail)
      return output
    }

    override fun vx_msg_from_error_1(code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg {
      var output : vx_core.Type_msg = vx_core.f_msg_from_error_1(code, detail)
      return output
    }

  }

  val e_msg_from_error_1 : vx_core.Func_msg_from_error_1 = vx_core.Class_msg_from_error_1()
  val t_msg_from_error_1 : vx_core.Func_msg_from_error_1 = vx_core.Class_msg_from_error_1()

  fun f_msg_from_error_1(code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg {
    var output : vx_core.Type_msg = vx_core.e_msg
    output = vx_core.f_new(
      vx_core.t_msg,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        code,
        vx_core.vx_new_string(":detail"),
        detail,
        vx_core.vx_new_string(":severity"),
        vx_core.c_msg_error
      )
    )
    return output
  }


  interface Func_msg_from_error_2 : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_msg_from_error_2(path : vx_core.Type_string, code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg
  }

  class Class_msg_from_error_2 : vx_core.Class_base, Func_msg_from_error_2 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_error_2 = vx_core.Class_msg_from_error_2()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_error_2 = vx_core.Class_msg_from_error_2()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msg<-error", // name
        2, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg_from_error_2
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg_from_error_2
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var path : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var code : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var detail : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_msg_from_error_2(path, code, detail)
      return output
    }

    override fun vx_msg_from_error_2(path : vx_core.Type_string, code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg {
      var output : vx_core.Type_msg = vx_core.f_msg_from_error_2(path, code, detail)
      return output
    }

  }

  val e_msg_from_error_2 : vx_core.Func_msg_from_error_2 = vx_core.Class_msg_from_error_2()
  val t_msg_from_error_2 : vx_core.Func_msg_from_error_2 = vx_core.Class_msg_from_error_2()

  fun f_msg_from_error_2(path : vx_core.Type_string, code : vx_core.Type_string, detail : vx_core.Type_any) : vx_core.Type_msg {
    var output : vx_core.Type_msg = vx_core.e_msg
    output = vx_core.f_new(
      vx_core.t_msg,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        code,
        vx_core.vx_new_string(":path"),
        path,
        vx_core.vx_new_string(":severity"),
        vx_core.c_msg_error,
        vx_core.vx_new_string(":detail"),
        detail
      )
    )
    return output
  }


  interface Func_msg_from_warning : vx_core.Func_any_from_any {
    fun vx_msg_from_warning(warning : vx_core.Type_string) : vx_core.Type_msg
  }

  class Class_msg_from_warning : vx_core.Class_base, Func_msg_from_warning {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_warning = vx_core.Class_msg_from_warning()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msg_from_warning = vx_core.Class_msg_from_warning()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msg<-warning", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msg_from_warning
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msg_from_warning
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_msg_from_warning(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var warning : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_msg_from_warning(warning)
      return output
    }

    override fun vx_msg_from_warning(warning : vx_core.Type_string) : vx_core.Type_msg {
      var output : vx_core.Type_msg = vx_core.f_msg_from_warning(warning)
      return output
    }

  }

  val e_msg_from_warning : vx_core.Func_msg_from_warning = vx_core.Class_msg_from_warning()
  val t_msg_from_warning : vx_core.Func_msg_from_warning = vx_core.Class_msg_from_warning()

  fun f_msg_from_warning(warning : vx_core.Type_string) : vx_core.Type_msg {
    var output : vx_core.Type_msg = vx_core.e_msg
    output = vx_core.f_new(
      vx_core.t_msg,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":severity"),
        vx_core.c_msg_warning,
        vx_core.vx_new_string(":text"),
        warning
      )
    )
    return output
  }


  interface Func_msgblock_from_msgblock_msg : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_msgblock_from_msgblock_msg(origblock : vx_core.Type_msgblock, addmsg : vx_core.Type_msg) : vx_core.Type_msgblock
  }

  class Class_msgblock_from_msgblock_msg : vx_core.Class_base, Func_msgblock_from_msgblock_msg {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msgblock_from_msgblock_msg = vx_core.Class_msgblock_from_msgblock_msg()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msgblock_from_msgblock_msg = vx_core.Class_msgblock_from_msgblock_msg()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msg", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msgblock", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msgblock_from_msgblock_msg
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msgblock_from_msgblock_msg
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var origblock : vx_core.Type_msgblock = vx_core.f_any_from_any(vx_core.t_msgblock, arglist.vx_any(vx_core.vx_new_int(0)))
      var addmsg : vx_core.Type_msg = vx_core.f_any_from_any(vx_core.t_msg, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_msgblock_from_msgblock_msg(origblock, addmsg)
      return output
    }

    override fun vx_msgblock_from_msgblock_msg(origblock : vx_core.Type_msgblock, addmsg : vx_core.Type_msg) : vx_core.Type_msgblock {
      var output : vx_core.Type_msgblock = vx_core.f_msgblock_from_msgblock_msg(origblock, addmsg)
      return output
    }

  }

  val e_msgblock_from_msgblock_msg : vx_core.Func_msgblock_from_msgblock_msg = vx_core.Class_msgblock_from_msgblock_msg()
  val t_msgblock_from_msgblock_msg : vx_core.Func_msgblock_from_msgblock_msg = vx_core.Class_msgblock_from_msgblock_msg()

  fun f_msgblock_from_msgblock_msg(origblock : vx_core.Type_msgblock, addmsg : vx_core.Type_msg) : vx_core.Type_msgblock {
    var output : vx_core.Type_msgblock = vx_core.e_msgblock
    output = vx_core.f_copy(
      origblock,
      vx_core.vx_new(
        vx_core.t_anylist,
        addmsg
      )
    )
    return output
  }


  interface Func_msgblock_from_msgblock_msgblock : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_msgblock_from_msgblock_msgblock(origblock : vx_core.Type_msgblock, addblock : vx_core.Type_msgblock) : vx_core.Type_msgblock
  }

  class Class_msgblock_from_msgblock_msgblock : vx_core.Class_base, Func_msgblock_from_msgblock_msgblock {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msgblock_from_msgblock_msgblock = vx_core.Class_msgblock_from_msgblock_msgblock()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_msgblock_from_msgblock_msgblock = vx_core.Class_msgblock_from_msgblock_msgblock()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "msgblock<-msgblock-msgblock", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "msgblock", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_msgblock_from_msgblock_msgblock
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_msgblock_from_msgblock_msgblock
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var origblock : vx_core.Type_msgblock = vx_core.f_any_from_any(vx_core.t_msgblock, arglist.vx_any(vx_core.vx_new_int(0)))
      var addblock : vx_core.Type_msgblock = vx_core.f_any_from_any(vx_core.t_msgblock, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_msgblock_from_msgblock_msgblock(origblock, addblock)
      return output
    }

    override fun vx_msgblock_from_msgblock_msgblock(origblock : vx_core.Type_msgblock, addblock : vx_core.Type_msgblock) : vx_core.Type_msgblock {
      var output : vx_core.Type_msgblock = vx_core.f_msgblock_from_msgblock_msgblock(origblock, addblock)
      return output
    }

  }

  val e_msgblock_from_msgblock_msgblock : vx_core.Func_msgblock_from_msgblock_msgblock = vx_core.Class_msgblock_from_msgblock_msgblock()
  val t_msgblock_from_msgblock_msgblock : vx_core.Func_msgblock_from_msgblock_msgblock = vx_core.Class_msgblock_from_msgblock_msgblock()

  fun f_msgblock_from_msgblock_msgblock(origblock : vx_core.Type_msgblock, addblock : vx_core.Type_msgblock) : vx_core.Type_msgblock {
    var output : vx_core.Type_msgblock = vx_core.e_msgblock
    output = vx_core.f_new(
      vx_core.t_msgblock,
      vx_core.vx_new(
        vx_core.t_anylist,
        origblock,
        addblock
      )
    )
    return output
  }


  interface Func_name_from_typedef : vx_core.Func_any_from_any {
    fun vx_name_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string
  }

  class Class_name_from_typedef : vx_core.Class_base, Func_name_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_name_from_typedef = vx_core.Class_name_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_name_from_typedef = vx_core.Class_name_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "name<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_name_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_name_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_name_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_name_from_typedef(vtypedef)
      return output
    }

    override fun vx_name_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_name_from_typedef(vtypedef)
      return output
    }

  }

  val e_name_from_typedef : vx_core.Func_name_from_typedef = vx_core.Class_name_from_typedef()
  val t_name_from_typedef : vx_core.Func_name_from_typedef = vx_core.Class_name_from_typedef()

  fun f_name_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vtypedef.name()
    return output
  }


  interface Func_native : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_native(generic_any_1 : T, clauses : vx_core.Type_anylist) : T
  }

  class Class_native : vx_core.Class_base, Func_native {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_native = vx_core.Class_native()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_native = vx_core.Class_native()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "native", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_native
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_native
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_native(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var clauses : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_native(generic_any_1, clauses)
      return output
    }

    override fun <T : vx_core.Type_any> vx_native(generic_any_1 : T, clauses : vx_core.Type_anylist) : T {
      var output : T = vx_core.f_native(generic_any_1, clauses)
      return output
    }

  }

  val e_native : vx_core.Func_native = vx_core.Class_native()
  val t_native : vx_core.Func_native = vx_core.Class_native()

  fun <T : vx_core.Type_any> f_native(generic_any_1 : T, clauses : vx_core.Type_anylist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    return output
  }


  interface Func_native_from_any : vx_core.Func_any_from_any {
    fun vx_native_from_any(value : vx_core.Type_any) : vx_core.Type_any
  }

  class Class_native_from_any : vx_core.Class_base, Func_native_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_native_from_any = vx_core.Class_native_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_native_from_any = vx_core.Class_native_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "native<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_native_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_native_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_native_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_native_from_any(value)
      return output
    }

    override fun vx_native_from_any(value : vx_core.Type_any) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.f_native_from_any(value)
      return output
    }

  }

  val e_native_from_any : vx_core.Func_native_from_any = vx_core.Class_native_from_any()
  val t_native_from_any : vx_core.Func_native_from_any = vx_core.Class_native_from_any()

  fun f_native_from_any(value : vx_core.Type_any) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    return output
  }


  interface Func_new : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_new(generic_any_1 : T, values : vx_core.Type_anylist) : T
  }

  class Class_new : vx_core.Class_base, Func_new {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_new = vx_core.Class_new()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_new = vx_core.Class_new()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "new", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_new
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_new
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_anylist = value as vx_core.Type_anylist
      var outputval : vx_core.Type_any = vx_core.f_new(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_new(generic_any_1, values)
      return output
    }

    override fun <T : vx_core.Type_any> vx_new(generic_any_1 : T, values : vx_core.Type_anylist) : T {
      var output : T = vx_core.f_new(generic_any_1, values)
      return output
    }

  }

  val e_new : vx_core.Func_new = vx_core.Class_new()
  val t_new : vx_core.Func_new = vx_core.Class_new()

  fun <T : vx_core.Type_any> f_new(generic_any_1 : T, values : vx_core.Type_anylist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    val arrayany : Array<vx_core.Type_any> = vx_core.arrayany_from_anylist(
      values
    )
    val anyvalue : vx_core.Type_any = generic_any_1.vx_new(*arrayany)
    output = anyvalue as T
    return output
  }


  interface Func_new_from_type : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any> vx_new_from_type(type : T, values : vx_core.Type_anylist) : T
  }

  class Class_new_from_type : vx_core.Class_base, Func_new_from_type {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_new_from_type = vx_core.Class_new_from_type()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_new_from_type = vx_core.Class_new_from_type()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "new<-type", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_new_from_type
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_new_from_type
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var type : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var values : vx_core.Type_anylist = vx_core.f_any_from_any(vx_core.t_anylist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_new_from_type(type, values)
      return output
    }

    override fun <T : vx_core.Type_any> vx_new_from_type(type : T, values : vx_core.Type_anylist) : T {
      var output : T = vx_core.f_new_from_type(type, values)
      return output
    }

  }

  val e_new_from_type : vx_core.Func_new_from_type = vx_core.Class_new_from_type()
  val t_new_from_type : vx_core.Func_new_from_type = vx_core.Class_new_from_type()

  fun <T : vx_core.Type_any> f_new_from_type(type : T, values : vx_core.Type_anylist) : T {
    val arrayany : Array<vx_core.Type_any> = vx_core.arrayany_from_anylist(
      values
    )
    val anyvalue : vx_core.Type_any = type.vx_new(*arrayany)
    val output : T = anyvalue as T
    return output
  }


  interface Func_number_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_number_from_func() : vx_core.Type_number
  }

  class Class_number_from_func : vx_core.Class_base, Func_number_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_number_from_func = vx_core.Class_number_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_number_from_func = vx_core.Class_number_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "number<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "number", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_int, vx_core.t_float, vx_core.t_decimal), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_number_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_number_from_func
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_number_from_func()
      return output
    }

    override fun vx_number_from_func() : vx_core.Type_number {
      var output : vx_core.Type_number = vx_core.f_number_from_func()
      return output
    }

  }

  val e_number_from_func : vx_core.Func_number_from_func = vx_core.Class_number_from_func()
  val t_number_from_func : vx_core.Func_number_from_func = vx_core.Class_number_from_func()

  fun f_number_from_func() : vx_core.Type_number {
    var output : vx_core.Type_number = vx_core.e_number
    return output
  }


  interface Func_or : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_or(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean
  }

  class Class_or : vx_core.Class_base, Func_or {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_or = vx_core.Class_or()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_or = vx_core.Class_or()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "or", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_or
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_or
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var val1 : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(0)))
      var val2 : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_or(val1, val2)
      return output
    }

    override fun vx_or(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_or(val1, val2)
      return output
    }

  }

  val e_or : vx_core.Func_or = vx_core.Class_or()
  val t_or : vx_core.Func_or = vx_core.Class_or()

  fun f_or(val1 : vx_core.Type_boolean, val2 : vx_core.Type_boolean) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    if (val1.vx_boolean() || val2.vx_boolean()) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }
    return output
  }


  interface Func_or_1 : vx_core.Func_any_from_any {
    fun vx_or_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean
  }

  class Class_or_1 : vx_core.Class_base, Func_or_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_or_1 = vx_core.Class_or_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_or_1 = vx_core.Class_or_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "or", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "boolean", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_or_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_or_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_booleanlist = value as vx_core.Type_booleanlist
      var outputval : vx_core.Type_any = vx_core.f_or_1(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var values : vx_core.Type_booleanlist = vx_core.f_any_from_any(vx_core.t_booleanlist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_or_1(values)
      return output
    }

    override fun vx_or_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean {
      var output : vx_core.Type_boolean = vx_core.f_or_1(values)
      return output
    }

  }

  val e_or_1 : vx_core.Func_or_1 = vx_core.Class_or_1()
  val t_or_1 : vx_core.Func_or_1 = vx_core.Class_or_1()

  fun f_or_1(values : vx_core.Type_booleanlist) : vx_core.Type_boolean {
    var output : vx_core.Type_boolean = vx_core.e_boolean
    output = vx_core.f_any_from_list_start_reduce_next(
      vx_core.t_boolean,
      values,
      vx_core.vx_new_boolean(false),
      vx_core.t_any_from_reduce_next.vx_fn_new({reduce_any : vx_core.Type_any, current_any : vx_core.Type_any, next_any : vx_core.Type_any ->
        var reduce : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, reduce_any)
        var current : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, current_any)
        var next : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, next_any)
        var output_1 : vx_core.Type_any = vx_core.f_or(
          reduce,
          vx_core.f_or(
            current,
            next
          )
        )
        output_1
      })
    )
    return output
  }


  interface Func_package_global_from_name : vx_core.Func_any_from_any {
    fun vx_package_global_from_name(name : vx_core.Type_string) : vx_core.Type_package
  }

  class Class_package_global_from_name : vx_core.Class_base, Func_package_global_from_name {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_package_global_from_name = vx_core.Class_package_global_from_name()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_package_global_from_name = vx_core.Class_package_global_from_name()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "package-global<-name", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "package", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_package_global_from_name
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_package_global_from_name
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_package_global_from_name(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var name : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_package_global_from_name(name)
      return output
    }

    override fun vx_package_global_from_name(name : vx_core.Type_string) : vx_core.Type_package {
      var output : vx_core.Type_package = vx_core.f_package_global_from_name(name)
      return output
    }

  }

  val e_package_global_from_name : vx_core.Func_package_global_from_name = vx_core.Class_package_global_from_name()
  val t_package_global_from_name : vx_core.Func_package_global_from_name = vx_core.Class_package_global_from_name()

  fun f_package_global_from_name(name : vx_core.Type_string) : vx_core.Type_package {
    var output : vx_core.Type_package = vx_core.e_package
    output = vx_core.f_any_from_map(
      vx_core.t_package,
      vx_core.c_global.packagemap(),
      name
    )
    return output
  }


  interface Func_packagename_from_typedef : vx_core.Func_any_from_any {
    fun vx_packagename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string
  }

  class Class_packagename_from_typedef : vx_core.Class_base, Func_packagename_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_packagename_from_typedef = vx_core.Class_packagename_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_packagename_from_typedef = vx_core.Class_packagename_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "packagename<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_packagename_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_packagename_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_packagename_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_packagename_from_typedef(vtypedef)
      return output
    }

    override fun vx_packagename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_packagename_from_typedef(vtypedef)
      return output
    }

  }

  val e_packagename_from_typedef : vx_core.Func_packagename_from_typedef = vx_core.Class_packagename_from_typedef()
  val t_packagename_from_typedef : vx_core.Func_packagename_from_typedef = vx_core.Class_packagename_from_typedef()

  fun f_packagename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vtypedef.pkgname()
    return output
  }


  interface Func_path_from_context_path : vx_core.Func_any_from_any_context {
    fun vx_path_from_context_path(context : vx_core.Type_context, path : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_path_from_context_path : vx_core.Class_base, Func_path_from_context_path {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_path_from_context_path = vx_core.Class_path_from_context_path()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_path_from_context_path = vx_core.Class_path_from_context_path()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "path<-context-path", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_path_from_context_path
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_path_from_context_path
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      return vx_core.e_any_from_any_context
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_path_from_context_path(context, inputval)
      output = vx_core.f_any_from_any_context(generic_any_1, context, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var path : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_path_from_context_path(context, path)
      return output
    }

    override fun vx_path_from_context_path(context : vx_core.Type_context, path : vx_core.Type_string) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_path_from_context_path(context, path)
      return output
    }

  }

  val e_path_from_context_path : vx_core.Func_path_from_context_path = vx_core.Class_path_from_context_path()
  val t_path_from_context_path : vx_core.Func_path_from_context_path = vx_core.Class_path_from_context_path()

  fun f_path_from_context_path(context : vx_core.Type_context, path : vx_core.Type_string) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_path_from_setting_path(
      vx_core.f_setting_from_context(
        context
      ),
      path
    )
    return output
  }


  interface Func_path_from_setting_path : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_path_from_setting_path(session : vx_core.Type_setting, path : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_path_from_setting_path : vx_core.Class_base, Func_path_from_setting_path {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_path_from_setting_path = vx_core.Class_path_from_setting_path()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_path_from_setting_path = vx_core.Class_path_from_setting_path()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "path<-setting-path", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_path_from_setting_path
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_path_from_setting_path
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var session : vx_core.Type_setting = vx_core.f_any_from_any(vx_core.t_setting, arglist.vx_any(vx_core.vx_new_int(0)))
      var path : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_path_from_setting_path(session, path)
      return output
    }

    override fun vx_path_from_setting_path(session : vx_core.Type_setting, path : vx_core.Type_string) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_path_from_setting_path(session, path)
      return output
    }

  }

  val e_path_from_setting_path : vx_core.Func_path_from_setting_path = vx_core.Class_path_from_setting_path()
  val t_path_from_setting_path : vx_core.Func_path_from_setting_path = vx_core.Class_path_from_setting_path()

  fun f_path_from_setting_path(session : vx_core.Type_setting, path : vx_core.Type_string) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    return output
  }


  interface Func_permission_from_id_context : vx_core.Func_any_from_any_context {
    fun vx_permission_from_id_context(context : vx_core.Type_context, id : vx_core.Type_string) : vx_core.Type_permission
  }

  class Class_permission_from_id_context : vx_core.Class_base, Func_permission_from_id_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_permission_from_id_context = vx_core.Class_permission_from_id_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_permission_from_id_context = vx_core.Class_permission_from_id_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "permission<-id-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "permission", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_permission_from_id_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_permission_from_id_context
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_context.IFn) : vx_core.Func_any_from_any_context {
      return vx_core.e_any_from_any_context
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_context(generic_any_1 : T, context : vx_core.Type_context, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_string = value as vx_core.Type_string
      var outputval : vx_core.Type_any = vx_core.f_permission_from_id_context(context, inputval)
      output = vx_core.f_any_from_any_context(generic_any_1, context, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      var id : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_permission_from_id_context(context, id)
      return output
    }

    override fun vx_permission_from_id_context(context : vx_core.Type_context, id : vx_core.Type_string) : vx_core.Type_permission {
      var output : vx_core.Type_permission = vx_core.f_permission_from_id_context(context, id)
      return output
    }

  }

  val e_permission_from_id_context : vx_core.Func_permission_from_id_context = vx_core.Class_permission_from_id_context()
  val t_permission_from_id_context : vx_core.Func_permission_from_id_context = vx_core.Class_permission_from_id_context()

  fun f_permission_from_id_context(context : vx_core.Type_context, id : vx_core.Type_string) : vx_core.Type_permission {
    var output : vx_core.Type_permission = vx_core.e_permission
    output = vx_core.f_let(
      vx_core.t_permission,
      vx_core.t_any_from_func.vx_fn_new({ ->
        var user : vx_core.Type_user = vx_core.f_user_from_context(
          context
        )
        var security : vx_core.Type_security = user.security()
        var permissionmap : vx_core.Type_permissionmap = security.permissionmap()
        var output_1 : vx_core.Type_any = vx_core.f_any_from_map(
          vx_core.t_permission,
          permissionmap,
          vx_core.vx_new_string(":id")
        )
        output_1
      })
    )
    return output
  }


  interface Func_properties_from_typedef : vx_core.Func_any_from_any {
    fun vx_properties_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_argmap
  }

  class Class_properties_from_typedef : vx_core.Class_base, Func_properties_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_properties_from_typedef = vx_core.Class_properties_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_properties_from_typedef = vx_core.Class_properties_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "properties<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "argmap", // name
          ":map", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_arg), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_properties_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_properties_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_properties_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_properties_from_typedef(vtypedef)
      return output
    }

    override fun vx_properties_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_argmap {
      var output : vx_core.Type_argmap = vx_core.f_properties_from_typedef(vtypedef)
      return output
    }

  }

  val e_properties_from_typedef : vx_core.Func_properties_from_typedef = vx_core.Class_properties_from_typedef()
  val t_properties_from_typedef : vx_core.Func_properties_from_typedef = vx_core.Class_properties_from_typedef()

  fun f_properties_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_argmap {
    var output : vx_core.Type_argmap = vx_core.e_argmap
    output = vtypedef.properties()
    return output
  }


  interface Func_proplast_from_typedef : vx_core.Func_any_from_any {
    fun vx_proplast_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_arg
  }

  class Class_proplast_from_typedef : vx_core.Class_base, Func_proplast_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_proplast_from_typedef = vx_core.Class_proplast_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_proplast_from_typedef = vx_core.Class_proplast_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "proplast<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "arg", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_proplast_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_proplast_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_proplast_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_proplast_from_typedef(vtypedef)
      return output
    }

    override fun vx_proplast_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_arg {
      var output : vx_core.Type_arg = vx_core.f_proplast_from_typedef(vtypedef)
      return output
    }

  }

  val e_proplast_from_typedef : vx_core.Func_proplast_from_typedef = vx_core.Class_proplast_from_typedef()
  val t_proplast_from_typedef : vx_core.Func_proplast_from_typedef = vx_core.Class_proplast_from_typedef()

  fun f_proplast_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_arg {
    var output : vx_core.Type_arg = vx_core.e_arg
    output = vtypedef.proplast()
    return output
  }


  interface Func_resolve : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_resolve(generic_any_1 : T, value : T) : T
  }

  class Class_resolve : vx_core.Class_base, Func_resolve {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve = vx_core.Class_resolve()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve = vx_core.Class_resolve()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_resolve(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_resolve(generic_any_1, value)
      return output
    }

    override fun <T : vx_core.Type_any> vx_resolve(generic_any_1 : T, value : T) : T {
      var output : T = vx_core.f_resolve(generic_any_1, value)
      return output
    }

  }

  val e_resolve : vx_core.Func_resolve = vx_core.Class_resolve()
  val t_resolve : vx_core.Func_resolve = vx_core.Class_resolve()

  fun <T : vx_core.Type_any> f_resolve(generic_any_1 : T, value : T) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = value
    return output
  }


  interface Func_resolve_1 : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any> vx_resolve_1(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T
  }

  class Class_resolve_1 : vx_core.Class_base, Func_resolve_1 {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_1 = vx_core.Class_resolve_1()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_1 = vx_core.Class_resolve_1()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve", // name
        1, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve_1
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve_1
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Func_any_from_func = value as vx_core.Func_any_from_func
      var outputval : vx_core.Type_any = vx_core.f_resolve_1(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_resolve_1(generic_any_1, fn_any)
      return output
    }

    override fun <T : vx_core.Type_any> vx_resolve_1(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T {
      var output : T = vx_core.f_resolve_1(generic_any_1, fn_any)
      return output
    }

  }

  val e_resolve_1 : vx_core.Func_resolve_1 = vx_core.Class_resolve_1()
  val t_resolve_1 : vx_core.Func_resolve_1 = vx_core.Class_resolve_1()

  fun <T : vx_core.Type_any> f_resolve_1(generic_any_1 : T, fn_any : vx_core.Func_any_from_func) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    if (fn_any == null) {
    } else if (fn_any == vx_core.e_any_from_func) {
    } else {
      output = fn_any.vx_any_from_func(generic_any_1)
    }
    return output
  }


  interface Func_resolve_async : vx_core.Func_any_from_any_async {
    fun <T : vx_core.Type_any> vx_resolve_async(generic_any_1 : T, fn_any : vx_core.Func_any_from_func_async) : CompletableFuture<T>
  }

  class Class_resolve_async : vx_core.Class_base, Func_resolve_async {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_async = vx_core.Class_resolve_async()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_async = vx_core.Class_resolve_async()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve-async", // name
        0, // idx
        true, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve_async
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve_async
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any_async.IFn) : vx_core.Func_any_from_any_async {
      return vx_core.e_any_from_any_async
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any_async(generic_any_1 : T, value : U) : CompletableFuture<T> {
      var inputval : T = vx_core.f_any_from_any(generic_any_1, value)
      var output : CompletableFuture<T> = vx_core.f_async(generic_any_1, inputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : CompletableFuture<vx_core.Type_any> {
      var output : CompletableFuture<vx_core.Type_any> = vx_core.vx_async_new_from_value(vx_core.e_any)
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func_async = vx_core.f_any_from_any(vx_core.t_any_from_func_async, arglist.vx_any(vx_core.vx_new_int(0)))
      var future : CompletableFuture<vx_core.Type_any> = vx_core.f_resolve_async(generic_any_1, fn_any)
      output = vx_core.vx_async_from_async(vx_core.t_any, future)
      return output
    }

    override fun <T : vx_core.Type_any> vx_resolve_async(generic_any_1 : T, fn_any : vx_core.Func_any_from_func_async) : CompletableFuture<T> {
      var output : CompletableFuture<T> = vx_core.f_resolve_async(generic_any_1, fn_any)
      return output
    }

  }

  val e_resolve_async : vx_core.Func_resolve_async = vx_core.Class_resolve_async()
  val t_resolve_async : vx_core.Func_resolve_async = vx_core.Class_resolve_async()

  fun <T : vx_core.Type_any> f_resolve_async(generic_any_1 : T, fn_any : vx_core.Func_any_from_func_async) : CompletableFuture<T> {
    var output : CompletableFuture<T> = vx_core.vx_async_new_from_value(vx_core.f_empty(generic_any_1))
    if (fn_any == null) {
    } else if (fn_any == vx_core.e_any_from_func_async) {
    } else {
      output = fn_any.vx_any_from_func_async(generic_any_1)
    }
    return output
  }


  interface Func_resolve_first : vx_core.Func_any_from_any {
    fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_resolve_first(generic_any_1 : T, clauses : X) : T
  }

  class Class_resolve_first : vx_core.Class_base, Func_resolve_first {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_first = vx_core.Class_resolve_first()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_first = vx_core.Class_resolve_first()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve-first", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve_first
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve_first
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_resolve_first(vx_core.t_any, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var clauses : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_resolve_first(generic_any_1, clauses)
      return output
    }

    override fun <T : vx_core.Type_any, X : vx_core.Type_list> vx_resolve_first(generic_any_1 : T, clauses : X) : T {
      var output : T = vx_core.f_resolve_first(generic_any_1, clauses)
      return output
    }

  }

  val e_resolve_first : vx_core.Func_resolve_first = vx_core.Class_resolve_first()
  val t_resolve_first : vx_core.Func_resolve_first = vx_core.Class_resolve_first()

  fun <T : vx_core.Type_any, X : vx_core.Type_list> f_resolve_first(generic_any_1 : T, clauses : X) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.f_first_from_list_any_from_any(
      generic_any_1,
      clauses,
      vx_core.t_resolve
    )
    return output
  }


  interface Func_resolve_list : vx_core.Func_any_from_any {
    fun <X : vx_core.Type_list> vx_resolve_list(generic_list_1 : X, clauses : X) : X
  }

  class Class_resolve_list : vx_core.Class_base, Func_resolve_list {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_list = vx_core.Class_resolve_list()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_resolve_list = vx_core.Class_resolve_list()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "resolve-list", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "list-1", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_resolve_list
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_resolve_list
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_list = value as vx_core.Type_list
      var outputval : vx_core.Type_any = vx_core.f_resolve_list(vx_core.t_list, inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_list_1 : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      var clauses : vx_core.Type_list = vx_core.f_any_from_any(vx_core.t_list, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_resolve_list(generic_list_1, clauses)
      return output
    }

    override fun <X : vx_core.Type_list> vx_resolve_list(generic_list_1 : X, clauses : X) : X {
      var output : X = vx_core.f_resolve_list(generic_list_1, clauses)
      return output
    }

  }

  val e_resolve_list : vx_core.Func_resolve_list = vx_core.Class_resolve_list()
  val t_resolve_list : vx_core.Func_resolve_list = vx_core.Class_resolve_list()

  fun <X : vx_core.Type_list> f_resolve_list(generic_list_1 : X, clauses : X) : X {
    var output : X = vx_core.f_empty(generic_list_1)
    output = vx_core.f_list_from_list_1(
      generic_list_1,
      clauses,
      vx_core.t_resolve
    )
    return output
  }


  interface Func_security_from_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_security_from_context(context : vx_core.Type_context) : vx_core.Type_security
  }

  class Class_security_from_context : vx_core.Class_base, Func_security_from_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_security_from_context = vx_core.Class_security_from_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_security_from_context = vx_core.Class_security_from_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "security<-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "security", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_security_from_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_security_from_context
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_security_from_context(context)
      return output
    }

    override fun vx_security_from_context(context : vx_core.Type_context) : vx_core.Type_security {
      var output : vx_core.Type_security = vx_core.f_security_from_context(context)
      return output
    }

  }

  val e_security_from_context : vx_core.Func_security_from_context = vx_core.Class_security_from_context()
  val t_security_from_context : vx_core.Func_security_from_context = vx_core.Class_security_from_context()

  fun f_security_from_context(context : vx_core.Type_context) : vx_core.Type_security {
    var output : vx_core.Type_security = vx_core.e_security
    output = vx_core.f_security_from_user(
      vx_core.f_user_from_context(
        context
      )
    )
    return output
  }


  interface Func_security_from_user : vx_core.Func_any_from_any {
    fun vx_security_from_user(user : vx_core.Type_user) : vx_core.Type_security
  }

  class Class_security_from_user : vx_core.Class_base, Func_security_from_user {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_security_from_user = vx_core.Class_security_from_user()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_security_from_user = vx_core.Class_security_from_user()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "security<-user", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "security", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_security_from_user
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_security_from_user
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_user = value as vx_core.Type_user
      var outputval : vx_core.Type_any = vx_core.f_security_from_user(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var user : vx_core.Type_user = vx_core.f_any_from_any(vx_core.t_user, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_security_from_user(user)
      return output
    }

    override fun vx_security_from_user(user : vx_core.Type_user) : vx_core.Type_security {
      var output : vx_core.Type_security = vx_core.f_security_from_user(user)
      return output
    }

  }

  val e_security_from_user : vx_core.Func_security_from_user = vx_core.Class_security_from_user()
  val t_security_from_user : vx_core.Func_security_from_user = vx_core.Class_security_from_user()

  fun f_security_from_user(user : vx_core.Type_user) : vx_core.Type_security {
    var output : vx_core.Type_security = vx_core.e_security
    output = user.security()
    return output
  }


  interface Func_session_from_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_session_from_context(context : vx_core.Type_context) : vx_core.Type_session
  }

  class Class_session_from_context : vx_core.Class_base, Func_session_from_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_session_from_context = vx_core.Class_session_from_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_session_from_context = vx_core.Class_session_from_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "session<-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "session", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_session_from_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_session_from_context
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_session_from_context(context)
      return output
    }

    override fun vx_session_from_context(context : vx_core.Type_context) : vx_core.Type_session {
      var output : vx_core.Type_session = vx_core.f_session_from_context(context)
      return output
    }

  }

  val e_session_from_context : vx_core.Func_session_from_context = vx_core.Class_session_from_context()
  val t_session_from_context : vx_core.Func_session_from_context = vx_core.Class_session_from_context()

  fun f_session_from_context(context : vx_core.Type_context) : vx_core.Type_session {
    var output : vx_core.Type_session = vx_core.e_session
    output = context.session()
    return output
  }


  interface Func_setting_from_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_setting_from_context(context : vx_core.Type_context) : vx_core.Type_setting
  }

  class Class_setting_from_context : vx_core.Class_base, Func_setting_from_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_setting_from_context = vx_core.Class_setting_from_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_setting_from_context = vx_core.Class_setting_from_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "setting<-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "setting", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_setting_from_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_setting_from_context
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_setting_from_context(context)
      return output
    }

    override fun vx_setting_from_context(context : vx_core.Type_context) : vx_core.Type_setting {
      var output : vx_core.Type_setting = vx_core.f_setting_from_context(context)
      return output
    }

  }

  val e_setting_from_context : vx_core.Func_setting_from_context = vx_core.Class_setting_from_context()
  val t_setting_from_context : vx_core.Func_setting_from_context = vx_core.Class_setting_from_context()

  fun f_setting_from_context(context : vx_core.Type_context) : vx_core.Type_setting {
    var output : vx_core.Type_setting = vx_core.e_setting
    output = context.setting()
    return output
  }


  interface Func_string_repeat : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_string_repeat(text : vx_core.Type_string, repeat : vx_core.Type_int) : vx_core.Type_string
  }

  class Class_string_repeat : vx_core.Class_base, Func_string_repeat {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_repeat = vx_core.Class_string_repeat()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_repeat = vx_core.Class_string_repeat()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string-repeat", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_repeat
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_repeat
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var repeat : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_string_repeat(text, repeat)
      return output
    }

    override fun vx_string_repeat(text : vx_core.Type_string, repeat : vx_core.Type_int) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_string_repeat(text, repeat)
      return output
    }

  }

  val e_string_repeat : vx_core.Func_string_repeat = vx_core.Class_string_repeat()
  val t_string_repeat : vx_core.Func_string_repeat = vx_core.Class_string_repeat()

  fun f_string_repeat(text : vx_core.Type_string, repeat : vx_core.Type_int) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.vx_string_repeat(text, repeat)
    return output
  }


  interface Func_string_from_any : vx_core.Func_any_from_any {
    fun vx_string_from_any(value : vx_core.Type_any) : vx_core.Type_string
  }

  class Class_string_from_any : vx_core.Class_base, Func_string_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_any = vx_core.Class_string_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_any = vx_core.Class_string_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_string_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_string_from_any(value)
      return output
    }

    override fun vx_string_from_any(value : vx_core.Type_any) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_string_from_any(value)
      return output
    }

  }

  val e_string_from_any : vx_core.Func_string_from_any = vx_core.Class_string_from_any()
  val t_string_from_any : vx_core.Func_string_from_any = vx_core.Class_string_from_any()

  fun f_string_from_any(value : vx_core.Type_any) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_string_from_any_indent(
      value,
      vx_core.vx_new_int(0),
      vx_core.vx_new_boolean(true)
    )
    return output
  }


  interface Func_string_from_any_indent : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_string_from_any_indent(value : vx_core.Type_any, indent : vx_core.Type_int, linefeed : vx_core.Type_boolean) : vx_core.Type_string
  }

  class Class_string_from_any_indent : vx_core.Class_base, Func_string_from_any_indent {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_any_indent = vx_core.Class_string_from_any_indent()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_any_indent = vx_core.Class_string_from_any_indent()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string<-any-indent", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_from_any_indent
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_from_any_indent
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var indent : vx_core.Type_int = vx_core.f_any_from_any(vx_core.t_int, arglist.vx_any(vx_core.vx_new_int(1)))
      var linefeed : vx_core.Type_boolean = vx_core.f_any_from_any(vx_core.t_boolean, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_string_from_any_indent(value, indent, linefeed)
      return output
    }

    override fun vx_string_from_any_indent(value : vx_core.Type_any, indent : vx_core.Type_int, linefeed : vx_core.Type_boolean) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_string_from_any_indent(value, indent, linefeed)
      return output
    }

  }

  val e_string_from_any_indent : vx_core.Func_string_from_any_indent = vx_core.Class_string_from_any_indent()
  val t_string_from_any_indent : vx_core.Func_string_from_any_indent = vx_core.Class_string_from_any_indent()

  fun f_string_from_any_indent(value : vx_core.Type_any, indent : vx_core.Type_int, linefeed : vx_core.Type_boolean) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.vx_string_from_any_indent(value, indent, linefeed)
    return output
  }


  interface Func_string_from_func : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_string_from_func() : vx_core.Type_string
    fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_string_from_func
  }

  class Class_string_from_func : vx_core.Class_base, Func_string_from_func {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_func = vx_core.Class_string_from_func()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_func = vx_core.Class_string_from_func()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string<-func", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_from_func
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_from_func
      return output
    }

    var fn : Class_any_from_func.IFn? = null

    override fun vx_fn_new(fn : Class_any_from_func.IFn) : vx_core.Func_string_from_func {
      val output : vx_core.Class_string_from_func = vx_core.Class_string_from_func()
      output.fn = fn
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      output = vx_core.f_string_from_func()
      return output
    }

    override fun vx_string_from_func() : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_string_from_func()
      return output
    }

  }

  val e_string_from_func : vx_core.Func_string_from_func = vx_core.Class_string_from_func()
  val t_string_from_func : vx_core.Func_string_from_func = vx_core.Class_string_from_func()

  fun f_string_from_func() : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    return output
  }


  interface Func_string_from_string_find_replace : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_string_from_string_find_replace(text : vx_core.Type_string, find : vx_core.Type_string, replace : vx_core.Type_string) : vx_core.Type_string
  }

  class Class_string_from_string_find_replace : vx_core.Class_base, Func_string_from_string_find_replace {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_string_find_replace = vx_core.Class_string_from_string_find_replace()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_string_from_string_find_replace = vx_core.Class_string_from_string_find_replace()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "string<-string-find-replace", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_string_from_string_find_replace
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_string_from_string_find_replace
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var text : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(0)))
      var find : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(1)))
      var replace : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, arglist.vx_any(vx_core.vx_new_int(2)))
      output = vx_core.f_string_from_string_find_replace(text, find, replace)
      return output
    }

    override fun vx_string_from_string_find_replace(text : vx_core.Type_string, find : vx_core.Type_string, replace : vx_core.Type_string) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_string_from_string_find_replace(text, find, replace)
      return output
    }

  }

  val e_string_from_string_find_replace : vx_core.Func_string_from_string_find_replace = vx_core.Class_string_from_string_find_replace()
  val t_string_from_string_find_replace : vx_core.Func_string_from_string_find_replace = vx_core.Class_string_from_string_find_replace()

  fun f_string_from_string_find_replace(text : vx_core.Type_string, find : vx_core.Type_string, replace : vx_core.Type_string) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.vx_string_from_string_find_replace(text, find, replace)
    return output
  }


  interface Func_stringlist_from_map : vx_core.Func_any_from_any {
    fun vx_stringlist_from_map(map : vx_core.Type_map) : vx_core.Type_stringlist
  }

  class Class_stringlist_from_map : vx_core.Class_base, Func_stringlist_from_map {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_stringlist_from_map = vx_core.Class_stringlist_from_map()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_stringlist_from_map = vx_core.Class_stringlist_from_map()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "stringlist<-map", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_stringlist_from_map
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_stringlist_from_map
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_map = value as vx_core.Type_map
      var outputval : vx_core.Type_any = vx_core.f_stringlist_from_map(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var map : vx_core.Type_map = vx_core.f_any_from_any(vx_core.t_map, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_stringlist_from_map(map)
      return output
    }

    override fun vx_stringlist_from_map(map : vx_core.Type_map) : vx_core.Type_stringlist {
      var output : vx_core.Type_stringlist = vx_core.f_stringlist_from_map(map)
      return output
    }

  }

  val e_stringlist_from_map : vx_core.Func_stringlist_from_map = vx_core.Class_stringlist_from_map()
  val t_stringlist_from_map : vx_core.Func_stringlist_from_map = vx_core.Class_stringlist_from_map()

  fun f_stringlist_from_map(map : vx_core.Type_map) : vx_core.Type_stringlist {
    var output : vx_core.Type_stringlist = vx_core.e_stringlist
    output = vx_core.f_list_from_map_1(
      vx_core.t_stringlist,
      map,
      vx_core.t_any_from_key_value.vx_fn_new({key_any : vx_core.Type_any, value_any : vx_core.Type_any ->
        var key : vx_core.Type_string = vx_core.f_any_from_any(vx_core.t_string, key_any)
        var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, value_any)
        var output_1 : vx_core.Type_any = key
        output_1
      })
    )
    return output
  }


  interface Func_switch : vx_core.Type_func, vx_core.Type_replfunc {
    fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_switch(generic_any_1 : T, value : U, thenelselist : vx_core.Type_thenelselist) : T
  }

  class Class_switch : vx_core.Class_base, Func_switch {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_switch = vx_core.Class_switch()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_switch = vx_core.Class_switch()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "switch", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any-1", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_switch
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_switch
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var generic_any_1 : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      var thenelselist : vx_core.Type_thenelselist = vx_core.f_any_from_any(vx_core.t_thenelselist, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_switch(generic_any_1, value, thenelselist)
      return output
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_switch(generic_any_1 : T, value : U, thenelselist : vx_core.Type_thenelselist) : T {
      var output : T = vx_core.f_switch(generic_any_1, value, thenelselist)
      return output
    }

  }

  val e_switch : vx_core.Func_switch = vx_core.Class_switch()
  val t_switch : vx_core.Func_switch = vx_core.Class_switch()

  fun <T : vx_core.Type_any, U : vx_core.Type_any> f_switch(generic_any_1 : T, value : U, thenelselist : vx_core.Type_thenelselist) : T {
    var output : T = vx_core.f_empty(generic_any_1)
    output = vx_core.vx_switch(generic_any_1, value, thenelselist)
    return output
  }


  interface Func_then : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_then(fn_cond : vx_core.Func_boolean_from_func, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse
  }

  class Class_then : vx_core.Class_base, Func_then {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_then = vx_core.Class_then()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_then = vx_core.Class_then()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "then", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "thenelse", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_then
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_then
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var fn_cond : vx_core.Func_boolean_from_func = vx_core.f_any_from_any(vx_core.t_boolean_from_func, arglist.vx_any(vx_core.vx_new_int(0)))
      var fn_any : vx_core.Func_any_from_func = vx_core.f_any_from_any(vx_core.t_any_from_func, arglist.vx_any(vx_core.vx_new_int(1)))
      output = vx_core.f_then(fn_cond, fn_any)
      return output
    }

    override fun vx_then(fn_cond : vx_core.Func_boolean_from_func, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
      var output : vx_core.Type_thenelse = vx_core.f_then(fn_cond, fn_any)
      return output
    }

  }

  val e_then : vx_core.Func_then = vx_core.Class_then()
  val t_then : vx_core.Func_then = vx_core.Class_then()

  fun f_then(fn_cond : vx_core.Func_boolean_from_func, fn_any : vx_core.Func_any_from_func) : vx_core.Type_thenelse {
    var output : vx_core.Type_thenelse = vx_core.e_thenelse
    output = vx_core.f_new(
      vx_core.t_thenelse,
      vx_core.vx_new(
        vx_core.t_anylist,
        vx_core.vx_new_string(":code"),
        vx_core.vx_new_string(":then"),
        vx_core.vx_new_string(":fn-cond"),
        fn_cond,
        vx_core.vx_new_string(":fn-any"),
        fn_any
      )
    )
    return output
  }


  interface Func_traits_from_typedef : vx_core.Func_any_from_any {
    fun vx_traits_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist
  }

  class Class_traits_from_typedef : vx_core.Class_base, Func_traits_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_traits_from_typedef = vx_core.Class_traits_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_traits_from_typedef = vx_core.Class_traits_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "traits<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "typelist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_any), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_traits_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_traits_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_traits_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_traits_from_typedef(vtypedef)
      return output
    }

    override fun vx_traits_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist {
      var output : vx_core.Type_typelist = vx_core.f_traits_from_typedef(vtypedef)
      return output
    }

  }

  val e_traits_from_typedef : vx_core.Func_traits_from_typedef = vx_core.Class_traits_from_typedef()
  val t_traits_from_typedef : vx_core.Func_traits_from_typedef = vx_core.Class_traits_from_typedef()

  fun f_traits_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_typelist {
    var output : vx_core.Type_typelist = vx_core.e_typelist
    output = vtypedef.traits()
    return output
  }


  interface Func_type_from_any : vx_core.Func_any_from_any {
    fun vx_type_from_any(value : vx_core.Type_any) : vx_core.Type_any
  }

  class Class_type_from_any : vx_core.Class_base, Func_type_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_type_from_any = vx_core.Class_type_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_type_from_any = vx_core.Class_type_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "type<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "any", // name
          "", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_type_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_type_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_type_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_type_from_any(value)
      return output
    }

    override fun vx_type_from_any(value : vx_core.Type_any) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.f_type_from_any(value)
      return output
    }

  }

  val e_type_from_any : vx_core.Func_type_from_any = vx_core.Class_type_from_any()
  val t_type_from_any : vx_core.Func_type_from_any = vx_core.Class_type_from_any()

  fun f_type_from_any(value : vx_core.Type_any) : vx_core.Type_any {
    var output : vx_core.Type_any = vx_core.e_any
    output = value.vx_type()
    return output
  }


  interface Func_typedef_from_any : vx_core.Func_any_from_any {
    fun vx_typedef_from_any(value : vx_core.Type_any) : vx_core.Type_typedef
  }

  class Class_typedef_from_any : vx_core.Class_base, Func_typedef_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typedef_from_any = vx_core.Class_typedef_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typedef_from_any = vx_core.Class_typedef_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typedef<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "typedef", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typedef_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typedef_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_typedef_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typedef_from_any(value)
      return output
    }

    override fun vx_typedef_from_any(value : vx_core.Type_any) : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.f_typedef_from_any(value)
      return output
    }

  }

  val e_typedef_from_any : vx_core.Func_typedef_from_any = vx_core.Class_typedef_from_any()
  val t_typedef_from_any : vx_core.Func_typedef_from_any = vx_core.Class_typedef_from_any()

  fun f_typedef_from_any(value : vx_core.Type_any) : vx_core.Type_typedef {
    var output : vx_core.Type_typedef = vx_core.e_typedef
    output = vx_core.f_typedef_from_type(
      vx_core.f_type_from_any(
        value
      )
    )
    return output
  }


  interface Func_typedef_from_type : vx_core.Func_any_from_any {
    fun vx_typedef_from_type(value : vx_core.Type_any) : vx_core.Type_typedef
  }

  class Class_typedef_from_type : vx_core.Class_base, Func_typedef_from_type {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typedef_from_type = vx_core.Class_typedef_from_type()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typedef_from_type = vx_core.Class_typedef_from_type()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typedef<-type", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "typedef", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typedef_from_type
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typedef_from_type
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_typedef_from_type(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typedef_from_type(value)
      return output
    }

    override fun vx_typedef_from_type(value : vx_core.Type_any) : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.f_typedef_from_type(value)
      return output
    }

  }

  val e_typedef_from_type : vx_core.Func_typedef_from_type = vx_core.Class_typedef_from_type()
  val t_typedef_from_type : vx_core.Func_typedef_from_type = vx_core.Class_typedef_from_type()

  fun f_typedef_from_type(value : vx_core.Type_any) : vx_core.Type_typedef {
    var output : vx_core.Type_typedef = vx_core.e_typedef
    output = value.vx_typedef()
    return output
  }


  interface Func_typename_from_any : vx_core.Func_any_from_any {
    fun vx_typename_from_any(value : vx_core.Type_any) : vx_core.Type_string
  }

  class Class_typename_from_any : vx_core.Class_base, Func_typename_from_any {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typename_from_any = vx_core.Class_typename_from_any()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typename_from_any = vx_core.Class_typename_from_any()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typename<-any", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typename_from_any
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typename_from_any
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_typename_from_any(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var value : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typename_from_any(value)
      return output
    }

    override fun vx_typename_from_any(value : vx_core.Type_any) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_typename_from_any(value)
      return output
    }

  }

  val e_typename_from_any : vx_core.Func_typename_from_any = vx_core.Class_typename_from_any()
  val t_typename_from_any : vx_core.Func_typename_from_any = vx_core.Class_typename_from_any()

  fun f_typename_from_any(value : vx_core.Type_any) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_typename_from_type(
      vx_core.f_type_from_any(
        value
      )
    )
    return output
  }


  interface Func_typename_from_type : vx_core.Func_any_from_any {
    fun vx_typename_from_type(type : vx_core.Type_any) : vx_core.Type_string
  }

  class Class_typename_from_type : vx_core.Class_base, Func_typename_from_type {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typename_from_type = vx_core.Class_typename_from_type()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typename_from_type = vx_core.Class_typename_from_type()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typename<-type", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typename_from_type
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typename_from_type
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_any = value as vx_core.Type_any
      var outputval : vx_core.Type_any = vx_core.f_typename_from_type(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var type : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typename_from_type(type)
      return output
    }

    override fun vx_typename_from_type(type : vx_core.Type_any) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_typename_from_type(type)
      return output
    }

  }

  val e_typename_from_type : vx_core.Func_typename_from_type = vx_core.Class_typename_from_type()
  val t_typename_from_type : vx_core.Func_typename_from_type = vx_core.Class_typename_from_type()

  fun f_typename_from_type(type : vx_core.Type_any) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_typename_from_typedef(
      vx_core.f_typedef_from_type(
        type
      )
    )
    return output
  }


  interface Func_typename_from_typedef : vx_core.Func_any_from_any {
    fun vx_typename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string
  }

  class Class_typename_from_typedef : vx_core.Class_base, Func_typename_from_typedef {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typename_from_typedef = vx_core.Class_typename_from_typedef()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typename_from_typedef = vx_core.Class_typename_from_typedef()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typename<-typedef", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "string", // name
          ":string", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typename_from_typedef
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typename_from_typedef
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typedef = value as vx_core.Type_typedef
      var outputval : vx_core.Type_any = vx_core.f_typename_from_typedef(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var vtypedef : vx_core.Type_typedef = vx_core.f_any_from_any(vx_core.t_typedef, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typename_from_typedef(vtypedef)
      return output
    }

    override fun vx_typename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
      var output : vx_core.Type_string = vx_core.f_typename_from_typedef(vtypedef)
      return output
    }

  }

  val e_typename_from_typedef : vx_core.Func_typename_from_typedef = vx_core.Class_typename_from_typedef()
  val t_typename_from_typedef : vx_core.Func_typename_from_typedef = vx_core.Class_typename_from_typedef()

  fun f_typename_from_typedef(vtypedef : vx_core.Type_typedef) : vx_core.Type_string {
    var output : vx_core.Type_string = vx_core.e_string
    output = vx_core.f_new(
      vx_core.t_string,
      vx_core.vx_new(
        vx_core.t_anylist,
        vtypedef.pkgname(),
        vx_core.vx_new_string("/"),
        vtypedef.name()
      )
    )
    return output
  }


  interface Func_typenames_from_typelist : vx_core.Func_any_from_any {
    fun vx_typenames_from_typelist(typelist : vx_core.Type_typelist) : vx_core.Type_stringlist
  }

  class Class_typenames_from_typelist : vx_core.Class_base, Func_typenames_from_typelist {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typenames_from_typelist = vx_core.Class_typenames_from_typelist()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_typenames_from_typelist = vx_core.Class_typenames_from_typelist()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "typenames<-typelist", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "stringlist", // name
          ":list", // extends
          vx_core.e_typelist, // traits
          vx_core.vx_new(vx_core.t_typelist, vx_core.t_string), // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_typenames_from_typelist
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_typenames_from_typelist
      return output
    }

    override fun vx_fn_new(fn : vx_core.Class_any_from_any.IFn) : vx_core.Func_any_from_any {
      return vx_core.e_any_from_any
    }

    override fun <T : vx_core.Type_any, U : vx_core.Type_any> vx_any_from_any(generic_any_1 : T, value : U) : T {
      var output : T = vx_core.f_empty(generic_any_1)
      var inputval : vx_core.Type_typelist = value as vx_core.Type_typelist
      var outputval : vx_core.Type_any = vx_core.f_typenames_from_typelist(inputval)
      output = vx_core.f_any_from_any(generic_any_1, outputval)
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var typelist : vx_core.Type_typelist = vx_core.f_any_from_any(vx_core.t_typelist, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_typenames_from_typelist(typelist)
      return output
    }

    override fun vx_typenames_from_typelist(typelist : vx_core.Type_typelist) : vx_core.Type_stringlist {
      var output : vx_core.Type_stringlist = vx_core.f_typenames_from_typelist(typelist)
      return output
    }

  }

  val e_typenames_from_typelist : vx_core.Func_typenames_from_typelist = vx_core.Class_typenames_from_typelist()
  val t_typenames_from_typelist : vx_core.Func_typenames_from_typelist = vx_core.Class_typenames_from_typelist()

  fun f_typenames_from_typelist(typelist : vx_core.Type_typelist) : vx_core.Type_stringlist {
    var output : vx_core.Type_stringlist = vx_core.e_stringlist
    output = vx_core.f_list_from_list_1(
      vx_core.t_stringlist,
      typelist,
      vx_core.t_any_from_any.vx_fn_new({type_any : vx_core.Type_any ->
        var type : vx_core.Type_any = vx_core.f_any_from_any(vx_core.t_any, type_any)
        var output_1 : vx_core.Type_any = vx_core.f_typename_from_type(
          type
        )
        output_1
      })
    )
    return output
  }


  interface Func_user_from_context : vx_core.Type_func, vx_core.Type_replfunc {
    fun vx_user_from_context(context : vx_core.Type_context) : vx_core.Type_user
  }

  class Class_user_from_context : vx_core.Class_base, Func_user_from_context {
    constructor() {}

    override fun vx_new(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_user_from_context = vx_core.Class_user_from_context()
      return output
    }

    override fun vx_copy(vararg vals : Any) : vx_core.Type_any {
      val output : vx_core.Class_user_from_context = vx_core.Class_user_from_context()
      return output
    }

    override fun vx_typedef() : vx_core.Type_typedef {
      var output : vx_core.Type_typedef = vx_core.t_func.vx_typedef()
      return output
    }

    override fun vx_funcdef() : vx_core.Type_funcdef {
      var output : vx_core.Type_funcdef = vx_core.funcdef_new(
        "vx/core", // pkgname
        "user<-context", // name
        0, // idx
        false, // async
        vx_core.typedef_new(
          "vx/core", // pkgname
          "user", // name
          ":struct", // extends
          vx_core.e_typelist, // traits
          vx_core.e_typelist, // allowtypes
          vx_core.e_typelist, // disallowtypes
          vx_core.e_funclist, // allowfuncs
          vx_core.e_funclist, // disallowfuncs
          vx_core.e_anylist, // allowvalues
          vx_core.e_anylist, // disallowvalues
          vx_core.e_argmap // properties
        ) // typedef
      )
      return output
    }

    override fun vx_empty() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_user_from_context
      return output
    }

    override fun vx_type() : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.t_user_from_context
      return output
    }

    override fun vx_repl(arglist : vx_core.Type_anylist) : vx_core.Type_any {
      var output : vx_core.Type_any = vx_core.e_any
      var context : vx_core.Type_context = vx_core.f_any_from_any(vx_core.t_context, arglist.vx_any(vx_core.vx_new_int(0)))
      output = vx_core.f_user_from_context(context)
      return output
    }

    override fun vx_user_from_context(context : vx_core.Type_context) : vx_core.Type_user {
      var output : vx_core.Type_user = vx_core.f_user_from_context(context)
      return output
    }

  }

  val e_user_from_context : vx_core.Func_user_from_context = vx_core.Class_user_from_context()
  val t_user_from_context : vx_core.Func_user_from_context = vx_core.Class_user_from_context()

  fun f_user_from_context(context : vx_core.Type_context) : vx_core.Type_user {
    var output : vx_core.Type_user = vx_core.e_user
    output = vx_core.f_session_from_context(
      context
    ).user()
    return output
  }


  init {
    Const_false.const_new(c_false)
    Const_global.const_new(c_global)
    Const_infinity.const_new(c_infinity)
    Const_mempool_active.const_new(c_mempool_active)
    Const_msg_error.const_new(c_msg_error)
    Const_msg_info.const_new(c_msg_info)
    Const_msg_severe.const_new(c_msg_severe)
    Const_msg_warning.const_new(c_msg_warning)
    Const_neginfinity.const_new(c_neginfinity)
    Const_newline.const_new(c_newline)
    Const_notanumber.const_new(c_notanumber)
    Const_nothing.const_new(c_nothing)
    Const_path_test_resources.const_new(c_path_test_resources)
    Const_quote.const_new(c_quote)
    Const_true.const_new(c_true)
    var maptype : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
    var mapconst : MutableMap<String, vx_core.Type_any> = LinkedHashMap<String, vx_core.Type_any>()
    var mapfunc : MutableMap<String, vx_core.Type_func> = LinkedHashMap<String, vx_core.Type_func>()
    maptype.put("any", vx_core.t_any)
    maptype.put("any-async<-func", vx_core.t_any_async_from_func)
    maptype.put("any<-anylist", vx_core.t_any_from_anylist)
    maptype.put("anylist", vx_core.t_anylist)
    maptype.put("anymap", vx_core.t_anymap)
    maptype.put("anytype", vx_core.t_anytype)
    maptype.put("arg", vx_core.t_arg)
    maptype.put("arglist", vx_core.t_arglist)
    maptype.put("argmap", vx_core.t_argmap)
    maptype.put("boolean", vx_core.t_boolean)
    maptype.put("booleanlist", vx_core.t_booleanlist)
    maptype.put("collection", vx_core.t_collection)
    maptype.put("compilelanguages", vx_core.t_compilelanguages)
    maptype.put("connect", vx_core.t_connect)
    maptype.put("connectlist", vx_core.t_connectlist)
    maptype.put("connectmap", vx_core.t_connectmap)
    maptype.put("const", vx_core.t_const)
    maptype.put("constdef", vx_core.t_constdef)
    maptype.put("constlist", vx_core.t_constlist)
    maptype.put("constmap", vx_core.t_constmap)
    maptype.put("context", vx_core.t_context)
    maptype.put("date", vx_core.t_date)
    maptype.put("decimal", vx_core.t_decimal)
    maptype.put("error", vx_core.t_error)
    maptype.put("float", vx_core.t_float)
    maptype.put("func", vx_core.t_func)
    maptype.put("funcdef", vx_core.t_funcdef)
    maptype.put("funclist", vx_core.t_funclist)
    maptype.put("funcmap", vx_core.t_funcmap)
    maptype.put("int", vx_core.t_int)
    maptype.put("intlist", vx_core.t_intlist)
    maptype.put("intmap", vx_core.t_intmap)
    maptype.put("list", vx_core.t_list)
    maptype.put("listtype", vx_core.t_listtype)
    maptype.put("locale", vx_core.t_locale)
    maptype.put("map", vx_core.t_map)
    maptype.put("maptype", vx_core.t_maptype)
    maptype.put("mempool", vx_core.t_mempool)
    maptype.put("msg", vx_core.t_msg)
    maptype.put("msgblock", vx_core.t_msgblock)
    maptype.put("msgblocklist", vx_core.t_msgblocklist)
    maptype.put("msglist", vx_core.t_msglist)
    maptype.put("none", vx_core.t_none)
    maptype.put("notype", vx_core.t_notype)
    maptype.put("number", vx_core.t_number)
    maptype.put("numberlist", vx_core.t_numberlist)
    maptype.put("numbermap", vx_core.t_numbermap)
    maptype.put("package", vx_core.t_package)
    maptype.put("packagemap", vx_core.t_packagemap)
    maptype.put("permission", vx_core.t_permission)
    maptype.put("permissionlist", vx_core.t_permissionlist)
    maptype.put("permissionmap", vx_core.t_permissionmap)
    maptype.put("project", vx_core.t_project)
    maptype.put("security", vx_core.t_security)
    maptype.put("session", vx_core.t_session)
    maptype.put("setting", vx_core.t_setting)
    maptype.put("state", vx_core.t_state)
    maptype.put("statelistener", vx_core.t_statelistener)
    maptype.put("statelistenermap", vx_core.t_statelistenermap)
    maptype.put("string", vx_core.t_string)
    maptype.put("stringlist", vx_core.t_stringlist)
    maptype.put("stringlistlist", vx_core.t_stringlistlist)
    maptype.put("stringmap", vx_core.t_stringmap)
    maptype.put("stringmutablemap", vx_core.t_stringmutablemap)
    maptype.put("struct", vx_core.t_struct)
    maptype.put("thenelse", vx_core.t_thenelse)
    maptype.put("thenelselist", vx_core.t_thenelselist)
    maptype.put("translation", vx_core.t_translation)
    maptype.put("translationlist", vx_core.t_translationlist)
    maptype.put("translationmap", vx_core.t_translationmap)
    maptype.put("type", vx_core.t_type)
    maptype.put("typedef", vx_core.t_typedef)
    maptype.put("typelist", vx_core.t_typelist)
    maptype.put("typemap", vx_core.t_typemap)
    maptype.put("user", vx_core.t_user)
    maptype.put("value", vx_core.t_value)
    mapconst.put("false", vx_core.c_false)
    mapconst.put("global", vx_core.c_global)
    mapconst.put("infinity", vx_core.c_infinity)
    mapconst.put("mempool-active", vx_core.c_mempool_active)
    mapconst.put("msg-error", vx_core.c_msg_error)
    mapconst.put("msg-info", vx_core.c_msg_info)
    mapconst.put("msg-severe", vx_core.c_msg_severe)
    mapconst.put("msg-warning", vx_core.c_msg_warning)
    mapconst.put("neginfinity", vx_core.c_neginfinity)
    mapconst.put("newline", vx_core.c_newline)
    mapconst.put("notanumber", vx_core.c_notanumber)
    mapconst.put("nothing", vx_core.c_nothing)
    mapconst.put("path-test-resources", vx_core.c_path_test_resources)
    mapconst.put("quote", vx_core.c_quote)
    mapconst.put("true", vx_core.c_true)
    mapfunc.put("!", vx_core.t_not)
    mapfunc.put("!-empty", vx_core.t_notempty)
    mapfunc.put("!-empty_1", vx_core.t_notempty_1)
    mapfunc.put("!=", vx_core.t_ne)
    mapfunc.put("!==", vx_core.t_neqeq)
    mapfunc.put("*", vx_core.t_multiply)
    mapfunc.put("*_1", vx_core.t_multiply_1)
    mapfunc.put("*_2", vx_core.t_multiply_2)
    mapfunc.put("*_3", vx_core.t_multiply_3)
    mapfunc.put("+", vx_core.t_plus)
    mapfunc.put("+_1", vx_core.t_plus_1)
    mapfunc.put("+_2", vx_core.t_plus_2)
    mapfunc.put("+_3", vx_core.t_plus_3)
    mapfunc.put("+1", vx_core.t_plus1)
    mapfunc.put("-", vx_core.t_minus)
    mapfunc.put("-_1", vx_core.t_minus_1)
    mapfunc.put("-_2", vx_core.t_minus_2)
    mapfunc.put("-_3", vx_core.t_minus_3)
    mapfunc.put("-1", vx_core.t_minus1)
    mapfunc.put(".", vx_core.t_dotmethod)
    mapfunc.put("/", vx_core.t_divide)
    mapfunc.put("<", vx_core.t_lt)
    mapfunc.put("<_1", vx_core.t_lt_1)
    mapfunc.put("<-", vx_core.t_chainfirst)
    mapfunc.put("<<-", vx_core.t_chainlast)
    mapfunc.put("<=", vx_core.t_le)
    mapfunc.put("<=_1", vx_core.t_le_1)
    mapfunc.put("=", vx_core.t_eq)
    mapfunc.put("=_1", vx_core.t_eq_1)
    mapfunc.put("==", vx_core.t_eqeq)
    mapfunc.put(">", vx_core.t_gt)
    mapfunc.put(">_1", vx_core.t_gt_1)
    mapfunc.put(">=", vx_core.t_ge)
    mapfunc.put(">=_1", vx_core.t_ge_1)
    mapfunc.put("allowfuncs<-security", vx_core.t_allowfuncs_from_security)
    mapfunc.put("allowtypenames<-typedef", vx_core.t_allowtypenames_from_typedef)
    mapfunc.put("allowtypes<-typedef", vx_core.t_allowtypes_from_typedef)
    mapfunc.put("and", vx_core.t_and)
    mapfunc.put("and_1", vx_core.t_and_1)
    mapfunc.put("any<-any", vx_core.t_any_from_any)
    mapfunc.put("any<-any-async", vx_core.t_any_from_any_async)
    mapfunc.put("any<-any-context", vx_core.t_any_from_any_context)
    mapfunc.put("any<-any-context-async", vx_core.t_any_from_any_context_async)
    mapfunc.put("any<-any-key-value", vx_core.t_any_from_any_key_value)
    mapfunc.put("any<-func", vx_core.t_any_from_func)
    mapfunc.put("any<-func-async", vx_core.t_any_from_func_async)
    mapfunc.put("any<-int", vx_core.t_any_from_int)
    mapfunc.put("any<-int-any", vx_core.t_any_from_int_any)
    mapfunc.put("any<-key-value", vx_core.t_any_from_key_value)
    mapfunc.put("any<-key-value-async", vx_core.t_any_from_key_value_async)
    mapfunc.put("any<-list", vx_core.t_any_from_list)
    mapfunc.put("any<-list-start-reduce", vx_core.t_any_from_list_start_reduce)
    mapfunc.put("any<-list-start-reduce-next", vx_core.t_any_from_list_start_reduce_next)
    mapfunc.put("any<-map", vx_core.t_any_from_map)
    mapfunc.put("any<-map-start-reduce", vx_core.t_any_from_map_start_reduce)
    mapfunc.put("any<-none", vx_core.t_any_from_none)
    mapfunc.put("any<-none-async", vx_core.t_any_from_none_async)
    mapfunc.put("any<-reduce", vx_core.t_any_from_reduce)
    mapfunc.put("any<-reduce-async", vx_core.t_any_from_reduce_async)
    mapfunc.put("any<-reduce-next", vx_core.t_any_from_reduce_next)
    mapfunc.put("any<-reduce-next-async", vx_core.t_any_from_reduce_next_async)
    mapfunc.put("any<-struct", vx_core.t_any_from_struct)
    mapfunc.put("async", vx_core.t_async)
    mapfunc.put("boolean-permission<-func", vx_core.t_boolean_permission_from_func)
    mapfunc.put("boolean-write<-map-name-value", vx_core.t_boolean_write_from_map_name_value)
    mapfunc.put("boolean<-any", vx_core.t_boolean_from_any)
    mapfunc.put("boolean<-func", vx_core.t_boolean_from_func)
    mapfunc.put("boolean<-none", vx_core.t_boolean_from_none)
    mapfunc.put("case", vx_core.t_case)
    mapfunc.put("case_1", vx_core.t_case_1)
    mapfunc.put("compare", vx_core.t_compare)
    mapfunc.put("contains", vx_core.t_contains)
    mapfunc.put("contains_1", vx_core.t_contains_1)
    mapfunc.put("context-main", vx_core.t_context_main)
    mapfunc.put("copy", vx_core.t_copy)
    mapfunc.put("else", vx_core.t_else)
    mapfunc.put("empty", vx_core.t_empty)
    mapfunc.put("extends<-any", vx_core.t_extends_from_any)
    mapfunc.put("extends<-typedef", vx_core.t_extends_from_typedef)
    mapfunc.put("first<-list", vx_core.t_first_from_list)
    mapfunc.put("first<-list-any<-any", vx_core.t_first_from_list_any_from_any)
    mapfunc.put("float<-string", vx_core.t_float_from_string)
    mapfunc.put("fn", vx_core.t_fn)
    mapfunc.put("funcdef<-func", vx_core.t_funcdef_from_func)
    mapfunc.put("funcname<-funcdef", vx_core.t_funcname_from_funcdef)
    mapfunc.put("if", vx_core.t_if)
    mapfunc.put("if_1", vx_core.t_if_1)
    mapfunc.put("if_2", vx_core.t_if_2)
    mapfunc.put("int<-func", vx_core.t_int_from_func)
    mapfunc.put("int<-string", vx_core.t_int_from_string)
    mapfunc.put("is-empty", vx_core.t_is_empty)
    mapfunc.put("is-empty_1", vx_core.t_is_empty_1)
    mapfunc.put("is-endswith", vx_core.t_is_endswith)
    mapfunc.put("is-float", vx_core.t_is_float)
    mapfunc.put("is-func", vx_core.t_is_func)
    mapfunc.put("is-int", vx_core.t_is_int)
    mapfunc.put("is-number", vx_core.t_is_number)
    mapfunc.put("is-pass<-permission", vx_core.t_is_pass_from_permission)
    mapfunc.put("last<-list", vx_core.t_last_from_list)
    mapfunc.put("length", vx_core.t_length)
    mapfunc.put("length_1", vx_core.t_length_1)
    mapfunc.put("length_2", vx_core.t_length_2)
    mapfunc.put("let", vx_core.t_let)
    mapfunc.put("let-async", vx_core.t_let_async)
    mapfunc.put("list-join<-list", vx_core.t_list_join_from_list)
    mapfunc.put("list-join<-list_1", vx_core.t_list_join_from_list_1)
    mapfunc.put("list<-list", vx_core.t_list_from_list)
    mapfunc.put("list<-list_1", vx_core.t_list_from_list_1)
    mapfunc.put("list<-list-async", vx_core.t_list_from_list_async)
    mapfunc.put("list<-list-intany", vx_core.t_list_from_list_intany)
    mapfunc.put("list<-map", vx_core.t_list_from_map)
    mapfunc.put("list<-map_1", vx_core.t_list_from_map_1)
    mapfunc.put("list<-map-async", vx_core.t_list_from_map_async)
    mapfunc.put("list<-type", vx_core.t_list_from_type)
    mapfunc.put("log", vx_core.t_log)
    mapfunc.put("log_1", vx_core.t_log_1)
    mapfunc.put("main", vx_core.t_main)
    mapfunc.put("map<-list", vx_core.t_map_from_list)
    mapfunc.put("map<-map", vx_core.t_map_from_map)
    mapfunc.put("map<-map_1", vx_core.t_map_from_map_1)
    mapfunc.put("msg<-error", vx_core.t_msg_from_error)
    mapfunc.put("msg<-error_1", vx_core.t_msg_from_error_1)
    mapfunc.put("msg<-error_2", vx_core.t_msg_from_error_2)
    mapfunc.put("msg<-warning", vx_core.t_msg_from_warning)
    mapfunc.put("msgblock<-msgblock-msg", vx_core.t_msgblock_from_msgblock_msg)
    mapfunc.put("msgblock<-msgblock-msgblock", vx_core.t_msgblock_from_msgblock_msgblock)
    mapfunc.put("name<-typedef", vx_core.t_name_from_typedef)
    mapfunc.put("native", vx_core.t_native)
    mapfunc.put("native<-any", vx_core.t_native_from_any)
    mapfunc.put("new", vx_core.t_new)
    mapfunc.put("new<-type", vx_core.t_new_from_type)
    mapfunc.put("number<-func", vx_core.t_number_from_func)
    mapfunc.put("or", vx_core.t_or)
    mapfunc.put("or_1", vx_core.t_or_1)
    mapfunc.put("package-global<-name", vx_core.t_package_global_from_name)
    mapfunc.put("packagename<-typedef", vx_core.t_packagename_from_typedef)
    mapfunc.put("path<-context-path", vx_core.t_path_from_context_path)
    mapfunc.put("path<-setting-path", vx_core.t_path_from_setting_path)
    mapfunc.put("permission<-id-context", vx_core.t_permission_from_id_context)
    mapfunc.put("properties<-typedef", vx_core.t_properties_from_typedef)
    mapfunc.put("proplast<-typedef", vx_core.t_proplast_from_typedef)
    mapfunc.put("resolve", vx_core.t_resolve)
    mapfunc.put("resolve_1", vx_core.t_resolve_1)
    mapfunc.put("resolve-async", vx_core.t_resolve_async)
    mapfunc.put("resolve-first", vx_core.t_resolve_first)
    mapfunc.put("resolve-list", vx_core.t_resolve_list)
    mapfunc.put("security<-context", vx_core.t_security_from_context)
    mapfunc.put("security<-user", vx_core.t_security_from_user)
    mapfunc.put("session<-context", vx_core.t_session_from_context)
    mapfunc.put("setting<-context", vx_core.t_setting_from_context)
    mapfunc.put("string-repeat", vx_core.t_string_repeat)
    mapfunc.put("string<-any", vx_core.t_string_from_any)
    mapfunc.put("string<-any-indent", vx_core.t_string_from_any_indent)
    mapfunc.put("string<-func", vx_core.t_string_from_func)
    mapfunc.put("string<-string-find-replace", vx_core.t_string_from_string_find_replace)
    mapfunc.put("stringlist<-map", vx_core.t_stringlist_from_map)
    mapfunc.put("switch", vx_core.t_switch)
    mapfunc.put("then", vx_core.t_then)
    mapfunc.put("traits<-typedef", vx_core.t_traits_from_typedef)
    mapfunc.put("type<-any", vx_core.t_type_from_any)
    mapfunc.put("typedef<-any", vx_core.t_typedef_from_any)
    mapfunc.put("typedef<-type", vx_core.t_typedef_from_type)
    mapfunc.put("typename<-any", vx_core.t_typename_from_any)
    mapfunc.put("typename<-type", vx_core.t_typename_from_type)
    mapfunc.put("typename<-typedef", vx_core.t_typename_from_typedef)
    mapfunc.put("typenames<-typelist", vx_core.t_typenames_from_typelist)
    mapfunc.put("user<-context", vx_core.t_user_from_context)
    vx_core.vx_global_package_set("vx/core", maptype, mapconst, mapfunc)
  }

}
